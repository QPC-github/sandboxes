import {
  getControlId
} from "./chunk-XODJ6PPZ.mjs";

// src/controls/Color.tsx
import React, {
  useCallback,
  useEffect,
  useMemo,
  useState
} from "react";
import { HexColorPicker, HslaStringColorPicker, RgbaStringColorPicker } from "react-colorful";
import convert from "color-convert";
import throttle from "lodash/throttle";
import { styled } from "@storybook/theming";
import { TooltipNote, WithTooltip, Form, Icons } from "@storybook/components";
var Wrapper = styled.div({
  position: "relative",
  maxWidth: 250
});
var PickerTooltip = styled(WithTooltip)({
  position: "absolute",
  zIndex: 1,
  top: 4,
  left: 4
});
var TooltipContent = styled.div({
  width: 200,
  margin: 5,
  ".react-colorful__saturation": {
    borderRadius: "4px 4px 0 0"
  },
  ".react-colorful__hue": {
    boxShadow: "inset 0 0 0 1px rgb(0 0 0 / 5%)"
  },
  ".react-colorful__last-control": {
    borderRadius: "0 0 4px 4px"
  }
});
var Note = styled(TooltipNote)(({ theme }) => ({
  fontFamily: theme.typography.fonts.base
}));
var Swatches = styled.div({
  display: "grid",
  gridTemplateColumns: "repeat(9, 16px)",
  gap: 6,
  padding: 3,
  marginTop: 5,
  width: 200
});
var SwatchColor = styled.div(({ theme, active }) => ({
  width: 16,
  height: 16,
  boxShadow: active ? `${theme.appBorderColor} 0 0 0 1px inset, ${theme.color.mediumdark}50 0 0 0 4px` : `${theme.appBorderColor} 0 0 0 1px inset`,
  borderRadius: theme.appBorderRadius
}));
var swatchBackground = `url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')`;
var Swatch = ({ value, active, onClick, style, ...props }) => {
  const backgroundImage = `linear-gradient(${value}, ${value}), ${swatchBackground}, linear-gradient(#fff, #fff)`;
  return /* @__PURE__ */ React.createElement(SwatchColor, {
    ...props,
    ...{ active, onClick },
    style: { ...style, backgroundImage }
  });
};
var Input = styled(Form.Input)(({ theme }) => ({
  width: "100%",
  paddingLeft: 30,
  paddingRight: 30,
  boxSizing: "border-box",
  fontFamily: theme.typography.fonts.base
}));
var ToggleIcon = styled(Icons)(({ theme }) => ({
  position: "absolute",
  zIndex: 1,
  top: 6,
  right: 7,
  width: 20,
  height: 20,
  padding: 4,
  boxSizing: "border-box",
  cursor: "pointer",
  color: theme.input.color
}));
var ColorSpace = /* @__PURE__ */ ((ColorSpace2) => {
  ColorSpace2["RGB"] = "rgb";
  ColorSpace2["HSL"] = "hsl";
  ColorSpace2["HEX"] = "hex";
  return ColorSpace2;
})(ColorSpace || {});
var COLOR_SPACES = Object.values(ColorSpace);
var COLOR_REGEXP = /\(([0-9]+),\s*([0-9]+)%?,\s*([0-9]+)%?,?\s*([0-9.]+)?\)/;
var RGB_REGEXP = /^\s*rgba?\(([0-9]+),\s*([0-9]+),\s*([0-9]+),?\s*([0-9.]+)?\)\s*$/i;
var HSL_REGEXP = /^\s*hsla?\(([0-9]+),\s*([0-9]+)%,\s*([0-9]+)%,?\s*([0-9.]+)?\)\s*$/i;
var HEX_REGEXP = /^\s*#?([0-9a-f]{3}|[0-9a-f]{6})\s*$/i;
var SHORTHEX_REGEXP = /^\s*#?([0-9a-f]{3})\s*$/i;
var ColorPicker = {
  ["hex" /* HEX */]: HexColorPicker,
  ["rgb" /* RGB */]: RgbaStringColorPicker,
  ["hsl" /* HSL */]: HslaStringColorPicker
};
var fallbackColor = {
  ["hex" /* HEX */]: "transparent",
  ["rgb" /* RGB */]: "rgba(0, 0, 0, 0)",
  ["hsl" /* HSL */]: "hsla(0, 0%, 0%, 0)"
};
var stringToArgs = (value) => {
  const match = value?.match(COLOR_REGEXP);
  if (!match)
    return [0, 0, 0, 1];
  const [, x, y, z, a = 1] = match;
  return [x, y, z, a].map(Number);
};
var parseValue = (value) => {
  if (!value)
    return void 0;
  let valid = true;
  if (RGB_REGEXP.test(value)) {
    const [r, g, b, a] = stringToArgs(value);
    const [h, s, l] = convert.rgb.hsl([r, g, b]) || [0, 0, 0];
    return {
      valid,
      value,
      keyword: convert.rgb.keyword([r, g, b]),
      colorSpace: "rgb" /* RGB */,
      ["rgb" /* RGB */]: value,
      ["hsl" /* HSL */]: `hsla(${h}, ${s}%, ${l}%, ${a})`,
      ["hex" /* HEX */]: `#${convert.rgb.hex([r, g, b]).toLowerCase()}`
    };
  }
  if (HSL_REGEXP.test(value)) {
    const [h, s, l, a] = stringToArgs(value);
    const [r, g, b] = convert.hsl.rgb([h, s, l]) || [0, 0, 0];
    return {
      valid,
      value,
      keyword: convert.hsl.keyword([h, s, l]),
      colorSpace: "hsl" /* HSL */,
      ["rgb" /* RGB */]: `rgba(${r}, ${g}, ${b}, ${a})`,
      ["hsl" /* HSL */]: value,
      ["hex" /* HEX */]: `#${convert.hsl.hex([h, s, l]).toLowerCase()}`
    };
  }
  const plain = value.replace("#", "");
  const rgb = convert.keyword.rgb(plain) || convert.hex.rgb(plain);
  const hsl = convert.rgb.hsl(rgb);
  let mapped = value;
  if (/[^#a-f0-9]/i.test(value))
    mapped = plain;
  else if (HEX_REGEXP.test(value))
    mapped = `#${plain}`;
  if (mapped.startsWith("#")) {
    valid = HEX_REGEXP.test(mapped);
  } else {
    try {
      convert.keyword.hex(mapped);
    } catch (e) {
      valid = false;
    }
  }
  return {
    valid,
    value: mapped,
    keyword: convert.rgb.keyword(rgb),
    colorSpace: "hex" /* HEX */,
    ["rgb" /* RGB */]: `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 1)`,
    ["hsl" /* HSL */]: `hsla(${hsl[0]}, ${hsl[1]}%, ${hsl[2]}%, 1)`,
    ["hex" /* HEX */]: mapped
  };
};
var getRealValue = (value, color, colorSpace) => {
  if (!value || !color?.valid)
    return fallbackColor[colorSpace];
  if (colorSpace !== "hex" /* HEX */)
    return color?.[colorSpace] || fallbackColor[colorSpace];
  if (!color.hex.startsWith("#")) {
    try {
      return `#${convert.keyword.hex(color.hex)}`;
    } catch (e) {
      return fallbackColor.hex;
    }
  }
  const short = color.hex.match(SHORTHEX_REGEXP);
  if (!short)
    return HEX_REGEXP.test(color.hex) ? color.hex : fallbackColor.hex;
  const [r, g, b] = short[1].split("");
  return `#${r}${r}${g}${g}${b}${b}`;
};
var useColorInput = (initialValue, onChange) => {
  const [value, setValue] = useState(initialValue || "");
  const [color, setColor] = useState(() => parseValue(value));
  const [colorSpace, setColorSpace] = useState(color?.colorSpace || "hex" /* HEX */);
  useEffect(() => {
    if (initialValue !== void 0)
      return;
    setValue("");
    setColor(void 0);
    setColorSpace("hex" /* HEX */);
  }, [initialValue]);
  const realValue = useMemo(
    () => getRealValue(value, color, colorSpace).toLowerCase(),
    [value, color, colorSpace]
  );
  const updateValue = useCallback(
    (update) => {
      const parsed = parseValue(update);
      const v = parsed?.value || update || "";
      setValue(v);
      if (v === "") {
        setColor(void 0);
        onChange(void 0);
      }
      if (!parsed) {
        return;
      }
      setColor(parsed);
      setColorSpace(parsed.colorSpace);
      onChange(parsed.value);
    },
    [onChange]
  );
  const cycleColorSpace = useCallback(() => {
    let next = COLOR_SPACES.indexOf(colorSpace) + 1;
    if (next >= COLOR_SPACES.length)
      next = 0;
    setColorSpace(COLOR_SPACES[next]);
    const update = color?.[COLOR_SPACES[next]] || "";
    setValue(update);
    onChange(update);
  }, [color, colorSpace, onChange]);
  return { value, realValue, updateValue, color, colorSpace, cycleColorSpace };
};
var id = (value) => value.replace(/\s*/, "").toLowerCase();
var usePresets = (presetColors, currentColor, colorSpace) => {
  const [selectedColors, setSelectedColors] = useState(currentColor?.valid ? [currentColor] : []);
  useEffect(() => {
    if (currentColor !== void 0)
      return;
    setSelectedColors([]);
  }, [currentColor]);
  const presets = useMemo(() => {
    const initialPresets = (presetColors || []).map((preset) => {
      if (typeof preset === "string")
        return parseValue(preset);
      if (preset.title)
        return { ...parseValue(preset.color), keyword: preset.title };
      return parseValue(preset.color);
    });
    return initialPresets.concat(selectedColors).filter(Boolean).slice(-27);
  }, [presetColors, selectedColors]);
  const addPreset = useCallback(
    (color) => {
      if (!color?.valid)
        return;
      if (presets.some((preset) => id(preset[colorSpace]) === id(color[colorSpace])))
        return;
      setSelectedColors((arr) => arr.concat(color));
    },
    [colorSpace, presets]
  );
  return { presets, addPreset };
};
var ColorControl = ({
  name,
  value: initialValue,
  onChange,
  onFocus,
  onBlur,
  presetColors,
  startOpen
}) => {
  const throttledOnChange = useCallback(throttle(onChange, 200), [onChange]);
  const { value, realValue, updateValue, color, colorSpace, cycleColorSpace } = useColorInput(
    initialValue,
    throttledOnChange
  );
  const { presets, addPreset } = usePresets(presetColors, color, colorSpace);
  const Picker = ColorPicker[colorSpace];
  return /* @__PURE__ */ React.createElement(Wrapper, null, /* @__PURE__ */ React.createElement(PickerTooltip, {
    trigger: "click",
    startOpen,
    closeOnClick: true,
    onVisibilityChange: () => addPreset(color),
    tooltip: /* @__PURE__ */ React.createElement(TooltipContent, null, /* @__PURE__ */ React.createElement(Picker, {
      color: realValue === "transparent" ? "#000000" : realValue,
      ...{ onChange: updateValue, onFocus, onBlur }
    }), presets.length > 0 && /* @__PURE__ */ React.createElement(Swatches, null, presets.map((preset, index) => /* @__PURE__ */ React.createElement(WithTooltip, {
      key: `${preset.value}-${index}`,
      hasChrome: false,
      tooltip: /* @__PURE__ */ React.createElement(Note, {
        note: preset.keyword || preset.value
      })
    }, /* @__PURE__ */ React.createElement(Swatch, {
      value: preset[colorSpace],
      active: color && id(preset[colorSpace]) === id(color[colorSpace]),
      onClick: () => updateValue(preset.value)
    })))))
  }, /* @__PURE__ */ React.createElement(Swatch, {
    value: realValue,
    style: { margin: 4 }
  })), /* @__PURE__ */ React.createElement(Input, {
    id: getControlId(name),
    value,
    onChange: (e) => updateValue(e.target.value),
    onFocus: (e) => e.target.select(),
    placeholder: "Choose color..."
  }), value ? /* @__PURE__ */ React.createElement(ToggleIcon, {
    icon: "markup",
    onClick: cycleColorSpace
  }) : null);
};
var Color_default = ColorControl;
export {
  ColorControl,
  Color_default as default
};
