var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/preset/preview.ts
var preview_exports = {};
__export(preview_exports, {
  argsEnhancers: () => argsEnhancers,
  parameters: () => parameters,
  runStep: () => runStep
});
module.exports = __toCommonJS(preview_exports);
var import_addons = require("@storybook/addons");
var import_core_events = require("@storybook/core-events");
var import_instrumenter = require("@storybook/instrumenter");
var import_jest_mock = require("jest-mock");
var JestMock = new import_jest_mock.ModuleMocker(global);
var fn = JestMock.fn.bind(JestMock);
var { action } = (0, import_instrumenter.instrument)({ action: fn }, { retain: true });
var channel = import_addons.addons.getChannel();
var seen = /* @__PURE__ */ new Set();
var spies = [];
channel.on(import_core_events.FORCE_REMOUNT, () => spies.forEach((mock) => {
  var _a;
  return (_a = mock == null ? void 0 : mock.mockClear) == null ? void 0 : _a.call(mock);
}));
channel.on(import_core_events.STORY_RENDER_PHASE_CHANGED, ({ newPhase }) => {
  if (newPhase === "loading")
    spies.forEach((mock) => {
      var _a;
      return (_a = mock == null ? void 0 : mock.mockClear) == null ? void 0 : _a.call(mock);
    });
});
var addSpies = (id, val, key) => {
  if (seen.has(val))
    return val;
  seen.add(val);
  try {
    if (Object.prototype.toString.call(val) === "[object Object]") {
      for (const [k, v] of Object.entries(val))
        val[k] = addSpies(id, v, k);
      return val;
    }
    if (Array.isArray(val)) {
      return val.map((item, index) => addSpies(id, item, `${key}[${index}]`));
    }
    if (typeof val === "function" && val.isAction) {
      Object.defineProperty(val, "name", { value: key, writable: false });
      Object.defineProperty(val, "__storyId__", { value: id, writable: false });
      const spy = action(val);
      spies.push(spy);
      return spy;
    }
  } catch (e) {
  }
  return val;
};
var addActionsFromArgTypes = ({ id, initialArgs }) => addSpies(id, initialArgs);
var argsEnhancers = [addActionsFromArgTypes];
var { step: runStep } = (0, import_instrumenter.instrument)(
  { step: (label, play, context) => play(context) },
  { intercept: true }
);
var parameters = {
  throwPlayFunctionExceptions: false
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  argsEnhancers,
  parameters,
  runStep
});
