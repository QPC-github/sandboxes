// src/main.ts
import global from "global";
import { Channel as Channel2 } from "@storybook/channels";
import { SET_CONFIG } from "@storybook/core-events";
import { logger } from "@storybook/client-logger";

// src/storybook-channel-mock.ts
import { Channel } from "@storybook/channels";
function mockChannel() {
  const transport = {
    setHandler: () => {
    },
    send: () => {
    }
  };
  return new Channel({ transport });
}

// src/types.ts
var types = /* @__PURE__ */ ((types2) => {
  types2["TAB"] = "tab";
  types2["PANEL"] = "panel";
  types2["TOOL"] = "tool";
  types2["TOOLEXTRA"] = "toolextra";
  types2["PREVIEW"] = "preview";
  types2["NOTES_ELEMENT"] = "notes-element";
  return types2;
})(types || {});
function isSupportedType(type) {
  return !!Object.values(types).find((typeVal) => typeVal === type);
}

// src/main.ts
var AddonStore = class {
  constructor() {
    this.loaders = {};
    this.elements = {};
    this.config = {};
    this.getChannel = () => {
      if (!this.channel) {
        this.setChannel(mockChannel());
      }
      return this.channel;
    };
    this.getServerChannel = () => {
      if (!this.serverChannel) {
        throw new Error("Accessing non-existent serverChannel");
      }
      return this.serverChannel;
    };
    this.ready = () => this.promise;
    this.hasChannel = () => !!this.channel;
    this.hasServerChannel = () => !!this.serverChannel;
    this.setChannel = (channel) => {
      this.channel = channel;
      this.resolve();
    };
    this.setServerChannel = (channel) => {
      this.serverChannel = channel;
    };
    this.getElements = (type) => {
      if (!this.elements[type]) {
        this.elements[type] = {};
      }
      return this.elements[type];
    };
    this.addPanel = (name, options) => {
      this.add(name, {
        type: "panel" /* PANEL */,
        ...options
      });
    };
    this.add = (name, addon) => {
      const { type } = addon;
      const collection = this.getElements(type);
      collection[name] = { id: name, ...addon };
    };
    this.setConfig = (value) => {
      Object.assign(this.config, value);
      if (this.hasChannel()) {
        this.getChannel().emit(SET_CONFIG, value);
      }
    };
    this.getConfig = () => this.config;
    this.register = (name, registerCallback) => {
      if (this.loaders[name]) {
        logger.warn(`${name} was loaded twice, this could have bad side-effects`);
      }
      this.loaders[name] = registerCallback;
    };
    this.loadAddons = (api) => {
      Object.values(this.loaders).forEach((value) => value(api));
    };
    this.promise = new Promise((res) => {
      this.resolve = () => res(this.getChannel());
    });
  }
};
var KEY = "__STORYBOOK_ADDONS";
function getAddonsStore() {
  if (!global[KEY]) {
    global[KEY] = new AddonStore();
  }
  return global[KEY];
}
var addons = getAddonsStore();

// src/make-decorator.ts
var makeDecorator = ({
  name,
  parameterName,
  wrapper,
  skipIfNoParametersOrOptions = false
}) => {
  const decorator = (options) => (storyFn, context) => {
    const parameters = context.parameters && context.parameters[parameterName];
    if (parameters && parameters.disable) {
      return storyFn(context);
    }
    if (skipIfNoParametersOrOptions && !options && !parameters) {
      return storyFn(context);
    }
    return wrapper(storyFn, context, {
      options,
      parameters
    });
  };
  return (...args) => {
    if (typeof args[0] === "function") {
      return decorator()(...args);
    }
    return (...innerArgs) => {
      if (innerArgs.length > 1) {
        if (args.length > 1) {
          return decorator(args)(...innerArgs);
        }
        return decorator(...args)(...innerArgs);
      }
      throw new Error(
        `Passing stories directly into ${name}() is not allowed,
        instead use addDecorator(${name}) and pass options with the '${parameterName}' parameter`
      );
    };
  };
};

// src/hooks.ts
import global2 from "global";
import { logger as logger2 } from "@storybook/client-logger";
import {
  FORCE_RE_RENDER,
  STORY_RENDERED,
  UPDATE_STORY_ARGS,
  RESET_STORY_ARGS,
  UPDATE_GLOBALS
} from "@storybook/core-events";
var { window: globalWindow } = global2;
var HooksContext = class {
  constructor() {
    this.renderListener = (storyId) => {
      if (storyId !== this.currentContext.id)
        return;
      this.triggerEffects();
      this.currentContext = null;
      this.removeRenderListeners();
    };
    this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap();
    this.mountedDecorators = /* @__PURE__ */ new Set();
    this.prevMountedDecorators = this.mountedDecorators;
    this.currentHooks = [];
    this.nextHookIndex = 0;
    this.currentPhase = "NONE";
    this.currentEffects = [];
    this.prevEffects = [];
    this.currentDecoratorName = null;
    this.hasUpdates = false;
    this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((effect) => {
      if (effect.destroy) {
        effect.destroy();
      }
    });
    this.init();
    this.removeRenderListeners();
  }
  getNextHook() {
    const hook = this.currentHooks[this.nextHookIndex];
    this.nextHookIndex += 1;
    return hook;
  }
  triggerEffects() {
    this.prevEffects.forEach((effect) => {
      if (!this.currentEffects.includes(effect) && effect.destroy) {
        effect.destroy();
      }
    });
    this.currentEffects.forEach((effect) => {
      if (!this.prevEffects.includes(effect)) {
        effect.destroy = effect.create();
      }
    });
    this.prevEffects = this.currentEffects;
    this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners();
    const channel = addons.getChannel();
    channel.on(STORY_RENDERED, this.renderListener);
  }
  removeRenderListeners() {
    const channel = addons.getChannel();
    channel.removeListener(STORY_RENDERED, this.renderListener);
  }
};
function hookify(fn) {
  return (...args) => {
    const { hooks } = typeof args[0] === "function" ? args[1] : args[0];
    const prevPhase = hooks.currentPhase;
    const prevHooks = hooks.currentHooks;
    const prevNextHookIndex = hooks.nextHookIndex;
    const prevDecoratorName = hooks.currentDecoratorName;
    hooks.currentDecoratorName = fn.name;
    if (hooks.prevMountedDecorators.has(fn)) {
      hooks.currentPhase = "UPDATE";
      hooks.currentHooks = hooks.hookListsMap.get(fn) || [];
    } else {
      hooks.currentPhase = "MOUNT";
      hooks.currentHooks = [];
      hooks.hookListsMap.set(fn, hooks.currentHooks);
      hooks.prevMountedDecorators.add(fn);
    }
    hooks.nextHookIndex = 0;
    const prevContext = globalWindow.STORYBOOK_HOOKS_CONTEXT;
    globalWindow.STORYBOOK_HOOKS_CONTEXT = hooks;
    const result = fn(...args);
    globalWindow.STORYBOOK_HOOKS_CONTEXT = prevContext;
    if (hooks.currentPhase === "UPDATE" && hooks.getNextHook() != null) {
      throw new Error(
        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      );
    }
    hooks.currentPhase = prevPhase;
    hooks.currentHooks = prevHooks;
    hooks.nextHookIndex = prevNextHookIndex;
    hooks.currentDecoratorName = prevDecoratorName;
    return result;
  };
}
var numberOfRenders = 0;
var RENDER_LIMIT = 25;
var applyHooks = (applyDecorators) => (storyFn, decorators) => {
  const decorated = applyDecorators(
    hookify(storyFn),
    decorators.map((decorator) => hookify(decorator))
  );
  return (context) => {
    const { hooks } = context;
    hooks.prevMountedDecorators = hooks.mountedDecorators;
    hooks.mountedDecorators = /* @__PURE__ */ new Set([storyFn, ...decorators]);
    hooks.currentContext = context;
    hooks.hasUpdates = false;
    let result = decorated(context);
    numberOfRenders = 1;
    while (hooks.hasUpdates) {
      hooks.hasUpdates = false;
      hooks.currentEffects = [];
      result = decorated(context);
      numberOfRenders += 1;
      if (numberOfRenders > RENDER_LIMIT) {
        throw new Error(
          "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
        );
      }
    }
    hooks.addRenderListeners();
    return result;
  };
};
var areDepsEqual = (deps, nextDeps) => deps.length === nextDeps.length && deps.every((dep, i) => dep === nextDeps[i]);
var invalidHooksError = () => new Error("Storybook preview hooks can only be called inside decorators and story functions.");
function getHooksContextOrNull() {
  return globalWindow.STORYBOOK_HOOKS_CONTEXT || null;
}
function getHooksContextOrThrow() {
  const hooks = getHooksContextOrNull();
  if (hooks == null) {
    throw invalidHooksError();
  }
  return hooks;
}
function useHook(name, callback, deps) {
  const hooks = getHooksContextOrThrow();
  if (hooks.currentPhase === "MOUNT") {
    if (deps != null && !Array.isArray(deps)) {
      logger2.warn(
        `${name} received a final argument that is not an array (instead, received ${deps}). When specified, the final argument must be an array.`
      );
    }
    const hook = { name, deps };
    hooks.currentHooks.push(hook);
    callback(hook);
    return hook;
  }
  if (hooks.currentPhase === "UPDATE") {
    const hook = hooks.getNextHook();
    if (hook == null) {
      throw new Error("Rendered more hooks than during the previous render.");
    }
    if (hook.name !== name) {
      logger2.warn(
        `Storybook has detected a change in the order of Hooks${hooks.currentDecoratorName ? ` called by ${hooks.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
      );
    }
    if (deps != null && hook.deps == null) {
      logger2.warn(
        `${name} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
      );
    }
    if (deps != null && hook.deps != null && deps.length !== hook.deps.length) {
      logger2.warn(`The final argument passed to ${name} changed size between renders. The order and size of this array must remain constant.
Previous: ${hook.deps}
Incoming: ${deps}`);
    }
    if (deps == null || hook.deps == null || !areDepsEqual(deps, hook.deps)) {
      callback(hook);
      hook.deps = deps;
    }
    return hook;
  }
  throw invalidHooksError();
}
function useMemoLike(name, nextCreate, deps) {
  const { memoizedState } = useHook(
    name,
    (hook) => {
      hook.memoizedState = nextCreate();
    },
    deps
  );
  return memoizedState;
}
function useMemo(nextCreate, deps) {
  return useMemoLike("useMemo", nextCreate, deps);
}
function useCallback(callback, deps) {
  return useMemoLike("useCallback", () => callback, deps);
}
function useRefLike(name, initialValue) {
  return useMemoLike(name, () => ({ current: initialValue }), []);
}
function useRef(initialValue) {
  return useRefLike("useRef", initialValue);
}
function triggerUpdate() {
  const hooks = getHooksContextOrNull();
  if (hooks != null && hooks.currentPhase !== "NONE") {
    hooks.hasUpdates = true;
  } else {
    try {
      addons.getChannel().emit(FORCE_RE_RENDER);
    } catch (e) {
      logger2.warn("State updates of Storybook preview hooks work only in browser");
    }
  }
}
function useStateLike(name, initialState) {
  const stateRef = useRefLike(
    name,
    typeof initialState === "function" ? initialState() : initialState
  );
  const setState = (update) => {
    stateRef.current = typeof update === "function" ? update(stateRef.current) : update;
    triggerUpdate();
  };
  return [stateRef.current, setState];
}
function useState(initialState) {
  return useStateLike("useState", initialState);
}
function useReducer(reducer, initialArg, init) {
  const initialState = init != null ? () => init(initialArg) : initialArg;
  const [state, setState] = useStateLike("useReducer", initialState);
  const dispatch = (action) => setState((prevState) => reducer(prevState, action));
  return [state, dispatch];
}
function useEffect(create, deps) {
  const hooks = getHooksContextOrThrow();
  const effect = useMemoLike("useEffect", () => ({ create }), deps);
  if (!hooks.currentEffects.includes(effect)) {
    hooks.currentEffects.push(effect);
  }
}
function useChannel(eventMap, deps = []) {
  const channel = addons.getChannel();
  useEffect(() => {
    Object.entries(eventMap).forEach(([type, listener]) => channel.on(type, listener));
    return () => {
      Object.entries(eventMap).forEach(
        ([type, listener]) => channel.removeListener(type, listener)
      );
    };
  }, [...Object.keys(eventMap), ...deps]);
  return useCallback(channel.emit.bind(channel), [channel]);
}
function useStoryContext() {
  const { currentContext } = getHooksContextOrThrow();
  if (currentContext == null) {
    throw invalidHooksError();
  }
  return currentContext;
}
function useParameter(parameterKey, defaultValue) {
  const { parameters } = useStoryContext();
  if (parameterKey) {
    return parameters[parameterKey] ?? defaultValue;
  }
  return void 0;
}
function useArgs() {
  const channel = addons.getChannel();
  const { id: storyId, args } = useStoryContext();
  const updateArgs = useCallback(
    (updatedArgs) => channel.emit(UPDATE_STORY_ARGS, { storyId, updatedArgs }),
    [channel, storyId]
  );
  const resetArgs = useCallback(
    (argNames) => channel.emit(RESET_STORY_ARGS, { storyId, argNames }),
    [channel, storyId]
  );
  return [args, updateArgs, resetArgs];
}
function useGlobals() {
  const channel = addons.getChannel();
  const { globals } = useStoryContext();
  const updateGlobals = useCallback(
    (newGlobals) => channel.emit(UPDATE_GLOBALS, { globals: newGlobals }),
    [channel]
  );
  return [globals, updateGlobals];
}

// src/index.ts
var src_default = addons;
export {
  AddonStore,
  Channel2 as Channel,
  HooksContext,
  addons,
  applyHooks,
  src_default as default,
  isSupportedType,
  makeDecorator,
  mockChannel,
  types,
  useArgs,
  useCallback,
  useChannel,
  useEffect,
  useGlobals,
  useMemo,
  useParameter,
  useReducer,
  useRef,
  useState,
  useStoryContext
};
