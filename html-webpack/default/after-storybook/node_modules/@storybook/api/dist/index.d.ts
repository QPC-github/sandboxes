import React, { ReactNode, ReactElement, Component, FC } from 'react';
import { StoryId as StoryId$1, ComponentTitle, Args as Args$1, ArgTypes as ArgTypes$1, ComponentId, StoryKind as StoryKind$1, StoryName, toId, Globals, GlobalTypes, Conditional } from '@storybook/csf';
import { RenderData, NavigateOptions, RouterData } from '@storybook/router';
import { Channel, Listener } from '@storybook/channels';
export { Listener as ChannelListener } from '@storybook/channels';
import { S as SubState$9, a as SubAPI$c, D as DocsOptions } from './shortcuts-574b19a2.js';
import { ThemeVars } from '@storybook/theming';

declare type GetState = () => State;
declare type SetState = (a: any, b: any) => any;
interface Upstream {
    getState: GetState;
    setState: SetState;
}
declare type Patch = Partial<State>;
declare type InputFnPatch = (s: State) => Patch;
declare type InputPatch = Patch | InputFnPatch;
interface Options {
    persistence: 'none' | 'session' | string;
}
declare type CallBack = (s: State) => void;
declare class Store {
    upstreamGetState: GetState;
    upstreamSetState: SetState;
    constructor({ setState, getState }: Upstream);
    getInitialState(base: State): any;
    getState(): State;
    setState(inputPatch: InputPatch, options?: Options): Promise<State>;
    setState(inputPatch: InputPatch, callback?: CallBack, options?: Options): Promise<State>;
}

interface SubState$8 {
    refs: Refs;
}
declare type Versions$1 = Record<string, string>;
declare type SetRefData = Partial<ComposedRef & {
    setStoriesData: SetStoriesStoryData;
    storyIndex: StoryIndex;
}>;
interface SubAPI$b {
    findRef: (source: string) => ComposedRef;
    setRef: (id: string, data: SetRefData, ready?: boolean) => void;
    updateRef: (id: string, ref: ComposedRefUpdate) => void;
    getRefs: () => Refs;
    checkRef: (ref: SetRefData) => Promise<void>;
    changeRefVersion: (id: string, url: string) => void;
    changeRefState: (id: string, ready: boolean) => void;
}
declare type StoryMapper = (ref: ComposedRef, story: SetStoriesStory) => SetStoriesStory;
interface ComposedRef {
    id: string;
    title?: string;
    url: string;
    type?: 'auto-inject' | 'unknown' | 'lazy' | 'server-checked';
    expanded?: boolean;
    stories: StoriesHash;
    versions?: Versions$1;
    loginUrl?: string;
    version?: string;
    ready?: boolean;
    error?: any;
}
declare type ComposedRefUpdate = Partial<Pick<ComposedRef, 'title' | 'type' | 'expanded' | 'stories' | 'versions' | 'loginUrl' | 'version' | 'ready' | 'error'>>;
declare type Refs = Record<string, ComposedRef>;

declare type PanelPositions = 'bottom' | 'right';
declare type ActiveTabsType = 'sidebar' | 'canvas' | 'addons';
interface Layout {
    initialActive: ActiveTabsType;
    isFullscreen: boolean;
    showPanel: boolean;
    panelPosition: PanelPositions;
    showNav: boolean;
    showTabs: boolean;
    showToolbar: boolean;
    /**
     * @deprecated
     */
    isToolshown?: boolean;
}
interface UI {
    name?: string;
    url?: string;
    enableShortcuts: boolean;
}
interface SubState$7 {
    layout: Layout;
    ui: UI;
    selectedPanel: string | undefined;
    theme: ThemeVars;
}
interface SubAPI$a {
    toggleFullscreen: (toggled?: boolean) => void;
    togglePanel: (toggled?: boolean) => void;
    togglePanelPosition: (position?: PanelPositions) => void;
    toggleNav: (toggled?: boolean) => void;
    toggleToolbar: (toggled?: boolean) => void;
    setOptions: (options: any) => void;
}
interface UIOptions {
    name?: string;
    url?: string;
    goFullScreen: boolean;
    showStoriesPanel: boolean;
    showAddonPanel: boolean;
    addonPanelInRight: boolean;
    theme?: ThemeVars;
    selectedPanel?: string;
}

interface SidebarOptions {
    showRoots?: boolean;
    collapsedRoots?: string[];
    renderLabel?: (item: HashEntry) => ReactNode;
}
declare type IframeRenderer = (storyId: string, viewMode: State['viewMode'], id: string, baseUrl: string, scale: number, queryParams: Record<string, any>) => ReactNode;
interface Provider {
    channel?: Channel;
    serverChannel?: Channel;
    renderPreview?: IframeRenderer;
    handleAPI(api: API): void;
    getConfig(): {
        sidebar?: SidebarOptions;
        theme?: ThemeVars;
        StoryMapper?: StoryMapper;
        [k: string]: any;
    } & Partial<UIOptions>;
    [key: string]: any;
}
interface SubAPI$9 {
    renderPreview?: Provider['renderPreview'];
}

declare type ViewMode$1 = 'story' | 'info' | 'settings' | 'page' | undefined | string;
declare enum types {
    TAB = "tab",
    PANEL = "panel",
    TOOL = "tool",
    PREVIEW = "preview",
    NOTES_ELEMENT = "notes-element"
}
declare type Types = types | string;
interface RenderOptions {
    active: boolean;
    key: string;
}
interface RouteOptions {
    storyId: string;
    viewMode: ViewMode$1;
    location: RenderData['location'];
    path: string;
}
interface MatchOptions {
    storyId: string;
    viewMode: ViewMode$1;
    location: RenderData['location'];
    path: string;
}
interface Addon {
    title: string;
    type?: Types;
    id?: string;
    route?: (routeOptions: RouteOptions) => string;
    match?: (matchOptions: MatchOptions) => boolean;
    render: (renderOptions: RenderOptions) => ReactElement<any>;
    paramKey?: string;
    disabled?: boolean;
    hidden?: boolean;
}
interface Collection<T = Addon> {
    [key: string]: T;
}
declare type Panels = Collection<Addon>;
declare type StateMerger$1<S> = (input: S) => S;
interface SubAPI$8 {
    getElements: <T>(type: Types) => Collection<T>;
    getPanels: () => Panels;
    getStoryPanels: () => Panels;
    getSelectedPanel: () => string;
    setSelectedPanel: (panelName: string) => void;
    setAddonState<S>(addonId: string, newStateOrMerger: S | StateMerger$1<S>, options?: Options): Promise<S>;
    getAddonState<S>(addonId: string): S;
}

interface BaseEntry {
    id: StoryId$1;
    depth: number;
    name: string;
    refId?: string;
    renderLabel?: (item: BaseEntry) => React.ReactNode;
    /** @deprecated */
    isRoot: boolean;
    /** @deprecated */
    isComponent: boolean;
    /** @deprecated */
    isLeaf: boolean;
}
interface RootEntry extends BaseEntry {
    type: 'root';
    startCollapsed?: boolean;
    children: StoryId$1[];
    /** @deprecated */
    isRoot: true;
    /** @deprecated */
    isComponent: false;
    /** @deprecated */
    isLeaf: false;
}
interface GroupEntry extends BaseEntry {
    type: 'group';
    parent?: StoryId$1;
    children: StoryId$1[];
    /** @deprecated */
    isRoot: false;
    /** @deprecated */
    isComponent: false;
    /** @deprecated */
    isLeaf: false;
}
interface ComponentEntry extends BaseEntry {
    type: 'component';
    parent?: StoryId$1;
    children: StoryId$1[];
    /** @deprecated */
    isRoot: false;
    /** @deprecated */
    isComponent: true;
    /** @deprecated */
    isLeaf: false;
}
interface DocsEntry extends BaseEntry {
    type: 'docs';
    parent: StoryId$1;
    title: ComponentTitle;
    /** @deprecated */
    kind: ComponentTitle;
    importPath: Path;
    /** @deprecated */
    isRoot: false;
    /** @deprecated */
    isComponent: false;
    /** @deprecated */
    isLeaf: true;
}
interface StoryEntry extends BaseEntry {
    type: 'story';
    parent: StoryId$1;
    title: ComponentTitle;
    /** @deprecated */
    kind: ComponentTitle;
    importPath: Path;
    prepared: boolean;
    parameters?: {
        [parameterName: string]: any;
    };
    args?: Args$1;
    argTypes?: ArgTypes$1;
    initialArgs?: Args$1;
    /** @deprecated */
    isRoot: false;
    /** @deprecated */
    isComponent: false;
    /** @deprecated */
    isLeaf: true;
}
declare type LeafEntry = DocsEntry | StoryEntry;
declare type HashEntry = RootEntry | GroupEntry | ComponentEntry | DocsEntry | StoryEntry;
/**
 * The `StoriesHash` is our manager-side representation of the `StoryIndex`.
 * We create entries in the hash not only for each story or docs entry, but
 * also for each "group" of the component (split on '/'), as that's how things
 * are manipulated in the manager (i.e. in the sidebar)
 */
interface StoriesHash {
    [id: string]: HashEntry;
}
interface SetStoriesStory {
    id: StoryId$1;
    name: string;
    refId?: string;
    componentId?: ComponentId;
    kind: StoryKind$1;
    parameters: {
        fileName: string;
        options: {
            [optionName: string]: any;
        };
        docsOnly?: boolean;
        viewMode?: ViewMode$1;
        [parameterName: string]: any;
    };
    argTypes?: ArgTypes$1;
    args?: Args$1;
    initialArgs?: Args$1;
}
interface SetStoriesStoryData {
    [id: string]: SetStoriesStory;
}
declare type Path = string;
interface BaseIndexEntry {
    id: StoryId$1;
    name: StoryName;
    title: ComponentTitle;
    importPath: Path;
}
declare type StoryIndexEntry = BaseIndexEntry & {
    type?: 'story';
};
declare type DocsIndexEntry = BaseIndexEntry & {
    storiesImports: Path[];
    type: 'docs';
};
declare type IndexEntry = StoryIndexEntry | DocsIndexEntry;
interface StoryIndex {
    v: number;
    entries: Record<StoryId$1, IndexEntry>;
}

interface SubAPI$7 {
    getChannel: () => Channel;
    on: (type: string, cb: Listener) => () => void;
    off: (type: string, cb: Listener) => void;
    emit: (type: string, ...args: any[]) => void;
    once: (type: string, cb: Listener) => void;
    collapseAll: () => void;
    expandAll: () => void;
}

interface Notification {
    id: string;
    link: string;
    content: {
        headline: string;
        subHeadline?: string | ReactNode;
    };
    icon?: {
        name: string;
        color?: string;
    };
    onClear?: () => void;
}
interface SubState$6 {
    notifications: Notification[];
}
interface SubAPI$6 {
    addNotification: (notification: Notification) => void;
    clearNotification: (id: string) => void;
}

interface SubAPI$5 {
    changeSettingsTab: (tab: string) => void;
    closeSettings: () => void;
    isSettingsScreenActive: () => boolean;
    navigateToSettingsPage: (path: string) => Promise<void>;
}
interface Settings {
    lastTrackedStoryId: string;
}
interface SubState$5 {
    settings: Settings;
}

interface SubAPI$4 {
    releaseNotesVersion: () => string;
    setDidViewReleaseNotes: () => void;
    showReleaseNotesOnLaunch: () => boolean;
}
interface SubState$4 {
    releaseNotesViewed: string[];
}

declare type Direction = -1 | 1;
declare type ParameterName = string;
declare type ViewMode = 'story' | 'info' | 'settings' | string | undefined;
declare type StoryUpdate = Pick<StoryEntry, 'parameters' | 'initialArgs' | 'argTypes' | 'args'>;
interface SubState$3 {
    storiesHash: StoriesHash;
    storyId: StoryId$1;
    viewMode: ViewMode;
    storiesConfigured: boolean;
    storiesFailed?: Error;
}
interface SubAPI$3 {
    storyId: typeof toId;
    resolveStory: (storyId: StoryId$1, refsId?: string) => HashEntry;
    selectFirstStory: () => void;
    selectStory: (kindOrId?: string, story?: string, obj?: {
        ref?: string;
        viewMode?: ViewMode;
    }) => void;
    getCurrentStoryData: () => LeafEntry;
    setStories: (stories: SetStoriesStoryData, failed?: Error) => Promise<void>;
    jumpToComponent: (direction: Direction) => void;
    jumpToStory: (direction: Direction) => void;
    getData: (storyId: StoryId$1, refId?: string) => LeafEntry;
    isPrepared: (storyId: StoryId$1, refId?: string) => boolean;
    getParameters: (storyId: StoryId$1 | {
        storyId: StoryId$1;
        refId: string;
    }, parameterName?: ParameterName) => StoryEntry['parameters'] | any;
    getCurrentParameter<S>(parameterName?: ParameterName): S;
    updateStoryArgs(story: StoryEntry, newArgs: Args): void;
    resetStoryArgs: (story: StoryEntry, argNames?: string[]) => void;
    findLeafEntry(StoriesHash: StoriesHash, storyId: StoryId$1): LeafEntry;
    findLeafStoryId(StoriesHash: StoriesHash, storyId: StoryId$1): StoryId$1;
    findSiblingStoryId(storyId: StoryId$1, hash: StoriesHash, direction: Direction, toSiblingGroup: boolean): StoryId$1;
    fetchStoryList: () => Promise<void>;
    setStoryList: (storyList: StoryIndex) => Promise<void>;
    updateStory: (storyId: StoryId$1, update: StoryUpdate, ref?: ComposedRef) => Promise<void>;
}

interface SubState$2 {
    customQueryParams: QueryParams;
}
interface QueryParams {
    [key: string]: string | null;
}
interface SubAPI$2 {
    navigateUrl: (url: string, options: NavigateOptions) => void;
    getQueryParam: (key: string) => string | undefined;
    getUrlState: () => {
        queryParams: QueryParams;
        path: string;
        viewMode?: string;
        storyId?: string;
        url: string;
    };
    setQueryParams: (input: QueryParams) => void;
}

interface Version {
    version: string;
    info?: {
        plain: string;
    };
    [key: string]: any;
}
interface UnknownEntries {
    [key: string]: {
        [key: string]: any;
    };
}
interface Versions {
    latest?: Version;
    next?: Version;
    current?: Version;
}
interface SubState$1 {
    versions: Versions & UnknownEntries;
    lastVersionCheck: number;
    dismissedVersionNotification: undefined | string;
}
interface SubAPI$1 {
    getCurrentVersion: () => Version;
    getLatestVersion: () => Version;
    versionUpdateAvailable: () => boolean;
}

interface SubState {
    globals?: Globals;
    globalTypes?: GlobalTypes;
}
interface SubAPI {
    getGlobals: () => Globals;
    getGlobalTypes: () => GlobalTypes;
    updateGlobals: (newGlobals: Globals) => void;
}

declare const _default: <TObj = any>(a: TObj, b: Partial<TObj>) => TObj & Partial<TObj>;

declare const ActiveTabs: {
    SIDEBAR: "sidebar";
    CANVAS: "canvas";
    ADDONS: "addons";
};

declare const ManagerContext: React.Context<{
    api: API;
    state: State;
}>;
declare type ModuleArgs = RouterData & ProviderData & {
    mode?: 'production' | 'development';
    state: State;
    fullAPI: API;
    store: Store;
};
declare type OptionsData = {
    docsOptions: DocsOptions;
};
declare type State = SubState$7 & SubState$3 & SubState$8 & SubState$6 & SubState$1 & SubState$2 & SubState$9 & SubState$4 & SubState$5 & SubState & RouterData & OptionsData & Other;
declare type API = SubAPI$8 & SubAPI$7 & SubAPI$9 & SubAPI$3 & SubAPI$b & SubAPI & SubAPI$a & SubAPI$6 & SubAPI$c & SubAPI$4 & SubAPI$5 & SubAPI$1 & SubAPI$2 & Other;
interface Other {
    [key: string]: any;
}
interface Combo {
    api: API;
    state: State;
}
interface ProviderData {
    provider: Provider;
    docsOptions: DocsOptions;
}
declare type ManagerProviderProps = RouterData & ProviderData & {
    children: ReactNode | ((props: Combo) => ReactNode);
};
declare type StoryId = string;
declare type StoryKind = string;
interface Args {
    [key: string]: any;
}
interface ArgType {
    name?: string;
    description?: string;
    defaultValue?: any;
    if?: Conditional;
    [key: string]: any;
}
interface ArgTypes {
    [key: string]: ArgType;
}
interface Parameters {
    [key: string]: any;
}
declare const combineParameters: (...parameterSets: Parameters[]) => any;
interface ModuleWithInit<APIType = unknown, StateType = unknown> {
    init: () => void | Promise<void>;
    api: APIType;
    state: StateType;
}
declare type ModuleWithoutInit<APIType = unknown, StateType = unknown> = Omit<ModuleWithInit<APIType, StateType>, 'init'>;
declare type ModuleFn<APIType = unknown, StateType = unknown, HasInit = false> = (m: ModuleArgs) => HasInit extends true ? ModuleWithInit<APIType, StateType> : ModuleWithoutInit<APIType, StateType>;
declare class ManagerProvider extends Component<ManagerProviderProps, State> {
    api: API;
    modules: (ModuleWithInit | ModuleWithoutInit)[];
    static displayName: string;
    constructor(props: ManagerProviderProps);
    static getDerivedStateFromProps(props: ManagerProviderProps, state: State): State;
    shouldComponentUpdate(nextProps: ManagerProviderProps, nextState: State): boolean;
    initModules: () => void;
    render(): JSX.Element;
}
interface ManagerConsumerProps<P = unknown> {
    filter?: (combo: Combo) => P;
    children: FC<P> | ReactNode;
}
declare function ManagerConsumer<P = Combo>({ filter, children, }: ManagerConsumerProps<P>): ReactElement;
declare function useStorybookState(): State;
declare function useStorybookApi(): API;

interface EventMap {
    [eventId: string]: Listener;
}
declare const useChannel: (eventMap: EventMap, deps?: any[]) => (type: string, ...args: any[]) => void;
declare function useStoryPrepared(storyId?: StoryId): boolean;
declare function useParameter<S>(parameterKey: string, defaultValue?: S): S;
declare type StateMerger<S> = (input: S) => S;
declare function useSharedState<S>(stateId: string, defaultState?: S): [S, (newStateOrMerger: S | StateMerger<S>, options?: Options) => void];
declare function useAddonState<S>(addonId: string, defaultState?: S): [S, (newStateOrMerger: S | StateMerger<S>, options?: Options) => void];
declare function useArgs(): [Args, (newArgs: Args) => void, (argNames?: string[]) => void];
declare function useGlobals(): [Args, (newGlobals: Args) => void];
declare function useGlobalTypes(): ArgTypes;
declare function useArgTypes(): ArgTypes;

export { API, ActiveTabs, ArgType, ArgTypes, Args, Combo, ComponentEntry, ComposedRef, ManagerConsumer as Consumer, DocsEntry, EventMap, GroupEntry, HashEntry, LeafEntry, ManagerContext, ManagerProviderProps, ModuleArgs, ModuleFn, Parameters, ManagerProvider as Provider, Refs, RootEntry, State, Options as StoreOptions, StoriesHash, StoryEntry, StoryId, StoryKind, combineParameters, _default as merge, useAddonState, useArgTypes, useArgs, useChannel, useGlobalTypes, useGlobals, useParameter, useSharedState, useStoryPrepared, useStorybookApi, useStorybookState };
