"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  computeStorybookMetadata: () => computeStorybookMetadata,
  getStorybookMetadata: () => getStorybookMetadata,
  metaFrameworks: () => metaFrameworks,
  sanitizeAddonName: () => sanitizeAddonName,
  telemetry: () => telemetry
});
module.exports = __toCommonJS(src_exports);
var import_client_logger = require("@storybook/client-logger");

// src/storybook-metadata.ts
var import_read_pkg_up = __toESM(require("read-pkg-up"));
var import_detect_package_manager = require("detect-package-manager");
var import_core_common2 = require("@storybook/core-common");

// src/package-versions.ts
var import_path = __toESM(require("path"));
var getActualPackageVersions = async (packages) => {
  const packageNames = Object.keys(packages);
  return Promise.all(packageNames.map(getActualPackageVersion));
};
var getActualPackageVersion = async (packageName) => {
  try {
    const packageJson = require(import_path.default.join(packageName, "package.json"));
    return {
      name: packageName,
      version: packageJson.version
    };
  } catch (err) {
    return { name: packageName, version: null };
  }
};

// src/get-monorepo-type.ts
var import_fs_extra = __toESM(require("fs-extra"));
var import_path2 = __toESM(require("path"));
var import_core_common = require("@storybook/core-common");
var monorepoConfigs = {
  Nx: "nx.json",
  Turborepo: "turbo.json",
  Lerna: "lerna.json",
  Rush: "rush.json",
  Lage: "lage.config.json"
};
var getMonorepoType = () => {
  const projectRootPath = (0, import_core_common.getProjectRoot)();
  if (!projectRootPath)
    return void 0;
  const keys = Object.keys(monorepoConfigs);
  const monorepoType = keys.find((monorepo) => {
    const configFile = import_path2.default.join(projectRootPath, monorepoConfigs[monorepo]);
    return import_fs_extra.default.existsSync(configFile);
  });
  if (monorepoType) {
    return monorepoType;
  }
  if (!import_fs_extra.default.existsSync(import_path2.default.join(projectRootPath, "package.json"))) {
    return void 0;
  }
  const packageJson = import_fs_extra.default.readJsonSync(import_path2.default.join(projectRootPath, "package.json"));
  if (packageJson == null ? void 0 : packageJson.workspaces) {
    return "Workspaces";
  }
  return void 0;
};

// src/sanitize.ts
var import_path3 = require("path");
function regexpEscape(str) {
  return str.replace(/[-[/{}()*+?.\\^$|]/g, `\\$&`);
}
function cleanPaths(str, separator = import_path3.sep) {
  if (!str)
    return str;
  const stack = process.cwd().split(separator);
  while (stack.length > 1) {
    const currentPath = stack.join(separator);
    const currentRegex = new RegExp(regexpEscape(currentPath), `g`);
    str = str.replace(currentRegex, `$SNIP`);
    const currentPath2 = stack.join(separator + separator);
    const currentRegex2 = new RegExp(regexpEscape(currentPath2), `g`);
    str = str.replace(currentRegex2, `$SNIP`);
    stack.pop();
  }
  return str;
}
function sanitizeError(error, pathSeparator = import_path3.sep) {
  error = JSON.parse(JSON.stringify(error, Object.getOwnPropertyNames(error)));
  const errorString = cleanPaths(JSON.stringify(error), pathSeparator);
  return JSON.parse(errorString);
}

// src/storybook-metadata.ts
var metaFrameworks = {
  next: "Next",
  "react-scripts": "CRA",
  gatsby: "Gatsby",
  "@nuxtjs/storybook": "nuxt",
  "@nrwl/storybook": "nx",
  "@vue/cli-service": "vue-cli",
  "@sveltejs/kit": "svelte-kit"
};
var getFrameworkOptions = (mainConfig) => {
  const possibleOptions = [
    "angular",
    "ember",
    "html",
    "preact",
    "react",
    "server",
    "svelte",
    "vue",
    "vue3",
    "webComponents"
  ].map((opt) => `${opt}Options`);
  for (const opt of possibleOptions) {
    if (opt in mainConfig) {
      return mainConfig[opt];
    }
  }
  return void 0;
};
var sanitizeAddonName = (name) => {
  return cleanPaths(name).replace(/\/dist\/.*/, "").replace(/\.[mc]?[tj]?s[x]?$/, "").replace(/\/register$/, "").replace(/\/manager$/, "").replace(/\/preset$/, "");
};
var computeStorybookMetadata = async ({
  packageJson,
  mainConfig
}) => {
  var _a, _b;
  const metadata = {
    generatedAt: new Date().getTime(),
    builder: { name: "webpack5" },
    hasCustomBabel: false,
    hasCustomWebpack: false,
    hasStaticDirs: false,
    hasStorybookEslint: false,
    refCount: 0
  };
  const allDependencies = {
    ...packageJson == null ? void 0 : packageJson.dependencies,
    ...packageJson == null ? void 0 : packageJson.devDependencies,
    ...packageJson == null ? void 0 : packageJson.peerDependencies
  };
  const metaFramework = Object.keys(allDependencies).find((dep) => !!metaFrameworks[dep]);
  if (metaFramework) {
    const { version } = await getActualPackageVersion(metaFramework);
    metadata.metaFramework = {
      name: metaFrameworks[metaFramework],
      packageName: metaFramework,
      version
    };
  }
  const monorepoType = getMonorepoType();
  if (monorepoType) {
    metadata.monorepo = monorepoType;
  }
  try {
    const packageManagerType = await (0, import_detect_package_manager.detect)({ cwd: (0, import_core_common2.getProjectRoot)() });
    const packageManagerVerson = await (0, import_detect_package_manager.getNpmVersion)(packageManagerType);
    metadata.packageManager = {
      type: packageManagerType,
      version: packageManagerVerson
    };
  } catch (err) {
  }
  metadata.hasCustomBabel = !!mainConfig.babel;
  metadata.hasCustomWebpack = !!mainConfig.webpackFinal;
  metadata.hasStaticDirs = !!mainConfig.staticDirs;
  if (mainConfig.typescript) {
    metadata.typescriptOptions = mainConfig.typescript;
  }
  if ((_a = mainConfig.core) == null ? void 0 : _a.builder) {
    const { builder } = mainConfig.core;
    metadata.builder = {
      name: typeof builder === "string" ? builder : builder.name,
      options: typeof builder === "string" ? void 0 : (builder == null ? void 0 : builder.options) ?? void 0
    };
  }
  if (mainConfig.refs) {
    metadata.refCount = Object.keys(mainConfig.refs).length;
  }
  if (mainConfig.features) {
    metadata.features = mainConfig.features;
  }
  const addons = {};
  if (mainConfig.addons) {
    mainConfig.addons.forEach((addon) => {
      let addonName;
      let options;
      if (typeof addon === "string") {
        addonName = sanitizeAddonName(addon);
      } else {
        options = addon.options;
        addonName = sanitizeAddonName(addon.name);
      }
      addons[addonName] = {
        options,
        version: void 0
      };
    });
  }
  const addonVersions = await getActualPackageVersions(addons);
  addonVersions.forEach(({ name, version }) => {
    addons[name].version = version;
  });
  const addonNames = Object.keys(addons);
  const storybookPackages = Object.keys(allDependencies).filter((dep) => dep.includes("storybook") && !addonNames.includes(dep)).reduce((acc, dep) => {
    return {
      ...acc,
      [dep]: { version: void 0 }
    };
  }, {});
  const storybookPackageVersions = await getActualPackageVersions(storybookPackages);
  storybookPackageVersions.forEach(({ name, version }) => {
    storybookPackages[name].version = version;
  });
  const language = allDependencies.typescript ? "typescript" : "javascript";
  const hasStorybookEslint = !!allDependencies["eslint-plugin-storybook"];
  const storybookInfo = (0, import_core_common2.getStorybookInfo)(packageJson);
  const storybookVersion = ((_b = storybookPackages[storybookInfo.frameworkPackage]) == null ? void 0 : _b.version) || storybookInfo.version;
  return {
    ...metadata,
    storybookVersion,
    language,
    storybookPackages,
    framework: {
      name: storybookInfo.framework,
      options: getFrameworkOptions(mainConfig)
    },
    addons,
    hasStorybookEslint
  };
};
var cachedMetadata;
var getStorybookMetadata = async (_configDir) => {
  var _a;
  if (cachedMetadata) {
    return cachedMetadata;
  }
  const { packageJson = {} } = import_read_pkg_up.default.sync({ cwd: process.cwd(), normalize: false }) || {};
  const configDir = (_configDir || (0, import_core_common2.getStorybookConfiguration)(
    ((_a = packageJson == null ? void 0 : packageJson.scripts) == null ? void 0 : _a.storybook) || "",
    "-c",
    "--config-dir"
  )) ?? ".storybook";
  const mainConfig = (0, import_core_common2.loadMainConfig)({ configDir });
  cachedMetadata = await computeStorybookMetadata({ mainConfig, packageJson });
  return cachedMetadata;
};

// src/telemetry.ts
var import_isomorphic_unfetch = __toESM(require("isomorphic-unfetch"));
var import_fetch_retry = __toESM(require("fetch-retry"));
var import_nanoid = require("nanoid");

// src/anonymous-id.ts
var import_path4 = __toESM(require("path"));
var import_child_process = require("child_process");
var import_core_common3 = require("@storybook/core-common");

// src/one-way-hash.ts
var import_crypto = require("crypto");
var oneWayHash = (payload) => {
  const hash = (0, import_crypto.createHash)("sha256");
  hash.update("storybook-telemetry-salt");
  hash.update(payload);
  return hash.digest("hex");
};

// src/anonymous-id.ts
var anonymousProjectId;
var getAnonymousProjectId = () => {
  if (anonymousProjectId) {
    return anonymousProjectId;
  }
  let unhashedProjectId;
  try {
    const projectRoot = (0, import_core_common3.getProjectRoot)();
    const projectRootPath = import_path4.default.relative(projectRoot, process.cwd());
    const originBuffer = (0, import_child_process.execSync)(`git config --local --get remote.origin.url`, {
      timeout: 1e3,
      stdio: `pipe`
    });
    unhashedProjectId = `${String(originBuffer).trim()}${projectRootPath}`;
    anonymousProjectId = oneWayHash(unhashedProjectId);
  } catch (_) {
  }
  return anonymousProjectId;
};

// src/telemetry.ts
var URL = "https://storybook.js.org/event-log";
var fetch = (0, import_fetch_retry.default)(import_isomorphic_unfetch.default);
var tasks = [];
var sessionId = (0, import_nanoid.nanoid)();
async function sendTelemetry(data, options = { retryDelay: 1e3, immediate: false }) {
  const { payload, metadata, ...rest } = data;
  const context = {
    anonymousId: getAnonymousProjectId(),
    inCI: process.env.CI === "true"
  };
  const eventId = (0, import_nanoid.nanoid)();
  const body = { ...rest, eventId, sessionId, metadata, payload, context };
  let request;
  try {
    request = fetch(URL, {
      method: "POST",
      body: JSON.stringify(body),
      headers: { "Content-Type": "application/json" },
      retries: 3,
      retryOn: [503, 504],
      retryDelay: (attempt) => 2 ** attempt * (typeof (options == null ? void 0 : options.retryDelay) === "number" && !Number.isNaN(options == null ? void 0 : options.retryDelay) ? options.retryDelay : 1e3)
    });
    tasks.push(request);
    if (options.immediate) {
      await Promise.all(tasks);
    } else {
      await request;
    }
  } catch (err) {
  } finally {
    tasks = tasks.filter((task) => task !== request);
  }
}

// src/notify.ts
var import_chalk = __toESM(require("chalk"));
var import_core_common4 = require("@storybook/core-common");
var TELEMETRY_KEY_NOTIFY_DATE = "telemetry-notification-date";
var logger = console;
var notify = async () => {
  const telemetryNotifyDate = await import_core_common4.cache.get(TELEMETRY_KEY_NOTIFY_DATE, null);
  if (telemetryNotifyDate) {
    return;
  }
  import_core_common4.cache.set(TELEMETRY_KEY_NOTIFY_DATE, Date.now());
  logger.log();
  logger.log(
    `${import_chalk.default.magenta.bold(
      "attention"
    )} => Storybook now collects completely anonymous telemetry regarding usage.`
  );
  logger.log(`This information is used to shape Storybook's roadmap and prioritize features.`);
  logger.log(
    `You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:`
  );
  logger.log(import_chalk.default.cyan("https://storybook.js.org/telemetry"));
  logger.log();
};

// src/index.ts
var telemetry = async (eventType, payload = {}, options = {}) => {
  var _a;
  await notify();
  const telemetryData = {
    eventType,
    payload
  };
  try {
    telemetryData.metadata = await getStorybookMetadata(options == null ? void 0 : options.configDir);
  } catch (error) {
    if (!telemetryData.payload.error)
      telemetryData.payload.error = error;
  } finally {
    const { error } = telemetryData.payload;
    if (error) {
      telemetryData.payload.error = sanitizeError(error);
    }
    if (!telemetryData.payload.error || (options == null ? void 0 : options.enableCrashReports)) {
      if ((_a = process.env) == null ? void 0 : _a.STORYBOOK_DEBUG_TELEMETRY) {
        import_client_logger.logger.info("\n[telemetry]");
        import_client_logger.logger.info(JSON.stringify(telemetryData, null, 2));
      } else {
        await sendTelemetry(telemetryData, options);
      }
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  computeStorybookMetadata,
  getStorybookMetadata,
  metaFrameworks,
  sanitizeAddonName,
  telemetry
});
