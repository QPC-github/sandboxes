// src/load-custom-webpack-config.ts
import path from "path";
import { serverRequire } from "@storybook/core-common";
var webpackConfigs = ["webpack.config", "webpackfile"];
var loadCustomWebpackConfig = (configDir) => serverRequire(webpackConfigs.map((configName) => path.resolve(configDir, configName)));

// src/check-webpack-version.ts
import { logger } from "@storybook/node-logger";
import { dedent } from "ts-dedent";
var checkWebpackVersion = (webpack, specifier, caption) => {
  if (!webpack.version) {
    logger.info("Skipping webpack version check, no version available");
    return;
  }
  if (webpack.version !== specifier) {
    logger.warn(dedent`
      Unexpected webpack version in ${caption}:
      - Received '${webpack.version}'
      - Expected '${specifier}'

      If you're using Webpack 5 in SB6.2 and upgrading, consider: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#webpack-5-manager-build

      For more info about Webpack 5 support: https://gist.github.com/shilman/8856ea1786dcd247139b47b270912324#troubleshooting
    `);
  }
};

// src/merge-webpack-config.ts
function mergePluginsField(defaultPlugins = [], customPlugins = []) {
  return [...defaultPlugins, ...customPlugins];
}
function mergeRulesField(defaultRules = [], customRules = []) {
  return [...defaultRules, ...customRules];
}
function mergeExtensionsField({ extensions: defaultExtensions = [] }, { extensions: customExtensions = [] }) {
  return [...defaultExtensions, ...customExtensions];
}
function mergeAliasField({ alias: defaultAlias = {} }, { alias: customAlias = {} }) {
  return {
    ...defaultAlias,
    ...customAlias
  };
}
function mergeModuleField(a, b) {
  return {
    ...a,
    ...b,
    rules: mergeRulesField(a.rules || [], b.rules || [])
  };
}
function mergeResolveField({ resolve: defaultResolve = {} }, { resolve: customResolve = {} }) {
  return {
    ...defaultResolve,
    ...customResolve,
    alias: mergeAliasField(defaultResolve, customResolve),
    extensions: mergeExtensionsField(defaultResolve, customResolve)
  };
}
function mergeOptimizationField({ optimization: defaultOptimization = {} }, { optimization: customOptimization = {} }) {
  return {
    ...defaultOptimization,
    ...customOptimization
  };
}
function mergeConfigs(config, customConfig) {
  return {
    ...customConfig,
    ...config,
    devtool: customConfig.devtool || config.devtool,
    plugins: mergePluginsField(config.plugins, customConfig.plugins),
    module: mergeModuleField(config.module || {}, customConfig.module || {}),
    resolve: mergeResolveField(config, customConfig),
    optimization: mergeOptimizationField(config, customConfig)
  };
}

// src/to-importFn.ts
import { dedent as dedent2 } from "ts-dedent";
import { globToRegexp } from "@storybook/core-common";

// src/importPipeline.ts
function importPipeline() {
  let importGate = Promise.resolve();
  return async (importFn) => {
    await importGate;
    const moduleExportsPromise = importFn();
    importGate = importGate.then(async () => {
      await moduleExportsPromise;
    });
    return moduleExportsPromise;
  };
}

// src/to-importFn.ts
function webpackIncludeRegexp(specifier) {
  const { directory, files } = specifier;
  const directoryWithoutLeadingDots = directory.replace(/^(\.+\/)+/, "/");
  const webpackIncludeGlob = [".", ".."].includes(directory) ? files : `${directoryWithoutLeadingDots}/${files}`;
  const webpackIncludeRegexpWithCaret = globToRegexp(webpackIncludeGlob);
  return new RegExp(webpackIncludeRegexpWithCaret.source.replace(/^\^/, ""));
}
function toImportFnPart(specifier) {
  const { directory, importPathMatcher } = specifier;
  return dedent2`
      async (path) => {
        if (!${importPathMatcher}.exec(path)) {
          return;
        }

        const pathRemainder = path.substring(${directory.length + 1});
        return import(
          /* webpackChunkName: "[request]" */
          /* webpackInclude: ${webpackIncludeRegexp(specifier)} */
          '${directory}/' + pathRemainder
        );
      }

  `;
}
function toImportFn(stories, { needPipelinedImport } = {}) {
  let pipelinedImport = `const pipeline = (x) => x();`;
  if (needPipelinedImport) {
    pipelinedImport = `
      const importPipeline = ${importPipeline};
      const pipeline = importPipeline();
    `;
  }
  return dedent2`
    ${pipelinedImport}

    const importers = [
      ${stories.map(toImportFnPart).join(",\n")}
    ];

    export async function importFn(path) {
      for (let i = 0; i < importers.length; i++) {
        const moduleExports = await pipeline(() => importers[i](path));
        if (moduleExports) {
          return moduleExports;
        }
      }
    }
  `;
}

// src/to-require-context.ts
import { globToRegexp as globToRegexp2 } from "@storybook/core-common";
var toRequireContext = (specifier) => {
  const { directory, files } = specifier;
  const match = globToRegexp2(`./${files}`);
  return {
    path: directory,
    recursive: files.includes("**") || files.split("/").length > 1,
    match
  };
};
var toRequireContextString = (specifier) => {
  const { path: p, recursive: r, match: m } = toRequireContext(specifier);
  const result = `require.context('${p}', ${r}, ${m})`;
  return result;
};
export {
  checkWebpackVersion,
  loadCustomWebpackConfig,
  mergeConfigs,
  toImportFn,
  toImportFnPart,
  toRequireContext,
  toRequireContextString,
  webpackIncludeRegexp
};
