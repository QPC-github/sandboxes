// src/constants.ts
var PARAM_KEY = "actions";
var ADDON_ID = "storybook/actions";
var PANEL_ID = `${ADDON_ID}/panel`;
var EVENT_ID = `${ADDON_ID}/action-event`;
var CYCLIC_KEY = "$___storybook.isCyclic";

// src/runtime/configureActions.ts
var config = {
  depth: 10,
  clearOnStoryChange: true,
  limit: 50
};
var configureActions = (options = {}) => {
  Object.assign(config, options);
};

// src/runtime/action.ts
import uuidv4 from "uuid-browser/v4";
import { addons } from "@storybook/addons";
var findProto = (obj, callback) => {
  const proto = Object.getPrototypeOf(obj);
  if (!proto || callback(proto))
    return proto;
  return findProto(proto, callback);
};
var isReactSyntheticEvent = (e) => Boolean(
  typeof e === "object" && e && findProto(e, (proto) => /^Synthetic(?:Base)?Event$/.test(proto.constructor.name)) && typeof e.persist === "function"
);
var serializeArg = (a) => {
  if (isReactSyntheticEvent(a)) {
    const e = Object.create(
      a.constructor.prototype,
      Object.getOwnPropertyDescriptors(a)
    );
    e.persist();
    const viewDescriptor = Object.getOwnPropertyDescriptor(e, "view");
    const view = viewDescriptor?.value;
    if (typeof view === "object" && view?.constructor.name === "Window") {
      Object.defineProperty(e, "view", {
        ...viewDescriptor,
        value: Object.create(view.constructor.prototype)
      });
    }
    return e;
  }
  return a;
};
function action(name, options = {}) {
  const actionOptions = {
    ...config,
    ...options
  };
  const handler = function actionHandler(...args) {
    const channel = addons.getChannel();
    const id = uuidv4();
    const minDepth = 5;
    const serializedArgs = args.map(serializeArg);
    const normalizedArgs = args.length > 1 ? serializedArgs : serializedArgs[0];
    const actionDisplayToEmit = {
      id,
      count: 0,
      data: { name, args: normalizedArgs },
      options: {
        ...actionOptions,
        maxDepth: minDepth + (actionOptions.depth || 3),
        allowFunction: actionOptions.allowFunction || false
      }
    };
    channel.emit(EVENT_ID, actionDisplayToEmit);
  };
  handler.isAction = true;
  return handler;
}

// src/runtime/actions.ts
var actions = (...args) => {
  let options = config;
  let names = args;
  if (names.length === 1 && Array.isArray(names[0])) {
    [names] = names;
  }
  if (names.length !== 1 && typeof names[names.length - 1] !== "string") {
    options = {
      ...config,
      ...names.pop()
    };
  }
  let namesObject = names[0];
  if (names.length !== 1 || typeof namesObject === "string") {
    namesObject = {};
    names.forEach((name) => {
      namesObject[name] = name;
    });
  }
  const actionsObject = {};
  Object.keys(namesObject).forEach((name) => {
    actionsObject[name] = action(namesObject[name], options);
  });
  return actionsObject;
};

// src/runtime/withActions.ts
import global from "global";
import { useEffect, makeDecorator } from "@storybook/addons";
import deprecate from "util-deprecate";
import { dedent } from "ts-dedent";
var { document, Element } = global;
var delegateEventSplitter = /^(\S+)\s*(.*)$/;
var isIE = Element != null && !Element.prototype.matches;
var matchesMethod = isIE ? "msMatchesSelector" : "matches";
var hasMatchInAncestry = (element, selector) => {
  if (element[matchesMethod](selector)) {
    return true;
  }
  const parent = element.parentElement;
  if (!parent) {
    return false;
  }
  return hasMatchInAncestry(parent, selector);
};
var createHandlers = (actionsFn, ...handles) => {
  const actionsObject = actionsFn(...handles);
  return Object.entries(actionsObject).map(([key, action2]) => {
    const [_, eventName, selector] = key.match(delegateEventSplitter) || [];
    return {
      eventName,
      handler: (e) => {
        if (!selector || hasMatchInAncestry(e.target, selector)) {
          action2(e);
        }
      }
    };
  });
};
var applyEventHandlers = deprecate(
  (actionsFn, ...handles) => {
    const root = document && document.getElementById("storybook-root");
    useEffect(() => {
      if (root != null) {
        const handlers = createHandlers(actionsFn, ...handles);
        handlers.forEach(({ eventName, handler }) => root.addEventListener(eventName, handler));
        return () => handlers.forEach(
          ({ eventName, handler }) => root.removeEventListener(eventName, handler)
        );
      }
      return void 0;
    }, [root, actionsFn, handles]);
  },
  dedent`
    withActions(options) is deprecated, please configure addon-actions using the addParameter api:

    addParameters({
      actions: {
        handles: options
      },
    });
  `
);
var applyDeprecatedOptions = (actionsFn, options) => {
  if (options) {
    applyEventHandlers(actionsFn, options);
  }
};
var withActions = makeDecorator({
  name: "withActions",
  parameterName: PARAM_KEY,
  skipIfNoParametersOrOptions: true,
  wrapper: (getStory, context, { parameters, options }) => {
    applyDeprecatedOptions(actions, options);
    if (parameters && parameters.handles)
      applyEventHandlers(actions, ...parameters.handles);
    return getStory(context);
  }
});

export {
  PARAM_KEY,
  ADDON_ID,
  PANEL_ID,
  EVENT_ID,
  CYCLIC_KEY,
  config,
  configureActions,
  action,
  actions,
  withActions
};
