var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/ts-dedent/esm/index.js
function dedent(templ) {
  var values = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    values[_i - 1] = arguments[_i];
  }
  var strings = Array.from(typeof templ === "string" ? [templ] : templ);
  strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var indentLengths = strings.reduce(function(arr, str) {
    var matches = str.match(/\n([\t ]+|(?!\s).)/g);
    if (matches) {
      return arr.concat(matches.map(function(match) {
        var _a, _b;
        return (_b = (_a = match.match(/[\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      }));
    }
    return arr;
  }, []);
  if (indentLengths.length) {
    var pattern_1 = new RegExp("\n[	 ]{" + Math.min.apply(Math, indentLengths) + "}", "g");
    strings = strings.map(function(str) {
      return str.replace(pattern_1, "\n");
    });
  }
  strings[0] = strings[0].replace(/^\r?\n/, "");
  var string = strings[0];
  values.forEach(function(value, i) {
    var endentations = string.match(/(?:^|\n)( *)$/);
    var endentation = endentations ? endentations[1] : "";
    var indentedValue = value;
    if (typeof value === "string" && value.includes("\n")) {
      indentedValue = String(value).split("\n").map(function(str, i2) {
        return i2 === 0 ? str : "" + endentation + str;
      }).join("\n");
    }
    string += indentedValue + strings[i + 1];
  });
  return string;
}
var init_esm = __esm({
  "../../node_modules/ts-dedent/esm/index.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var init_extends = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/extends.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
var init_setPrototypeOf = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
var init_inheritsLoose = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js"() {
    init_setPrototypeOf();
  }
});

// ../../node_modules/global/window.js
var require_window = __commonJS({
  "../../node_modules/global/window.js"(exports, module2) {
    var win;
    if (typeof window !== "undefined") {
      win = window;
    } else if (typeof global !== "undefined") {
      win = global;
    } else if (typeof self !== "undefined") {
      win = self;
    } else {
      win = {};
    }
    module2.exports = win;
  }
});

// ../../node_modules/refractor/lang/jsx.js
var require_jsx = __commonJS({
  "../../node_modules/refractor/lang/jsx.js"(exports, module2) {
    "use strict";
    module2.exports = jsx2;
    jsx2.displayName = "jsx";
    jsx2.aliases = [];
    function jsx2(Prism) {
      ;
      (function(Prism2) {
        var javascript = Prism2.util.clone(Prism2.languages.javascript);
        var space = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
        var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
        var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
        function re(source, flags) {
          source = source.replace(/<S>/g, function() {
            return space;
          }).replace(/<BRACES>/g, function() {
            return braces;
          }).replace(/<SPREAD>/g, function() {
            return spread;
          });
          return RegExp(source, flags);
        }
        spread = re(spread).source;
        Prism2.languages.jsx = Prism2.languages.extend("markup", javascript);
        Prism2.languages.jsx.tag.pattern = re(
          /<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source
        );
        Prism2.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
        Prism2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
        Prism2.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
        Prism2.languages.jsx.tag.inside["comment"] = javascript["comment"];
        Prism2.languages.insertBefore(
          "inside",
          "attr-name",
          {
            spread: {
              pattern: re(/<SPREAD>/.source),
              inside: Prism2.languages.jsx
            }
          },
          Prism2.languages.jsx.tag
        );
        Prism2.languages.insertBefore(
          "inside",
          "special-attr",
          {
            script: {
              pattern: re(/=<BRACES>/.source),
              alias: "language-javascript",
              inside: {
                "script-punctuation": {
                  pattern: /^=(?=\{)/,
                  alias: "punctuation"
                },
                rest: Prism2.languages.jsx
              }
            }
          },
          Prism2.languages.jsx.tag
        );
        var stringifyToken = function(token) {
          if (!token) {
            return "";
          }
          if (typeof token === "string") {
            return token;
          }
          if (typeof token.content === "string") {
            return token.content;
          }
          return token.content.map(stringifyToken).join("");
        };
        var walkTokens = function(tokens) {
          var openedTags = [];
          for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var notTagNorBrace = false;
            if (typeof token !== "string") {
              if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") {
                if (token.content[0].content[0].content === "</") {
                  if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
                    openedTags.pop();
                  }
                } else {
                  if (token.content[token.content.length - 1].content === "/>") {
                  } else {
                    openedTags.push({
                      tagName: stringifyToken(token.content[0].content[1]),
                      openedBraces: 0
                    });
                  }
                }
              } else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{") {
                openedTags[openedTags.length - 1].openedBraces++;
              } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") {
                openedTags[openedTags.length - 1].openedBraces--;
              } else {
                notTagNorBrace = true;
              }
            }
            if (notTagNorBrace || typeof token === "string") {
              if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
                var plainText = stringifyToken(token);
                if (i < tokens.length - 1 && (typeof tokens[i + 1] === "string" || tokens[i + 1].type === "plain-text")) {
                  plainText += stringifyToken(tokens[i + 1]);
                  tokens.splice(i + 1, 1);
                }
                if (i > 0 && (typeof tokens[i - 1] === "string" || tokens[i - 1].type === "plain-text")) {
                  plainText = stringifyToken(tokens[i - 1]) + plainText;
                  tokens.splice(i - 1, 1);
                  i--;
                }
                tokens[i] = new Prism2.Token(
                  "plain-text",
                  plainText,
                  null,
                  plainText
                );
              }
            }
            if (token.content && typeof token.content !== "string") {
              walkTokens(token.content);
            }
          }
        };
        Prism2.hooks.add("after-tokenize", function(env) {
          if (env.language !== "jsx" && env.language !== "tsx") {
            return;
          }
          walkTokens(env.tokens);
        });
      })(Prism);
    }
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/jsx.js
var import_jsx, jsx_default;
var init_jsx = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/jsx.js"() {
    import_jsx = __toESM(require_jsx());
    jsx_default = import_jsx.default;
  }
});

// ../../node_modules/refractor/lang/bash.js
var require_bash = __commonJS({
  "../../node_modules/refractor/lang/bash.js"(exports, module2) {
    "use strict";
    module2.exports = bash2;
    bash2.displayName = "bash";
    bash2.aliases = ["shell"];
    function bash2(Prism) {
      ;
      (function(Prism2) {
        var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
        var commandAfterHeredoc = {
          pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
          lookbehind: true,
          alias: "punctuation",
          inside: null
        };
        var insideString = {
          bash: commandAfterHeredoc,
          environment: {
            pattern: RegExp("\\$" + envVars),
            alias: "constant"
          },
          variable: [
            {
              pattern: /\$?\(\([\s\S]+?\)\)/,
              greedy: true,
              inside: {
                variable: [
                  {
                    pattern: /(^\$\(\([\s\S]+)\)\)/,
                    lookbehind: true
                  },
                  /^\$\(\(/
                ],
                number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
                operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
                punctuation: /\(\(?|\)\)?|,|;/
              }
            },
            {
              pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
              greedy: true,
              inside: {
                variable: /^\$\(|^`|\)$|`$/
              }
            },
            {
              pattern: /\$\{[^}]+\}/,
              greedy: true,
              inside: {
                operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
                punctuation: /[\[\]]/,
                environment: {
                  pattern: RegExp("(\\{)" + envVars),
                  lookbehind: true,
                  alias: "constant"
                }
              }
            },
            /\$(?:\w+|[#?*!@$])/
          ],
          entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
        };
        Prism2.languages.bash = {
          shebang: {
            pattern: /^#!\s*\/.*/,
            alias: "important"
          },
          comment: {
            pattern: /(^|[^"{\\$])#.*/,
            lookbehind: true
          },
          "function-name": [
            {
              pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
              lookbehind: true,
              alias: "function"
            },
            {
              pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
              alias: "function"
            }
          ],
          "for-or-select": {
            pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
            alias: "variable",
            lookbehind: true
          },
          "assign-left": {
            pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
            inside: {
              environment: {
                pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
                lookbehind: true,
                alias: "constant"
              }
            },
            alias: "variable",
            lookbehind: true
          },
          string: [
            {
              pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
              lookbehind: true,
              greedy: true,
              inside: insideString
            },
            {
              pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
              lookbehind: true,
              greedy: true,
              inside: {
                bash: commandAfterHeredoc
              }
            },
            {
              pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
              lookbehind: true,
              greedy: true,
              inside: insideString
            },
            {
              pattern: /(^|[^$\\])'[^']*'/,
              lookbehind: true,
              greedy: true
            },
            {
              pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
              greedy: true,
              inside: {
                entity: insideString.entity
              }
            }
          ],
          environment: {
            pattern: RegExp("\\$?" + envVars),
            alias: "constant"
          },
          variable: insideString.variable,
          function: {
            pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
            lookbehind: true
          },
          keyword: {
            pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
            lookbehind: true
          },
          builtin: {
            pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
            lookbehind: true,
            alias: "class-name"
          },
          boolean: {
            pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
            lookbehind: true
          },
          "file-descriptor": {
            pattern: /\B&\d\b/,
            alias: "important"
          },
          operator: {
            pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
            inside: {
              "file-descriptor": {
                pattern: /^\d/,
                alias: "important"
              }
            }
          },
          punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
          number: {
            pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
            lookbehind: true
          }
        };
        commandAfterHeredoc.inside = Prism2.languages.bash;
        var toBeCopied = [
          "comment",
          "function-name",
          "for-or-select",
          "assign-left",
          "string",
          "environment",
          "function",
          "keyword",
          "builtin",
          "boolean",
          "file-descriptor",
          "operator",
          "punctuation",
          "number"
        ];
        var inside = insideString.variable[1].inside;
        for (var i = 0; i < toBeCopied.length; i++) {
          inside[toBeCopied[i]] = Prism2.languages.bash[toBeCopied[i]];
        }
        Prism2.languages.shell = Prism2.languages.bash;
      })(Prism);
    }
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/bash.js
var import_bash, bash_default;
var init_bash = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/bash.js"() {
    import_bash = __toESM(require_bash());
    bash_default = import_bash.default;
  }
});

// ../../node_modules/refractor/lang/css.js
var require_css = __commonJS({
  "../../node_modules/refractor/lang/css.js"(exports, module2) {
    "use strict";
    module2.exports = css2;
    css2.displayName = "css";
    css2.aliases = [];
    function css2(Prism) {
      ;
      (function(Prism2) {
        var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
        Prism2.languages.css = {
          comment: /\/\*[\s\S]*?\*\//,
          atrule: {
            pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
            inside: {
              rule: /^@[\w-]+/,
              "selector-function-argument": {
                pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                lookbehind: true,
                alias: "selector"
              },
              keyword: {
                pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                lookbehind: true
              }
            }
          },
          url: {
            pattern: RegExp(
              "\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)",
              "i"
            ),
            greedy: true,
            inside: {
              function: /^url/i,
              punctuation: /^\(|\)$/,
              string: {
                pattern: RegExp("^" + string.source + "$"),
                alias: "url"
              }
            }
          },
          selector: {
            pattern: RegExp(
              `(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"
            ),
            lookbehind: true
          },
          string: {
            pattern: string,
            greedy: true
          },
          property: {
            pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
            lookbehind: true
          },
          important: /!important\b/i,
          function: {
            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
            lookbehind: true
          },
          punctuation: /[(){};:,]/
        };
        Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
        var markup2 = Prism2.languages.markup;
        if (markup2) {
          markup2.tag.addInlined("style", "css");
          markup2.tag.addAttribute("style", "css");
        }
      })(Prism);
    }
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/css.js
var import_css, css_default;
var init_css = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/css.js"() {
    import_css = __toESM(require_css());
    css_default = import_css.default;
  }
});

// ../../node_modules/refractor/lang/js-extras.js
var require_js_extras = __commonJS({
  "../../node_modules/refractor/lang/js-extras.js"(exports, module2) {
    "use strict";
    module2.exports = jsExtras2;
    jsExtras2.displayName = "jsExtras";
    jsExtras2.aliases = [];
    function jsExtras2(Prism) {
      ;
      (function(Prism2) {
        Prism2.languages.insertBefore("javascript", "function-variable", {
          "method-variable": {
            pattern: RegExp(
              "(\\.\\s*)" + Prism2.languages.javascript["function-variable"].pattern.source
            ),
            lookbehind: true,
            alias: ["function-variable", "method", "function", "property-access"]
          }
        });
        Prism2.languages.insertBefore("javascript", "function", {
          method: {
            pattern: RegExp(
              "(\\.\\s*)" + Prism2.languages.javascript["function"].source
            ),
            lookbehind: true,
            alias: ["function", "property-access"]
          }
        });
        Prism2.languages.insertBefore("javascript", "constant", {
          "known-class-name": [
            {
              pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
              alias: "class-name"
            },
            {
              pattern: /\b(?:[A-Z]\w*)Error\b/,
              alias: "class-name"
            }
          ]
        });
        function withId(source, flags) {
          return RegExp(
            source.replace(/<ID>/g, function() {
              return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
            }),
            flags
          );
        }
        Prism2.languages.insertBefore("javascript", "keyword", {
          imports: {
            pattern: withId(
              /(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source
            ),
            lookbehind: true,
            inside: Prism2.languages.javascript
          },
          exports: {
            pattern: withId(
              /(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source
            ),
            lookbehind: true,
            inside: Prism2.languages.javascript
          }
        });
        Prism2.languages.javascript["keyword"].unshift(
          {
            pattern: /\b(?:as|default|export|from|import)\b/,
            alias: "module"
          },
          {
            pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
            alias: "control-flow"
          },
          {
            pattern: /\bnull\b/,
            alias: ["null", "nil"]
          },
          {
            pattern: /\bundefined\b/,
            alias: "nil"
          }
        );
        Prism2.languages.insertBefore("javascript", "operator", {
          spread: {
            pattern: /\.{3}/,
            alias: "operator"
          },
          arrow: {
            pattern: /=>/,
            alias: "operator"
          }
        });
        Prism2.languages.insertBefore("javascript", "punctuation", {
          "property-access": {
            pattern: withId(/(\.\s*)#?<ID>/.source),
            lookbehind: true
          },
          "maybe-class-name": {
            pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
            lookbehind: true
          },
          dom: {
            pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
            alias: "variable"
          },
          console: {
            pattern: /\bconsole(?=\s*\.)/,
            alias: "class-name"
          }
        });
        var maybeClassNameTokens = [
          "function",
          "function-variable",
          "method",
          "method-variable",
          "property-access"
        ];
        for (var i = 0; i < maybeClassNameTokens.length; i++) {
          var token = maybeClassNameTokens[i];
          var value = Prism2.languages.javascript[token];
          if (Prism2.util.type(value) === "RegExp") {
            value = Prism2.languages.javascript[token] = {
              pattern: value
            };
          }
          var inside = value.inside || {};
          value.inside = inside;
          inside["maybe-class-name"] = /^[A-Z][\s\S]*/;
        }
      })(Prism);
    }
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/js-extras.js
var import_js_extras, js_extras_default;
var init_js_extras = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/js-extras.js"() {
    import_js_extras = __toESM(require_js_extras());
    js_extras_default = import_js_extras.default;
  }
});

// ../../node_modules/refractor/lang/json.js
var require_json = __commonJS({
  "../../node_modules/refractor/lang/json.js"(exports, module2) {
    "use strict";
    module2.exports = json2;
    json2.displayName = "json";
    json2.aliases = ["webmanifest"];
    function json2(Prism) {
      Prism.languages.json = {
        property: {
          pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
          lookbehind: true,
          greedy: true
        },
        string: {
          pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
          lookbehind: true,
          greedy: true
        },
        comment: {
          pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
          greedy: true
        },
        number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
        punctuation: /[{}[\],]/,
        operator: /:/,
        boolean: /\b(?:false|true)\b/,
        null: {
          pattern: /\bnull\b/,
          alias: "keyword"
        }
      };
      Prism.languages.webmanifest = Prism.languages.json;
    }
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/json.js
var import_json, json_default;
var init_json = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/json.js"() {
    import_json = __toESM(require_json());
    json_default = import_json.default;
  }
});

// ../../node_modules/refractor/lang/graphql.js
var require_graphql = __commonJS({
  "../../node_modules/refractor/lang/graphql.js"(exports, module2) {
    "use strict";
    module2.exports = graphql2;
    graphql2.displayName = "graphql";
    graphql2.aliases = [];
    function graphql2(Prism) {
      Prism.languages.graphql = {
        comment: /#.*/,
        description: {
          pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
          greedy: true,
          alias: "string",
          inside: {
            "language-markdown": {
              pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
              lookbehind: true,
              inside: Prism.languages.markdown
            }
          }
        },
        string: {
          pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
          greedy: true
        },
        number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
        boolean: /\b(?:false|true)\b/,
        variable: /\$[a-z_]\w*/i,
        directive: {
          pattern: /@[a-z_]\w*/i,
          alias: "function"
        },
        "attr-name": {
          pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
          greedy: true
        },
        "atom-input": {
          pattern: /\b[A-Z]\w*Input\b/,
          alias: "class-name"
        },
        scalar: /\b(?:Boolean|Float|ID|Int|String)\b/,
        constant: /\b[A-Z][A-Z_\d]*\b/,
        "class-name": {
          pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
          lookbehind: true
        },
        fragment: {
          pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
          lookbehind: true,
          alias: "function"
        },
        "definition-mutation": {
          pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
          lookbehind: true,
          alias: "function"
        },
        "definition-query": {
          pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
          lookbehind: true,
          alias: "function"
        },
        keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
        operator: /[!=|&]|\.{3}/,
        "property-query": /\w+(?=\s*\()/,
        object: /\w+(?=\s*\{)/,
        punctuation: /[!(){}\[\]:=,]/,
        property: /\w+/
      };
      Prism.hooks.add("after-tokenize", function afterTokenizeGraphql(env) {
        if (env.language !== "graphql") {
          return;
        }
        var validTokens = env.tokens.filter(function(token) {
          return typeof token !== "string" && token.type !== "comment" && token.type !== "scalar";
        });
        var currentIndex = 0;
        function getToken(offset) {
          return validTokens[currentIndex + offset];
        }
        function isTokenType(types, offset) {
          offset = offset || 0;
          for (var i2 = 0; i2 < types.length; i2++) {
            var token = getToken(i2 + offset);
            if (!token || token.type !== types[i2]) {
              return false;
            }
          }
          return true;
        }
        function findClosingBracket(open, close) {
          var stackHeight = 1;
          for (var i2 = currentIndex; i2 < validTokens.length; i2++) {
            var token = validTokens[i2];
            var content = token.content;
            if (token.type === "punctuation" && typeof content === "string") {
              if (open.test(content)) {
                stackHeight++;
              } else if (close.test(content)) {
                stackHeight--;
                if (stackHeight === 0) {
                  return i2;
                }
              }
            }
          }
          return -1;
        }
        function addAlias(token, alias) {
          var aliases = token.alias;
          if (!aliases) {
            token.alias = aliases = [];
          } else if (!Array.isArray(aliases)) {
            token.alias = aliases = [aliases];
          }
          aliases.push(alias);
        }
        for (; currentIndex < validTokens.length; ) {
          var startToken = validTokens[currentIndex++];
          if (startToken.type === "keyword" && startToken.content === "mutation") {
            var inputVariables = [];
            if (isTokenType(["definition-mutation", "punctuation"]) && getToken(1).content === "(") {
              currentIndex += 2;
              var definitionEnd = findClosingBracket(/^\($/, /^\)$/);
              if (definitionEnd === -1) {
                continue;
              }
              for (; currentIndex < definitionEnd; currentIndex++) {
                var t = getToken(0);
                if (t.type === "variable") {
                  addAlias(t, "variable-input");
                  inputVariables.push(t.content);
                }
              }
              currentIndex = definitionEnd + 1;
            }
            if (isTokenType(["punctuation", "property-query"]) && getToken(0).content === "{") {
              currentIndex++;
              addAlias(getToken(0), "property-mutation");
              if (inputVariables.length > 0) {
                var mutationEnd = findClosingBracket(/^\{$/, /^\}$/);
                if (mutationEnd === -1) {
                  continue;
                }
                for (var i = currentIndex; i < mutationEnd; i++) {
                  var varToken = validTokens[i];
                  if (varToken.type === "variable" && inputVariables.indexOf(varToken.content) >= 0) {
                    addAlias(varToken, "variable-input");
                  }
                }
              }
            }
          }
        }
      });
    }
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/graphql.js
var import_graphql, graphql_default;
var init_graphql = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/graphql.js"() {
    import_graphql = __toESM(require_graphql());
    graphql_default = import_graphql.default;
  }
});

// ../../node_modules/refractor/lang/markup.js
var require_markup = __commonJS({
  "../../node_modules/refractor/lang/markup.js"(exports, module2) {
    "use strict";
    module2.exports = markup2;
    markup2.displayName = "markup";
    markup2.aliases = ["html", "mathml", "svg", "xml", "ssml", "atom", "rss"];
    function markup2(Prism) {
      Prism.languages.markup = {
        comment: {
          pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
          greedy: true
        },
        prolog: {
          pattern: /<\?[\s\S]+?\?>/,
          greedy: true
        },
        doctype: {
          pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
          greedy: true,
          inside: {
            "internal-subset": {
              pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
              lookbehind: true,
              greedy: true,
              inside: null
            },
            string: {
              pattern: /"[^"]*"|'[^']*'/,
              greedy: true
            },
            punctuation: /^<!|>$|[[\]]/,
            "doctype-tag": /^DOCTYPE/i,
            name: /[^\s<>'"]+/
          }
        },
        cdata: {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          greedy: true
        },
        tag: {
          pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
          greedy: true,
          inside: {
            tag: {
              pattern: /^<\/?[^\s>\/]+/,
              inside: {
                punctuation: /^<\/?/,
                namespace: /^[^\s>\/:]+:/
              }
            },
            "special-attr": [],
            "attr-value": {
              pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
              inside: {
                punctuation: [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            },
            punctuation: /\/?>/,
            "attr-name": {
              pattern: /[^\s>\/]+/,
              inside: {
                namespace: /^[^\s>\/:]+:/
              }
            }
          }
        },
        entity: [
          {
            pattern: /&[\da-z]{1,8};/i,
            alias: "named-entity"
          },
          /&#x?[\da-f]{1,8};/i
        ]
      };
      Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
      Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
      Prism.hooks.add("wrap", function(env) {
        if (env.type === "entity") {
          env.attributes["title"] = env.content.value.replace(/&amp;/, "&");
        }
      });
      Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
        value: function addInlined(tagName, lang) {
          var includedCdataInside = {};
          includedCdataInside["language-" + lang] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: true,
            inside: Prism.languages[lang]
          };
          includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
          var inside = {
            "included-cdata": {
              pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
              inside: includedCdataInside
            }
          };
          inside["language-" + lang] = {
            pattern: /[\s\S]+/,
            inside: Prism.languages[lang]
          };
          var def = {};
          def[tagName] = {
            pattern: RegExp(
              /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
                /__/g,
                function() {
                  return tagName;
                }
              ),
              "i"
            ),
            lookbehind: true,
            greedy: true,
            inside
          };
          Prism.languages.insertBefore("markup", "cdata", def);
        }
      });
      Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
        value: function(attrName, lang) {
          Prism.languages.markup.tag.inside["special-attr"].push({
            pattern: RegExp(
              /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
              "i"
            ),
            lookbehind: true,
            inside: {
              "attr-name": /^[^\s=]+/,
              "attr-value": {
                pattern: /=[\s\S]+/,
                inside: {
                  value: {
                    pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                    lookbehind: true,
                    alias: [lang, "language-" + lang],
                    inside: Prism.languages[lang]
                  },
                  punctuation: [
                    {
                      pattern: /^=/,
                      alias: "attr-equals"
                    },
                    /"|'/
                  ]
                }
              }
            }
          });
        }
      });
      Prism.languages.html = Prism.languages.markup;
      Prism.languages.mathml = Prism.languages.markup;
      Prism.languages.svg = Prism.languages.markup;
      Prism.languages.xml = Prism.languages.extend("markup", {});
      Prism.languages.ssml = Prism.languages.xml;
      Prism.languages.atom = Prism.languages.xml;
      Prism.languages.rss = Prism.languages.xml;
    }
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/markup.js
var import_markup, markup_default;
var init_markup = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/markup.js"() {
    import_markup = __toESM(require_markup());
    markup_default = import_markup.default;
  }
});

// ../../node_modules/refractor/lang/markdown.js
var require_markdown = __commonJS({
  "../../node_modules/refractor/lang/markdown.js"(exports, module2) {
    "use strict";
    module2.exports = markdown2;
    markdown2.displayName = "markdown";
    markdown2.aliases = ["md"];
    function markdown2(Prism) {
      ;
      (function(Prism2) {
        var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
        function createInline(pattern) {
          pattern = pattern.replace(/<inner>/g, function() {
            return inner;
          });
          return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
        }
        var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
        var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(
          /__/g,
          function() {
            return tableCell;
          }
        );
        var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
        Prism2.languages.markdown = Prism2.languages.extend("markup", {});
        Prism2.languages.insertBefore("markdown", "prolog", {
          "front-matter-block": {
            pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
            lookbehind: true,
            greedy: true,
            inside: {
              punctuation: /^---|---$/,
              "front-matter": {
                pattern: /\S+(?:\s+\S+)*/,
                alias: ["yaml", "language-yaml"],
                inside: Prism2.languages.yaml
              }
            }
          },
          blockquote: {
            pattern: /^>(?:[\t ]*>)*/m,
            alias: "punctuation"
          },
          table: {
            pattern: RegExp(
              "^" + tableRow + tableLine + "(?:" + tableRow + ")*",
              "m"
            ),
            inside: {
              "table-data-rows": {
                pattern: RegExp(
                  "^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"
                ),
                lookbehind: true,
                inside: {
                  "table-data": {
                    pattern: RegExp(tableCell),
                    inside: Prism2.languages.markdown
                  },
                  punctuation: /\|/
                }
              },
              "table-line": {
                pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
                lookbehind: true,
                inside: {
                  punctuation: /\||:?-{3,}:?/
                }
              },
              "table-header-row": {
                pattern: RegExp("^" + tableRow + "$"),
                inside: {
                  "table-header": {
                    pattern: RegExp(tableCell),
                    alias: "important",
                    inside: Prism2.languages.markdown
                  },
                  punctuation: /\|/
                }
              }
            }
          },
          code: [
            {
              pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
              lookbehind: true,
              alias: "keyword"
            },
            {
              pattern: /^```[\s\S]*?^```$/m,
              greedy: true,
              inside: {
                "code-block": {
                  pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
                  lookbehind: true
                },
                "code-language": {
                  pattern: /^(```).+/,
                  lookbehind: true
                },
                punctuation: /```/
              }
            }
          ],
          title: [
            {
              pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
              alias: "important",
              inside: {
                punctuation: /==+$|--+$/
              }
            },
            {
              pattern: /(^\s*)#.+/m,
              lookbehind: true,
              alias: "important",
              inside: {
                punctuation: /^#+|#+$/
              }
            }
          ],
          hr: {
            pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
            lookbehind: true,
            alias: "punctuation"
          },
          list: {
            pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
            lookbehind: true,
            alias: "punctuation"
          },
          "url-reference": {
            pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
            inside: {
              variable: {
                pattern: /^(!?\[)[^\]]+/,
                lookbehind: true
              },
              string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
              punctuation: /^[\[\]!:]|[<>]/
            },
            alias: "url"
          },
          bold: {
            pattern: createInline(
              /\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source
            ),
            lookbehind: true,
            greedy: true,
            inside: {
              content: {
                pattern: /(^..)[\s\S]+(?=..$)/,
                lookbehind: true,
                inside: {}
              },
              punctuation: /\*\*|__/
            }
          },
          italic: {
            pattern: createInline(
              /\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source
            ),
            lookbehind: true,
            greedy: true,
            inside: {
              content: {
                pattern: /(^.)[\s\S]+(?=.$)/,
                lookbehind: true,
                inside: {}
              },
              punctuation: /[*_]/
            }
          },
          strike: {
            pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
            lookbehind: true,
            greedy: true,
            inside: {
              content: {
                pattern: /(^~~?)[\s\S]+(?=\1$)/,
                lookbehind: true,
                inside: {}
              },
              punctuation: /~~?/
            }
          },
          "code-snippet": {
            pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
            lookbehind: true,
            greedy: true,
            alias: ["code", "keyword"]
          },
          url: {
            pattern: createInline(
              /!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source
            ),
            lookbehind: true,
            greedy: true,
            inside: {
              operator: /^!/,
              content: {
                pattern: /(^\[)[^\]]+(?=\])/,
                lookbehind: true,
                inside: {}
              },
              variable: {
                pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
                lookbehind: true
              },
              url: {
                pattern: /(^\]\()[^\s)]+/,
                lookbehind: true
              },
              string: {
                pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
                lookbehind: true
              }
            }
          }
        });
        ["url", "bold", "italic", "strike"].forEach(function(token) {
          ;
          ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
            if (token !== inside) {
              Prism2.languages.markdown[token].inside.content.inside[inside] = Prism2.languages.markdown[inside];
            }
          });
        });
        Prism2.hooks.add("after-tokenize", function(env) {
          if (env.language !== "markdown" && env.language !== "md") {
            return;
          }
          function walkTokens(tokens) {
            if (!tokens || typeof tokens === "string") {
              return;
            }
            for (var i = 0, l = tokens.length; i < l; i++) {
              var token = tokens[i];
              if (token.type !== "code") {
                walkTokens(token.content);
                continue;
              }
              var codeLang = token.content[1];
              var codeBlock = token.content[3];
              if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
                var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
                lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
                var alias = "language-" + lang;
                if (!codeBlock.alias) {
                  codeBlock.alias = [alias];
                } else if (typeof codeBlock.alias === "string") {
                  codeBlock.alias = [codeBlock.alias, alias];
                } else {
                  codeBlock.alias.push(alias);
                }
              }
            }
          }
          walkTokens(env.tokens);
        });
        Prism2.hooks.add("wrap", function(env) {
          if (env.type !== "code-block") {
            return;
          }
          var codeLang = "";
          for (var i = 0, l = env.classes.length; i < l; i++) {
            var cls = env.classes[i];
            var match = /language-(.+)/.exec(cls);
            if (match) {
              codeLang = match[1];
              break;
            }
          }
          var grammar = Prism2.languages[codeLang];
          if (!grammar) {
            if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
              var id = "md-" + new Date().valueOf() + "-" + Math.floor(Math.random() * 1e16);
              env.attributes["id"] = id;
              Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
                var ele = document.getElementById(id);
                if (ele) {
                  ele.innerHTML = Prism2.highlight(
                    ele.textContent,
                    Prism2.languages[codeLang],
                    codeLang
                  );
                }
              });
            }
          } else {
            env.content = Prism2.highlight(
              textContent(env.content.value),
              grammar,
              codeLang
            );
          }
        });
        var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
        var KNOWN_ENTITY_NAMES = {
          amp: "&",
          lt: "<",
          gt: ">",
          quot: '"'
        };
        var fromCodePoint = String.fromCodePoint || String.fromCharCode;
        function textContent(html) {
          var text = html.replace(tagPattern, "");
          text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m, code) {
            code = code.toLowerCase();
            if (code[0] === "#") {
              var value;
              if (code[1] === "x") {
                value = parseInt(code.slice(2), 16);
              } else {
                value = Number(code.slice(1));
              }
              return fromCodePoint(value);
            } else {
              var known = KNOWN_ENTITY_NAMES[code];
              if (known) {
                return known;
              }
              return m;
            }
          });
          return text;
        }
        Prism2.languages.md = Prism2.languages.markdown;
      })(Prism);
    }
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/markdown.js
var import_markdown, markdown_default;
var init_markdown = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/markdown.js"() {
    import_markdown = __toESM(require_markdown());
    markdown_default = import_markdown.default;
  }
});

// ../../node_modules/refractor/lang/yaml.js
var require_yaml = __commonJS({
  "../../node_modules/refractor/lang/yaml.js"(exports, module2) {
    "use strict";
    module2.exports = yaml2;
    yaml2.displayName = "yaml";
    yaml2.aliases = ["yml"];
    function yaml2(Prism) {
      ;
      (function(Prism2) {
        var anchorOrAlias = /[*&][^\s[\]{},]+/;
        var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
        var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
        var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(
          /<PLAIN>/g,
          function() {
            return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
          }
        );
        var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
        function createValuePattern(value, flags) {
          flags = (flags || "").replace(/m/g, "") + "m";
          var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
            return properties;
          }).replace(/<<value>>/g, function() {
            return value;
          });
          return RegExp(pattern, flags);
        }
        Prism2.languages.yaml = {
          scalar: {
            pattern: RegExp(
              /([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(
                /<<prop>>/g,
                function() {
                  return properties;
                }
              )
            ),
            lookbehind: true,
            alias: "string"
          },
          comment: /#.*/,
          key: {
            pattern: RegExp(
              /((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
                return properties;
              }).replace(/<<key>>/g, function() {
                return "(?:" + plainKey + "|" + string + ")";
              })
            ),
            lookbehind: true,
            greedy: true,
            alias: "atrule"
          },
          directive: {
            pattern: /(^[ \t]*)%.+/m,
            lookbehind: true,
            alias: "important"
          },
          datetime: {
            pattern: createValuePattern(
              /\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source
            ),
            lookbehind: true,
            alias: "number"
          },
          boolean: {
            pattern: createValuePattern(/false|true/.source, "i"),
            lookbehind: true,
            alias: "important"
          },
          null: {
            pattern: createValuePattern(/null|~/.source, "i"),
            lookbehind: true,
            alias: "important"
          },
          string: {
            pattern: createValuePattern(string),
            lookbehind: true,
            greedy: true
          },
          number: {
            pattern: createValuePattern(
              /[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source,
              "i"
            ),
            lookbehind: true
          },
          tag,
          important: anchorOrAlias,
          punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
        };
        Prism2.languages.yml = Prism2.languages.yaml;
      })(Prism);
    }
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/yaml.js
var import_yaml, yaml_default;
var init_yaml = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/yaml.js"() {
    import_yaml = __toESM(require_yaml());
    yaml_default = import_yaml.default;
  }
});

// ../../node_modules/refractor/lang/typescript.js
var require_typescript = __commonJS({
  "../../node_modules/refractor/lang/typescript.js"(exports, module2) {
    "use strict";
    module2.exports = typescript2;
    typescript2.displayName = "typescript";
    typescript2.aliases = ["ts"];
    function typescript2(Prism) {
      ;
      (function(Prism2) {
        Prism2.languages.typescript = Prism2.languages.extend("javascript", {
          "class-name": {
            pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
            lookbehind: true,
            greedy: true,
            inside: null
          },
          builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
        });
        Prism2.languages.typescript.keyword.push(
          /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
          /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
          /\btype\b(?=\s*(?:[\{*]|$))/
        );
        delete Prism2.languages.typescript["parameter"];
        delete Prism2.languages.typescript["literal-property"];
        var typeInside = Prism2.languages.extend("typescript", {});
        delete typeInside["class-name"];
        Prism2.languages.typescript["class-name"].inside = typeInside;
        Prism2.languages.insertBefore("typescript", "function", {
          decorator: {
            pattern: /@[$\w\xA0-\uFFFF]+/,
            inside: {
              at: {
                pattern: /^@/,
                alias: "operator"
              },
              function: /^[\s\S]+/
            }
          },
          "generic-function": {
            pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
            greedy: true,
            inside: {
              function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
              generic: {
                pattern: /<[\s\S]+/,
                alias: "class-name",
                inside: typeInside
              }
            }
          }
        });
        Prism2.languages.ts = Prism2.languages.typescript;
      })(Prism);
    }
  }
});

// ../../node_modules/refractor/lang/tsx.js
var require_tsx = __commonJS({
  "../../node_modules/refractor/lang/tsx.js"(exports, module2) {
    "use strict";
    var refractorJsx = require_jsx();
    var refractorTypescript = require_typescript();
    module2.exports = tsx2;
    tsx2.displayName = "tsx";
    tsx2.aliases = [];
    function tsx2(Prism) {
      Prism.register(refractorJsx);
      Prism.register(refractorTypescript);
      (function(Prism2) {
        var typescript2 = Prism2.util.clone(Prism2.languages.typescript);
        Prism2.languages.tsx = Prism2.languages.extend("jsx", typescript2);
        delete Prism2.languages.tsx["parameter"];
        delete Prism2.languages.tsx["literal-property"];
        var tag = Prism2.languages.tsx.tag;
        tag.pattern = RegExp(
          /(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")",
          tag.pattern.flags
        );
        tag.lookbehind = true;
      })(Prism);
    }
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/tsx.js
var import_tsx, tsx_default;
var init_tsx = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/tsx.js"() {
    import_tsx = __toESM(require_tsx());
    tsx_default = import_tsx.default;
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/typescript.js
var import_typescript, typescript_default;
var init_typescript = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/languages/prism/typescript.js"() {
    import_typescript = __toESM(require_typescript());
    typescript_default = import_typescript.default;
  }
});

// ../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js
var require_objectWithoutPropertiesLoose = __commonJS({
  "../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"(exports, module2) {
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    module2.exports = _objectWithoutPropertiesLoose, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var require_objectWithoutProperties = __commonJS({
  "../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js"(exports, module2) {
    var objectWithoutPropertiesLoose = require_objectWithoutPropertiesLoose();
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    module2.exports = _objectWithoutProperties2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS({
  "../../node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module2) {
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    module2.exports = _arrayLikeToArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
var require_arrayWithoutHoles = __commonJS({
  "../../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"(exports, module2) {
    var arrayLikeToArray = require_arrayLikeToArray();
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return arrayLikeToArray(arr);
    }
    module2.exports = _arrayWithoutHoles, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/iterableToArray.js
var require_iterableToArray = __commonJS({
  "../../node_modules/@babel/runtime/helpers/iterableToArray.js"(exports, module2) {
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    module2.exports = _iterableToArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS({
  "../../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module2) {
    var arrayLikeToArray = require_arrayLikeToArray();
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return arrayLikeToArray(o, minLen);
    }
    module2.exports = _unsupportedIterableToArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/nonIterableSpread.js
var require_nonIterableSpread = __commonJS({
  "../../node_modules/@babel/runtime/helpers/nonIterableSpread.js"(exports, module2) {
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module2.exports = _nonIterableSpread, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/toConsumableArray.js
var require_toConsumableArray = __commonJS({
  "../../node_modules/@babel/runtime/helpers/toConsumableArray.js"(exports, module2) {
    var arrayWithoutHoles = require_arrayWithoutHoles();
    var iterableToArray = require_iterableToArray();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableSpread = require_nonIterableSpread();
    function _toConsumableArray2(arr) {
      return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
    }
    module2.exports = _toConsumableArray2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "../../node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module2) {
    function _defineProperty3(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    module2.exports = _defineProperty3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS({
  "../../node_modules/@babel/runtime/helpers/extends.js"(exports, module2) {
    function _extends3() {
      module2.exports = _extends3 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      return _extends3.apply(this, arguments);
    }
    module2.exports = _extends3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/create-element.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      (0, import_defineProperty.default)(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function powerSetPermutations(arr) {
  var arrLength = arr.length;
  if (arrLength === 0 || arrLength === 1)
    return arr;
  if (arrLength === 2) {
    return [arr[0], arr[1], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength === 3) {
    return [arr[0], arr[1], arr[2], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength >= 4) {
    return [arr[0], arr[1], arr[2], arr[3], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3]), "".concat(arr[3], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
}
function getClassNameCombinations(classNames) {
  if (classNames.length === 0 || classNames.length === 1)
    return classNames;
  var key = classNames.join(".");
  if (!classNameCombinations[key]) {
    classNameCombinations[key] = powerSetPermutations(classNames);
  }
  return classNameCombinations[key];
}
function createStyleObject(classNames) {
  var elementStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var stylesheet = arguments.length > 2 ? arguments[2] : void 0;
  var nonTokenClassNames = classNames.filter(function(className) {
    return className !== "token";
  });
  var classNamesCombinations = getClassNameCombinations(nonTokenClassNames);
  return classNamesCombinations.reduce(function(styleObject, className) {
    return _objectSpread(_objectSpread({}, styleObject), stylesheet[className]);
  }, elementStyle);
}
function createClassNameString(classNames) {
  return classNames.join(" ");
}
function createChildren(stylesheet, useInlineStyles) {
  var childrenCount = 0;
  return function(children) {
    childrenCount += 1;
    return children.map(function(child, i) {
      return createElement({
        node: child,
        stylesheet,
        useInlineStyles,
        key: "code-segment-".concat(childrenCount, "-").concat(i)
      });
    });
  };
}
function createElement(_ref) {
  var node = _ref.node, stylesheet = _ref.stylesheet, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, useInlineStyles = _ref.useInlineStyles, key = _ref.key;
  var properties = node.properties, type = node.type, TagName = node.tagName, value = node.value;
  if (type === "text") {
    return value;
  } else if (TagName) {
    var childrenCreator = createChildren(stylesheet, useInlineStyles);
    var props;
    if (!useInlineStyles) {
      props = _objectSpread(_objectSpread({}, properties), {}, {
        className: createClassNameString(properties.className)
      });
    } else {
      var allStylesheetSelectors = Object.keys(stylesheet).reduce(function(classes, selector) {
        selector.split(".").forEach(function(className2) {
          if (!classes.includes(className2))
            classes.push(className2);
        });
        return classes;
      }, []);
      var startingClassName = properties.className && properties.className.includes("token") ? ["token"] : [];
      var className = properties.className && startingClassName.concat(properties.className.filter(function(className2) {
        return !allStylesheetSelectors.includes(className2);
      }));
      props = _objectSpread(_objectSpread({}, properties), {}, {
        className: createClassNameString(className) || void 0,
        style: createStyleObject(properties.className, Object.assign({}, properties.style, style), stylesheet)
      });
    }
    var children = childrenCreator(node.children);
    return /* @__PURE__ */ import_react2.default.createElement(TagName, (0, import_extends2.default)({
      key
    }, props), children);
  }
}
var import_extends2, import_defineProperty, import_react2, classNameCombinations;
var init_create_element = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/create-element.js"() {
    import_extends2 = __toESM(require_extends());
    import_defineProperty = __toESM(require_defineProperty());
    import_react2 = __toESM(require("react"));
    classNameCombinations = {};
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/checkForListedLanguage.js
var checkForListedLanguage_default;
var init_checkForListedLanguage = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/checkForListedLanguage.js"() {
    checkForListedLanguage_default = function(astGenerator, language) {
      var langs = astGenerator.listLanguages();
      return langs.indexOf(language) !== -1;
    };
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/highlight.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      (0, import_defineProperty2.default)(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function getNewLines(str) {
  return str.match(newLineRegex);
}
function getAllLineNumbers(_ref) {
  var lines = _ref.lines, startingLineNumber = _ref.startingLineNumber, style = _ref.style;
  return lines.map(function(_, i) {
    var number = i + startingLineNumber;
    return /* @__PURE__ */ import_react3.default.createElement("span", {
      key: "line-".concat(i),
      className: "react-syntax-highlighter-line-number",
      style: typeof style === "function" ? style(number) : style
    }, "".concat(number, "\n"));
  });
}
function AllLineNumbers(_ref2) {
  var codeString = _ref2.codeString, codeStyle = _ref2.codeStyle, _ref2$containerStyle = _ref2.containerStyle, containerStyle = _ref2$containerStyle === void 0 ? {
    "float": "left",
    paddingRight: "10px"
  } : _ref2$containerStyle, _ref2$numberStyle = _ref2.numberStyle, numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle, startingLineNumber = _ref2.startingLineNumber;
  return /* @__PURE__ */ import_react3.default.createElement("code", {
    style: Object.assign({}, codeStyle, containerStyle)
  }, getAllLineNumbers({
    lines: codeString.replace(/\n$/, "").split("\n"),
    style: numberStyle,
    startingLineNumber
  }));
}
function getEmWidthOfNumber(num) {
  return "".concat(num.toString().length, ".25em");
}
function getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
  return {
    type: "element",
    tagName: "span",
    properties: {
      key: "line-number--".concat(lineNumber),
      className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
      style: inlineLineNumberStyle
    },
    children: [{
      type: "text",
      value: lineNumber
    }]
  };
}
function assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
  var defaultLineNumberStyle = {
    display: "inline-block",
    minWidth: getEmWidthOfNumber(largestLineNumber),
    paddingRight: "1em",
    textAlign: "right",
    userSelect: "none"
  };
  var customLineNumberStyle = typeof lineNumberStyle === "function" ? lineNumberStyle(lineNumber) : lineNumberStyle;
  var assembledStyle = _objectSpread2(_objectSpread2({}, defaultLineNumberStyle), customLineNumberStyle);
  return assembledStyle;
}
function createLineElement(_ref3) {
  var children = _ref3.children, lineNumber = _ref3.lineNumber, lineNumberStyle = _ref3.lineNumberStyle, largestLineNumber = _ref3.largestLineNumber, showInlineLineNumbers = _ref3.showInlineLineNumbers, _ref3$lineProps = _ref3.lineProps, lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps, _ref3$className = _ref3.className, className = _ref3$className === void 0 ? [] : _ref3$className, showLineNumbers = _ref3.showLineNumbers, wrapLongLines = _ref3.wrapLongLines;
  var properties = typeof lineProps === "function" ? lineProps(lineNumber) : lineProps;
  properties["className"] = className;
  if (lineNumber && showInlineLineNumbers) {
    var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
    children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
  }
  if (wrapLongLines & showLineNumbers) {
    properties.style = _objectSpread2(_objectSpread2({}, properties.style), {}, {
      display: "flex"
    });
  }
  return {
    type: "element",
    tagName: "span",
    properties,
    children
  };
}
function flattenCodeTree(tree) {
  var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var newTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  for (var i = 0; i < tree.length; i++) {
    var node = tree[i];
    if (node.type === "text") {
      newTree.push(createLineElement({
        children: [node],
        className: (0, import_toConsumableArray.default)(new Set(className))
      }));
    } else if (node.children) {
      var classNames = className.concat(node.properties.className);
      flattenCodeTree(node.children, classNames).forEach(function(i2) {
        return newTree.push(i2);
      });
    }
  }
  return newTree;
}
function processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
  var _ref4;
  var tree = flattenCodeTree(codeTree.value);
  var newTree = [];
  var lastLineBreakIndex = -1;
  var index = 0;
  function createWrappedLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return createLineElement({
      children: children2,
      lineNumber: lineNumber2,
      lineNumberStyle,
      largestLineNumber,
      showInlineLineNumbers,
      lineProps,
      className,
      showLineNumbers,
      wrapLongLines
    });
  }
  function createUnwrappedLine(children2, lineNumber2) {
    if (showLineNumbers && lineNumber2 && showInlineLineNumbers) {
      var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber2, largestLineNumber);
      children2.unshift(getInlineLineNumber(lineNumber2, inlineLineNumberStyle));
    }
    return children2;
  }
  function createLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return wrapLines || className.length > 0 ? createWrappedLine(children2, lineNumber2, className) : createUnwrappedLine(children2, lineNumber2);
  }
  var _loop = function _loop2() {
    var node = tree[index];
    var value = node.children[0].value;
    var newLines = getNewLines(value);
    if (newLines) {
      var splitValue = value.split("\n");
      splitValue.forEach(function(text, i) {
        var lineNumber2 = showLineNumbers && newTree.length + startingLineNumber;
        var newChild = {
          type: "text",
          value: "".concat(text, "\n")
        };
        if (i === 0) {
          var _children = tree.slice(lastLineBreakIndex + 1, index).concat(createLineElement({
            children: [newChild],
            className: node.properties.className
          }));
          var _line = createLine(_children, lineNumber2);
          newTree.push(_line);
        } else if (i === splitValue.length - 1) {
          var stringChild = tree[index + 1] && tree[index + 1].children && tree[index + 1].children[0];
          var lastLineInPreviousSpan = {
            type: "text",
            value: "".concat(text)
          };
          if (stringChild) {
            var newElem = createLineElement({
              children: [lastLineInPreviousSpan],
              className: node.properties.className
            });
            tree.splice(index + 1, 0, newElem);
          } else {
            var _children2 = [lastLineInPreviousSpan];
            var _line2 = createLine(_children2, lineNumber2, node.properties.className);
            newTree.push(_line2);
          }
        } else {
          var _children3 = [newChild];
          var _line3 = createLine(_children3, lineNumber2, node.properties.className);
          newTree.push(_line3);
        }
      });
      lastLineBreakIndex = index;
    }
    index++;
  };
  while (index < tree.length) {
    _loop();
  }
  if (lastLineBreakIndex !== tree.length - 1) {
    var children = tree.slice(lastLineBreakIndex + 1, tree.length);
    if (children && children.length) {
      var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
      var line = createLine(children, lineNumber);
      newTree.push(line);
    }
  }
  return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
}
function defaultRenderer(_ref5) {
  var rows = _ref5.rows, stylesheet = _ref5.stylesheet, useInlineStyles = _ref5.useInlineStyles;
  return rows.map(function(node, i) {
    return createElement({
      node,
      stylesheet,
      useInlineStyles,
      key: "code-segement".concat(i)
    });
  });
}
function isHighlightJs(astGenerator) {
  return astGenerator && typeof astGenerator.highlightAuto !== "undefined";
}
function getCodeTree(_ref6) {
  var astGenerator = _ref6.astGenerator, language = _ref6.language, code = _ref6.code, defaultCodeValue = _ref6.defaultCodeValue;
  if (isHighlightJs(astGenerator)) {
    var hasLanguage = checkForListedLanguage_default(astGenerator, language);
    if (language === "text") {
      return {
        value: defaultCodeValue,
        language: "text"
      };
    } else if (hasLanguage) {
      return astGenerator.highlight(language, code);
    } else {
      return astGenerator.highlightAuto(code);
    }
  }
  try {
    return language && language !== "text" ? {
      value: astGenerator.highlight(code, language)
    } : {
      value: defaultCodeValue
    };
  } catch (e) {
    return {
      value: defaultCodeValue
    };
  }
}
function highlight_default(defaultAstGenerator, defaultStyle) {
  return function SyntaxHighlighter3(_ref7) {
    var language = _ref7.language, children = _ref7.children, _ref7$style = _ref7.style, style = _ref7$style === void 0 ? defaultStyle : _ref7$style, _ref7$customStyle = _ref7.customStyle, customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle, _ref7$codeTagProps = _ref7.codeTagProps, codeTagProps = _ref7$codeTagProps === void 0 ? {
      className: language ? "language-".concat(language) : void 0,
      style: _objectSpread2(_objectSpread2({}, style['code[class*="language-"]']), style['code[class*="language-'.concat(language, '"]')])
    } : _ref7$codeTagProps, _ref7$useInlineStyles = _ref7.useInlineStyles, useInlineStyles = _ref7$useInlineStyles === void 0 ? true : _ref7$useInlineStyles, _ref7$showLineNumbers = _ref7.showLineNumbers, showLineNumbers = _ref7$showLineNumbers === void 0 ? false : _ref7$showLineNumbers, _ref7$showInlineLineN = _ref7.showInlineLineNumbers, showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? true : _ref7$showInlineLineN, _ref7$startingLineNum = _ref7.startingLineNumber, startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum, lineNumberContainerStyle = _ref7.lineNumberContainerStyle, _ref7$lineNumberStyle = _ref7.lineNumberStyle, lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle, wrapLines = _ref7.wrapLines, _ref7$wrapLongLines = _ref7.wrapLongLines, wrapLongLines = _ref7$wrapLongLines === void 0 ? false : _ref7$wrapLongLines, _ref7$lineProps = _ref7.lineProps, lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps, renderer = _ref7.renderer, _ref7$PreTag = _ref7.PreTag, PreTag = _ref7$PreTag === void 0 ? "pre" : _ref7$PreTag, _ref7$CodeTag = _ref7.CodeTag, CodeTag = _ref7$CodeTag === void 0 ? "code" : _ref7$CodeTag, _ref7$code = _ref7.code, code = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || "" : _ref7$code, astGenerator = _ref7.astGenerator, rest = (0, import_objectWithoutProperties.default)(_ref7, _excluded);
    astGenerator = astGenerator || defaultAstGenerator;
    var allLineNumbers = showLineNumbers ? /* @__PURE__ */ import_react3.default.createElement(AllLineNumbers, {
      containerStyle: lineNumberContainerStyle,
      codeStyle: codeTagProps.style || {},
      numberStyle: lineNumberStyle,
      startingLineNumber,
      codeString: code
    }) : null;
    var defaultPreStyle = style.hljs || style['pre[class*="language-"]'] || {
      backgroundColor: "#fff"
    };
    var generatorClassName = isHighlightJs(astGenerator) ? "hljs" : "prismjs";
    var preProps = useInlineStyles ? Object.assign({}, rest, {
      style: Object.assign({}, defaultPreStyle, customStyle)
    }) : Object.assign({}, rest, {
      className: rest.className ? "".concat(generatorClassName, " ").concat(rest.className) : generatorClassName,
      style: Object.assign({}, customStyle)
    });
    if (wrapLongLines) {
      codeTagProps.style = _objectSpread2(_objectSpread2({}, codeTagProps.style), {}, {
        whiteSpace: "pre-wrap"
      });
    } else {
      codeTagProps.style = _objectSpread2(_objectSpread2({}, codeTagProps.style), {}, {
        whiteSpace: "pre"
      });
    }
    if (!astGenerator) {
      return /* @__PURE__ */ import_react3.default.createElement(PreTag, preProps, allLineNumbers, /* @__PURE__ */ import_react3.default.createElement(CodeTag, codeTagProps, code));
    }
    if (wrapLines === void 0 && renderer || wrapLongLines)
      wrapLines = true;
    renderer = renderer || defaultRenderer;
    var defaultCodeValue = [{
      type: "text",
      value: code
    }];
    var codeTree = getCodeTree({
      astGenerator,
      language,
      code,
      defaultCodeValue
    });
    if (codeTree.language === null) {
      codeTree.value = defaultCodeValue;
    }
    var largestLineNumber = codeTree.value.length + startingLineNumber;
    var rows = processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
    return /* @__PURE__ */ import_react3.default.createElement(PreTag, preProps, /* @__PURE__ */ import_react3.default.createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({
      rows,
      stylesheet: style,
      useInlineStyles
    })));
  };
}
var import_objectWithoutProperties, import_toConsumableArray, import_defineProperty2, import_react3, _excluded, newLineRegex;
var init_highlight = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/highlight.js"() {
    import_objectWithoutProperties = __toESM(require_objectWithoutProperties());
    import_toConsumableArray = __toESM(require_toConsumableArray());
    import_defineProperty2 = __toESM(require_defineProperty());
    import_react3 = __toESM(require("react"));
    init_create_element();
    init_checkForListedLanguage();
    _excluded = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
    newLineRegex = /\n/g;
  }
});

// ../../node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "../../node_modules/xtend/immutable.js"(exports, module2) {
    module2.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// ../../node_modules/property-information/lib/util/schema.js
var require_schema = __commonJS({
  "../../node_modules/property-information/lib/util/schema.js"(exports, module2) {
    "use strict";
    module2.exports = Schema;
    var proto = Schema.prototype;
    proto.space = null;
    proto.normal = {};
    proto.property = {};
    function Schema(property, normal, space) {
      this.property = property;
      this.normal = normal;
      if (space) {
        this.space = space;
      }
    }
  }
});

// ../../node_modules/property-information/lib/util/merge.js
var require_merge = __commonJS({
  "../../node_modules/property-information/lib/util/merge.js"(exports, module2) {
    "use strict";
    var xtend = require_immutable();
    var Schema = require_schema();
    module2.exports = merge;
    function merge(definitions) {
      var length2 = definitions.length;
      var property = [];
      var normal = [];
      var index = -1;
      var info;
      var space;
      while (++index < length2) {
        info = definitions[index];
        property.push(info.property);
        normal.push(info.normal);
        space = info.space;
      }
      return new Schema(
        xtend.apply(null, property),
        xtend.apply(null, normal),
        space
      );
    }
  }
});

// ../../node_modules/property-information/normalize.js
var require_normalize = __commonJS({
  "../../node_modules/property-information/normalize.js"(exports, module2) {
    "use strict";
    module2.exports = normalize;
    function normalize(value) {
      return value.toLowerCase();
    }
  }
});

// ../../node_modules/property-information/lib/util/info.js
var require_info = __commonJS({
  "../../node_modules/property-information/lib/util/info.js"(exports, module2) {
    "use strict";
    module2.exports = Info;
    var proto = Info.prototype;
    proto.space = null;
    proto.attribute = null;
    proto.property = null;
    proto.boolean = false;
    proto.booleanish = false;
    proto.overloadedBoolean = false;
    proto.number = false;
    proto.commaSeparated = false;
    proto.spaceSeparated = false;
    proto.commaOrSpaceSeparated = false;
    proto.mustUseProperty = false;
    proto.defined = false;
    function Info(property, attribute) {
      this.property = property;
      this.attribute = attribute;
    }
  }
});

// ../../node_modules/property-information/lib/util/types.js
var require_types = __commonJS({
  "../../node_modules/property-information/lib/util/types.js"(exports) {
    "use strict";
    var powers = 0;
    exports.boolean = increment();
    exports.booleanish = increment();
    exports.overloadedBoolean = increment();
    exports.number = increment();
    exports.spaceSeparated = increment();
    exports.commaSeparated = increment();
    exports.commaOrSpaceSeparated = increment();
    function increment() {
      return Math.pow(2, ++powers);
    }
  }
});

// ../../node_modules/property-information/lib/util/defined-info.js
var require_defined_info = __commonJS({
  "../../node_modules/property-information/lib/util/defined-info.js"(exports, module2) {
    "use strict";
    var Info = require_info();
    var types = require_types();
    module2.exports = DefinedInfo;
    DefinedInfo.prototype = new Info();
    DefinedInfo.prototype.defined = true;
    var checks = [
      "boolean",
      "booleanish",
      "overloadedBoolean",
      "number",
      "commaSeparated",
      "spaceSeparated",
      "commaOrSpaceSeparated"
    ];
    var checksLength = checks.length;
    function DefinedInfo(property, attribute, mask, space) {
      var index = -1;
      var check;
      mark(this, "space", space);
      Info.call(this, property, attribute);
      while (++index < checksLength) {
        check = checks[index];
        mark(this, check, (mask & types[check]) === types[check]);
      }
    }
    function mark(values, key, value) {
      if (value) {
        values[key] = value;
      }
    }
  }
});

// ../../node_modules/property-information/lib/util/create.js
var require_create = __commonJS({
  "../../node_modules/property-information/lib/util/create.js"(exports, module2) {
    "use strict";
    var normalize = require_normalize();
    var Schema = require_schema();
    var DefinedInfo = require_defined_info();
    module2.exports = create;
    function create(definition) {
      var space = definition.space;
      var mustUseProperty = definition.mustUseProperty || [];
      var attributes = definition.attributes || {};
      var props = definition.properties;
      var transform = definition.transform;
      var property = {};
      var normal = {};
      var prop;
      var info;
      for (prop in props) {
        info = new DefinedInfo(
          prop,
          transform(attributes, prop),
          props[prop],
          space
        );
        if (mustUseProperty.indexOf(prop) !== -1) {
          info.mustUseProperty = true;
        }
        property[prop] = info;
        normal[normalize(prop)] = prop;
        normal[normalize(info.attribute)] = prop;
      }
      return new Schema(property, normal, space);
    }
  }
});

// ../../node_modules/property-information/lib/xlink.js
var require_xlink = __commonJS({
  "../../node_modules/property-information/lib/xlink.js"(exports, module2) {
    "use strict";
    var create = require_create();
    module2.exports = create({
      space: "xlink",
      transform: xlinkTransform,
      properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
      }
    });
    function xlinkTransform(_, prop) {
      return "xlink:" + prop.slice(5).toLowerCase();
    }
  }
});

// ../../node_modules/property-information/lib/xml.js
var require_xml = __commonJS({
  "../../node_modules/property-information/lib/xml.js"(exports, module2) {
    "use strict";
    var create = require_create();
    module2.exports = create({
      space: "xml",
      transform: xmlTransform,
      properties: {
        xmlLang: null,
        xmlBase: null,
        xmlSpace: null
      }
    });
    function xmlTransform(_, prop) {
      return "xml:" + prop.slice(3).toLowerCase();
    }
  }
});

// ../../node_modules/property-information/lib/util/case-sensitive-transform.js
var require_case_sensitive_transform = __commonJS({
  "../../node_modules/property-information/lib/util/case-sensitive-transform.js"(exports, module2) {
    "use strict";
    module2.exports = caseSensitiveTransform;
    function caseSensitiveTransform(attributes, attribute) {
      return attribute in attributes ? attributes[attribute] : attribute;
    }
  }
});

// ../../node_modules/property-information/lib/util/case-insensitive-transform.js
var require_case_insensitive_transform = __commonJS({
  "../../node_modules/property-information/lib/util/case-insensitive-transform.js"(exports, module2) {
    "use strict";
    var caseSensitiveTransform = require_case_sensitive_transform();
    module2.exports = caseInsensitiveTransform;
    function caseInsensitiveTransform(attributes, property) {
      return caseSensitiveTransform(attributes, property.toLowerCase());
    }
  }
});

// ../../node_modules/property-information/lib/xmlns.js
var require_xmlns = __commonJS({
  "../../node_modules/property-information/lib/xmlns.js"(exports, module2) {
    "use strict";
    var create = require_create();
    var caseInsensitiveTransform = require_case_insensitive_transform();
    module2.exports = create({
      space: "xmlns",
      attributes: {
        xmlnsxlink: "xmlns:xlink"
      },
      transform: caseInsensitiveTransform,
      properties: {
        xmlns: null,
        xmlnsXLink: null
      }
    });
  }
});

// ../../node_modules/property-information/lib/aria.js
var require_aria = __commonJS({
  "../../node_modules/property-information/lib/aria.js"(exports, module2) {
    "use strict";
    var types = require_types();
    var create = require_create();
    var booleanish = types.booleanish;
    var number = types.number;
    var spaceSeparated = types.spaceSeparated;
    module2.exports = create({
      transform: ariaTransform,
      properties: {
        ariaActiveDescendant: null,
        ariaAtomic: booleanish,
        ariaAutoComplete: null,
        ariaBusy: booleanish,
        ariaChecked: booleanish,
        ariaColCount: number,
        ariaColIndex: number,
        ariaColSpan: number,
        ariaControls: spaceSeparated,
        ariaCurrent: null,
        ariaDescribedBy: spaceSeparated,
        ariaDetails: null,
        ariaDisabled: booleanish,
        ariaDropEffect: spaceSeparated,
        ariaErrorMessage: null,
        ariaExpanded: booleanish,
        ariaFlowTo: spaceSeparated,
        ariaGrabbed: booleanish,
        ariaHasPopup: null,
        ariaHidden: booleanish,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: spaceSeparated,
        ariaLevel: number,
        ariaLive: null,
        ariaModal: booleanish,
        ariaMultiLine: booleanish,
        ariaMultiSelectable: booleanish,
        ariaOrientation: null,
        ariaOwns: spaceSeparated,
        ariaPlaceholder: null,
        ariaPosInSet: number,
        ariaPressed: booleanish,
        ariaReadOnly: booleanish,
        ariaRelevant: null,
        ariaRequired: booleanish,
        ariaRoleDescription: spaceSeparated,
        ariaRowCount: number,
        ariaRowIndex: number,
        ariaRowSpan: number,
        ariaSelected: booleanish,
        ariaSetSize: number,
        ariaSort: null,
        ariaValueMax: number,
        ariaValueMin: number,
        ariaValueNow: number,
        ariaValueText: null,
        role: null
      }
    });
    function ariaTransform(_, prop) {
      return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
    }
  }
});

// ../../node_modules/property-information/lib/html.js
var require_html = __commonJS({
  "../../node_modules/property-information/lib/html.js"(exports, module2) {
    "use strict";
    var types = require_types();
    var create = require_create();
    var caseInsensitiveTransform = require_case_insensitive_transform();
    var boolean = types.boolean;
    var overloadedBoolean = types.overloadedBoolean;
    var booleanish = types.booleanish;
    var number = types.number;
    var spaceSeparated = types.spaceSeparated;
    var commaSeparated = types.commaSeparated;
    module2.exports = create({
      space: "html",
      attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
      },
      transform: caseInsensitiveTransform,
      mustUseProperty: ["checked", "multiple", "muted", "selected"],
      properties: {
        abbr: null,
        accept: commaSeparated,
        acceptCharset: spaceSeparated,
        accessKey: spaceSeparated,
        action: null,
        allow: null,
        allowFullScreen: boolean,
        allowPaymentRequest: boolean,
        allowUserMedia: boolean,
        alt: null,
        as: null,
        async: boolean,
        autoCapitalize: null,
        autoComplete: spaceSeparated,
        autoFocus: boolean,
        autoPlay: boolean,
        capture: boolean,
        charSet: null,
        checked: boolean,
        cite: null,
        className: spaceSeparated,
        cols: number,
        colSpan: null,
        content: null,
        contentEditable: booleanish,
        controls: boolean,
        controlsList: spaceSeparated,
        coords: number | commaSeparated,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: boolean,
        defer: boolean,
        dir: null,
        dirName: null,
        disabled: boolean,
        download: overloadedBoolean,
        draggable: booleanish,
        encType: null,
        enterKeyHint: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: boolean,
        formTarget: null,
        headers: spaceSeparated,
        height: number,
        hidden: boolean,
        high: number,
        href: null,
        hrefLang: null,
        htmlFor: spaceSeparated,
        httpEquiv: spaceSeparated,
        id: null,
        imageSizes: null,
        imageSrcSet: commaSeparated,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: boolean,
        itemId: null,
        itemProp: spaceSeparated,
        itemRef: spaceSeparated,
        itemScope: boolean,
        itemType: spaceSeparated,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: boolean,
        low: number,
        manifest: null,
        max: null,
        maxLength: number,
        media: null,
        method: null,
        min: null,
        minLength: number,
        multiple: boolean,
        muted: boolean,
        name: null,
        nonce: null,
        noModule: boolean,
        noValidate: boolean,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforePrint: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextMenu: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: boolean,
        optimum: number,
        pattern: null,
        ping: spaceSeparated,
        placeholder: null,
        playsInline: boolean,
        poster: null,
        preload: null,
        readOnly: boolean,
        referrerPolicy: null,
        rel: spaceSeparated,
        required: boolean,
        reversed: boolean,
        rows: number,
        rowSpan: number,
        sandbox: spaceSeparated,
        scope: null,
        scoped: boolean,
        seamless: boolean,
        selected: boolean,
        shape: null,
        size: number,
        sizes: null,
        slot: null,
        span: number,
        spellCheck: booleanish,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: commaSeparated,
        start: number,
        step: null,
        style: null,
        tabIndex: number,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: boolean,
        useMap: null,
        value: booleanish,
        width: number,
        wrap: null,
        align: null,
        aLink: null,
        archive: spaceSeparated,
        axis: null,
        background: null,
        bgColor: null,
        border: number,
        borderColor: null,
        bottomMargin: number,
        cellPadding: null,
        cellSpacing: null,
        char: null,
        charOff: null,
        classId: null,
        clear: null,
        code: null,
        codeBase: null,
        codeType: null,
        color: null,
        compact: boolean,
        declare: boolean,
        event: null,
        face: null,
        frame: null,
        frameBorder: null,
        hSpace: number,
        leftMargin: number,
        link: null,
        longDesc: null,
        lowSrc: null,
        marginHeight: number,
        marginWidth: number,
        noResize: boolean,
        noHref: boolean,
        noShade: boolean,
        noWrap: boolean,
        object: null,
        profile: null,
        prompt: null,
        rev: null,
        rightMargin: number,
        rules: null,
        scheme: null,
        scrolling: booleanish,
        standby: null,
        summary: null,
        text: null,
        topMargin: number,
        valueType: null,
        version: null,
        vAlign: null,
        vLink: null,
        vSpace: number,
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: boolean,
        disableRemotePlayback: boolean,
        prefix: null,
        property: null,
        results: number,
        security: null,
        unselectable: null
      }
    });
  }
});

// ../../node_modules/property-information/html.js
var require_html2 = __commonJS({
  "../../node_modules/property-information/html.js"(exports, module2) {
    "use strict";
    var merge = require_merge();
    var xlink = require_xlink();
    var xml = require_xml();
    var xmlns = require_xmlns();
    var aria = require_aria();
    var html = require_html();
    module2.exports = merge([xml, xlink, xmlns, aria, html]);
  }
});

// ../../node_modules/property-information/find.js
var require_find = __commonJS({
  "../../node_modules/property-information/find.js"(exports, module2) {
    "use strict";
    var normalize = require_normalize();
    var DefinedInfo = require_defined_info();
    var Info = require_info();
    var data = "data";
    module2.exports = find;
    var valid = /^data[-\w.:]+$/i;
    var dash = /-[a-z]/g;
    var cap = /[A-Z]/g;
    function find(schema, value) {
      var normal = normalize(value);
      var prop = value;
      var Type = Info;
      if (normal in schema.normal) {
        return schema.property[schema.normal[normal]];
      }
      if (normal.length > 4 && normal.slice(0, 4) === data && valid.test(value)) {
        if (value.charAt(4) === "-") {
          prop = datasetToProperty(value);
        } else {
          value = datasetToAttribute(value);
        }
        Type = DefinedInfo;
      }
      return new Type(prop, value);
    }
    function datasetToProperty(attribute) {
      var value = attribute.slice(5).replace(dash, camelcase);
      return data + value.charAt(0).toUpperCase() + value.slice(1);
    }
    function datasetToAttribute(property) {
      var value = property.slice(4);
      if (dash.test(value)) {
        return property;
      }
      value = value.replace(cap, kebab);
      if (value.charAt(0) !== "-") {
        value = "-" + value;
      }
      return data + value;
    }
    function kebab($0) {
      return "-" + $0.toLowerCase();
    }
    function camelcase($0) {
      return $0.charAt(1).toUpperCase();
    }
  }
});

// ../../node_modules/hast-util-parse-selector/index.js
var require_hast_util_parse_selector = __commonJS({
  "../../node_modules/hast-util-parse-selector/index.js"(exports, module2) {
    "use strict";
    module2.exports = parse;
    var search = /[#.]/g;
    function parse(selector, defaultTagName) {
      var value = selector || "";
      var name = defaultTagName || "div";
      var props = {};
      var start = 0;
      var subvalue;
      var previous;
      var match;
      while (start < value.length) {
        search.lastIndex = start;
        match = search.exec(value);
        subvalue = value.slice(start, match ? match.index : value.length);
        if (subvalue) {
          if (!previous) {
            name = subvalue;
          } else if (previous === "#") {
            props.id = subvalue;
          } else if (props.className) {
            props.className.push(subvalue);
          } else {
            props.className = [subvalue];
          }
          start += subvalue.length;
        }
        if (match) {
          previous = match[0];
          start++;
        }
      }
      return { type: "element", tagName: name, properties: props, children: [] };
    }
  }
});

// ../../node_modules/space-separated-tokens/index.js
var require_space_separated_tokens = __commonJS({
  "../../node_modules/space-separated-tokens/index.js"(exports) {
    "use strict";
    exports.parse = parse;
    exports.stringify = stringify;
    var empty = "";
    var space = " ";
    var whiteSpace = /[ \t\n\r\f]+/g;
    function parse(value) {
      var input = String(value || empty).trim();
      return input === empty ? [] : input.split(whiteSpace);
    }
    function stringify(values) {
      return values.join(space).trim();
    }
  }
});

// ../../node_modules/comma-separated-tokens/index.js
var require_comma_separated_tokens = __commonJS({
  "../../node_modules/comma-separated-tokens/index.js"(exports) {
    "use strict";
    exports.parse = parse;
    exports.stringify = stringify;
    var comma = ",";
    var space = " ";
    var empty = "";
    function parse(value) {
      var values = [];
      var input = String(value || empty);
      var index = input.indexOf(comma);
      var lastIndex = 0;
      var end = false;
      var val;
      while (!end) {
        if (index === -1) {
          index = input.length;
          end = true;
        }
        val = input.slice(lastIndex, index).trim();
        if (val || !end) {
          values.push(val);
        }
        lastIndex = index + 1;
        index = input.indexOf(comma, lastIndex);
      }
      return values;
    }
    function stringify(values, options) {
      var settings = options || {};
      var left = settings.padLeft === false ? empty : space;
      var right = settings.padRight ? space : empty;
      if (values[values.length - 1] === empty) {
        values = values.concat(empty);
      }
      return values.join(right + comma + left).trim();
    }
  }
});

// ../../node_modules/hastscript/factory.js
var require_factory = __commonJS({
  "../../node_modules/hastscript/factory.js"(exports, module2) {
    "use strict";
    var find = require_find();
    var normalize = require_normalize();
    var parseSelector = require_hast_util_parse_selector();
    var spaces = require_space_separated_tokens().parse;
    var commas = require_comma_separated_tokens().parse;
    module2.exports = factory;
    var own = {}.hasOwnProperty;
    function factory(schema, defaultTagName, caseSensitive) {
      var adjust = caseSensitive ? createAdjustMap(caseSensitive) : null;
      return h;
      function h(selector, properties) {
        var node = parseSelector(selector, defaultTagName);
        var children = Array.prototype.slice.call(arguments, 2);
        var name = node.tagName.toLowerCase();
        var property;
        node.tagName = adjust && own.call(adjust, name) ? adjust[name] : name;
        if (properties && isChildren(properties, node)) {
          children.unshift(properties);
          properties = null;
        }
        if (properties) {
          for (property in properties) {
            addProperty(node.properties, property, properties[property]);
          }
        }
        addChild(node.children, children);
        if (node.tagName === "template") {
          node.content = { type: "root", children: node.children };
          node.children = [];
        }
        return node;
      }
      function addProperty(properties, key, value) {
        var info;
        var property;
        var result;
        if (value === null || value === void 0 || value !== value) {
          return;
        }
        info = find(schema, key);
        property = info.property;
        result = value;
        if (typeof result === "string") {
          if (info.spaceSeparated) {
            result = spaces(result);
          } else if (info.commaSeparated) {
            result = commas(result);
          } else if (info.commaOrSpaceSeparated) {
            result = spaces(commas(result).join(" "));
          }
        }
        if (property === "style" && typeof value !== "string") {
          result = style(result);
        }
        if (property === "className" && properties.className) {
          result = properties.className.concat(result);
        }
        properties[property] = parsePrimitives(info, property, result);
      }
    }
    function isChildren(value, node) {
      return typeof value === "string" || "length" in value || isNode(node.tagName, value);
    }
    function isNode(tagName, value) {
      var type = value.type;
      if (tagName === "input" || !type || typeof type !== "string") {
        return false;
      }
      if (typeof value.children === "object" && "length" in value.children) {
        return true;
      }
      type = type.toLowerCase();
      if (tagName === "button") {
        return type !== "menu" && type !== "submit" && type !== "reset" && type !== "button";
      }
      return "value" in value;
    }
    function addChild(nodes, value) {
      var index;
      var length2;
      if (typeof value === "string" || typeof value === "number") {
        nodes.push({ type: "text", value: String(value) });
        return;
      }
      if (typeof value === "object" && "length" in value) {
        index = -1;
        length2 = value.length;
        while (++index < length2) {
          addChild(nodes, value[index]);
        }
        return;
      }
      if (typeof value !== "object" || !("type" in value)) {
        throw new Error("Expected node, nodes, or string, got `" + value + "`");
      }
      nodes.push(value);
    }
    function parsePrimitives(info, name, value) {
      var index;
      var length2;
      var result;
      if (typeof value !== "object" || !("length" in value)) {
        return parsePrimitive(info, name, value);
      }
      length2 = value.length;
      index = -1;
      result = [];
      while (++index < length2) {
        result[index] = parsePrimitive(info, name, value[index]);
      }
      return result;
    }
    function parsePrimitive(info, name, value) {
      var result = value;
      if (info.number || info.positiveNumber) {
        if (!isNaN(result) && result !== "") {
          result = Number(result);
        }
      } else if (info.boolean || info.overloadedBoolean) {
        if (typeof result === "string" && (result === "" || normalize(value) === normalize(name))) {
          result = true;
        }
      }
      return result;
    }
    function style(value) {
      var result = [];
      var key;
      for (key in value) {
        result.push([key, value[key]].join(": "));
      }
      return result.join("; ");
    }
    function createAdjustMap(values) {
      var length2 = values.length;
      var index = -1;
      var result = {};
      var value;
      while (++index < length2) {
        value = values[index];
        result[value.toLowerCase()] = value;
      }
      return result;
    }
  }
});

// ../../node_modules/hastscript/html.js
var require_html3 = __commonJS({
  "../../node_modules/hastscript/html.js"(exports, module2) {
    "use strict";
    var schema = require_html2();
    var factory = require_factory();
    var html = factory(schema, "div");
    html.displayName = "html";
    module2.exports = html;
  }
});

// ../../node_modules/hastscript/index.js
var require_hastscript = __commonJS({
  "../../node_modules/hastscript/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_html3();
  }
});

// ../../node_modules/character-entities-legacy/index.json
var require_character_entities_legacy = __commonJS({
  "../../node_modules/character-entities-legacy/index.json"(exports, module2) {
    module2.exports = {
      AElig: "\xC6",
      AMP: "&",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Agrave: "\xC0",
      Aring: "\xC5",
      Atilde: "\xC3",
      Auml: "\xC4",
      COPY: "\xA9",
      Ccedil: "\xC7",
      ETH: "\xD0",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Egrave: "\xC8",
      Euml: "\xCB",
      GT: ">",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Igrave: "\xCC",
      Iuml: "\xCF",
      LT: "<",
      Ntilde: "\xD1",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Ograve: "\xD2",
      Oslash: "\xD8",
      Otilde: "\xD5",
      Ouml: "\xD6",
      QUOT: '"',
      REG: "\xAE",
      THORN: "\xDE",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Ugrave: "\xD9",
      Uuml: "\xDC",
      Yacute: "\xDD",
      aacute: "\xE1",
      acirc: "\xE2",
      acute: "\xB4",
      aelig: "\xE6",
      agrave: "\xE0",
      amp: "&",
      aring: "\xE5",
      atilde: "\xE3",
      auml: "\xE4",
      brvbar: "\xA6",
      ccedil: "\xE7",
      cedil: "\xB8",
      cent: "\xA2",
      copy: "\xA9",
      curren: "\xA4",
      deg: "\xB0",
      divide: "\xF7",
      eacute: "\xE9",
      ecirc: "\xEA",
      egrave: "\xE8",
      eth: "\xF0",
      euml: "\xEB",
      frac12: "\xBD",
      frac14: "\xBC",
      frac34: "\xBE",
      gt: ">",
      iacute: "\xED",
      icirc: "\xEE",
      iexcl: "\xA1",
      igrave: "\xEC",
      iquest: "\xBF",
      iuml: "\xEF",
      laquo: "\xAB",
      lt: "<",
      macr: "\xAF",
      micro: "\xB5",
      middot: "\xB7",
      nbsp: "\xA0",
      not: "\xAC",
      ntilde: "\xF1",
      oacute: "\xF3",
      ocirc: "\xF4",
      ograve: "\xF2",
      ordf: "\xAA",
      ordm: "\xBA",
      oslash: "\xF8",
      otilde: "\xF5",
      ouml: "\xF6",
      para: "\xB6",
      plusmn: "\xB1",
      pound: "\xA3",
      quot: '"',
      raquo: "\xBB",
      reg: "\xAE",
      sect: "\xA7",
      shy: "\xAD",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      szlig: "\xDF",
      thorn: "\xFE",
      times: "\xD7",
      uacute: "\xFA",
      ucirc: "\xFB",
      ugrave: "\xF9",
      uml: "\xA8",
      uuml: "\xFC",
      yacute: "\xFD",
      yen: "\xA5",
      yuml: "\xFF"
    };
  }
});

// ../../node_modules/character-reference-invalid/index.json
var require_character_reference_invalid = __commonJS({
  "../../node_modules/character-reference-invalid/index.json"(exports, module2) {
    module2.exports = {
      "0": "\uFFFD",
      "128": "\u20AC",
      "130": "\u201A",
      "131": "\u0192",
      "132": "\u201E",
      "133": "\u2026",
      "134": "\u2020",
      "135": "\u2021",
      "136": "\u02C6",
      "137": "\u2030",
      "138": "\u0160",
      "139": "\u2039",
      "140": "\u0152",
      "142": "\u017D",
      "145": "\u2018",
      "146": "\u2019",
      "147": "\u201C",
      "148": "\u201D",
      "149": "\u2022",
      "150": "\u2013",
      "151": "\u2014",
      "152": "\u02DC",
      "153": "\u2122",
      "154": "\u0161",
      "155": "\u203A",
      "156": "\u0153",
      "158": "\u017E",
      "159": "\u0178"
    };
  }
});

// ../../node_modules/is-decimal/index.js
var require_is_decimal = __commonJS({
  "../../node_modules/is-decimal/index.js"(exports, module2) {
    "use strict";
    module2.exports = decimal;
    function decimal(character) {
      var code = typeof character === "string" ? character.charCodeAt(0) : character;
      return code >= 48 && code <= 57;
    }
  }
});

// ../../node_modules/is-hexadecimal/index.js
var require_is_hexadecimal = __commonJS({
  "../../node_modules/is-hexadecimal/index.js"(exports, module2) {
    "use strict";
    module2.exports = hexadecimal;
    function hexadecimal(character) {
      var code = typeof character === "string" ? character.charCodeAt(0) : character;
      return code >= 97 && code <= 102 || code >= 65 && code <= 70 || code >= 48 && code <= 57;
    }
  }
});

// ../../node_modules/is-alphabetical/index.js
var require_is_alphabetical = __commonJS({
  "../../node_modules/is-alphabetical/index.js"(exports, module2) {
    "use strict";
    module2.exports = alphabetical;
    function alphabetical(character) {
      var code = typeof character === "string" ? character.charCodeAt(0) : character;
      return code >= 97 && code <= 122 || code >= 65 && code <= 90;
    }
  }
});

// ../../node_modules/is-alphanumerical/index.js
var require_is_alphanumerical = __commonJS({
  "../../node_modules/is-alphanumerical/index.js"(exports, module2) {
    "use strict";
    var alphabetical = require_is_alphabetical();
    var decimal = require_is_decimal();
    module2.exports = alphanumerical;
    function alphanumerical(character) {
      return alphabetical(character) || decimal(character);
    }
  }
});

// ../../node_modules/parse-entities/node_modules/character-entities/index.json
var require_character_entities = __commonJS({
  "../../node_modules/parse-entities/node_modules/character-entities/index.json"(exports, module2) {
    module2.exports = {
      AEli: "\xC6",
      AElig: "\xC6",
      AM: "&",
      AMP: "&",
      Aacut: "\xC1",
      Aacute: "\xC1",
      Abreve: "\u0102",
      Acir: "\xC2",
      Acirc: "\xC2",
      Acy: "\u0410",
      Afr: "\u{1D504}",
      Agrav: "\xC0",
      Agrave: "\xC0",
      Alpha: "\u0391",
      Amacr: "\u0100",
      And: "\u2A53",
      Aogon: "\u0104",
      Aopf: "\u{1D538}",
      ApplyFunction: "\u2061",
      Arin: "\xC5",
      Aring: "\xC5",
      Ascr: "\u{1D49C}",
      Assign: "\u2254",
      Atild: "\xC3",
      Atilde: "\xC3",
      Aum: "\xC4",
      Auml: "\xC4",
      Backslash: "\u2216",
      Barv: "\u2AE7",
      Barwed: "\u2306",
      Bcy: "\u0411",
      Because: "\u2235",
      Bernoullis: "\u212C",
      Beta: "\u0392",
      Bfr: "\u{1D505}",
      Bopf: "\u{1D539}",
      Breve: "\u02D8",
      Bscr: "\u212C",
      Bumpeq: "\u224E",
      CHcy: "\u0427",
      COP: "\xA9",
      COPY: "\xA9",
      Cacute: "\u0106",
      Cap: "\u22D2",
      CapitalDifferentialD: "\u2145",
      Cayleys: "\u212D",
      Ccaron: "\u010C",
      Ccedi: "\xC7",
      Ccedil: "\xC7",
      Ccirc: "\u0108",
      Cconint: "\u2230",
      Cdot: "\u010A",
      Cedilla: "\xB8",
      CenterDot: "\xB7",
      Cfr: "\u212D",
      Chi: "\u03A7",
      CircleDot: "\u2299",
      CircleMinus: "\u2296",
      CirclePlus: "\u2295",
      CircleTimes: "\u2297",
      ClockwiseContourIntegral: "\u2232",
      CloseCurlyDoubleQuote: "\u201D",
      CloseCurlyQuote: "\u2019",
      Colon: "\u2237",
      Colone: "\u2A74",
      Congruent: "\u2261",
      Conint: "\u222F",
      ContourIntegral: "\u222E",
      Copf: "\u2102",
      Coproduct: "\u2210",
      CounterClockwiseContourIntegral: "\u2233",
      Cross: "\u2A2F",
      Cscr: "\u{1D49E}",
      Cup: "\u22D3",
      CupCap: "\u224D",
      DD: "\u2145",
      DDotrahd: "\u2911",
      DJcy: "\u0402",
      DScy: "\u0405",
      DZcy: "\u040F",
      Dagger: "\u2021",
      Darr: "\u21A1",
      Dashv: "\u2AE4",
      Dcaron: "\u010E",
      Dcy: "\u0414",
      Del: "\u2207",
      Delta: "\u0394",
      Dfr: "\u{1D507}",
      DiacriticalAcute: "\xB4",
      DiacriticalDot: "\u02D9",
      DiacriticalDoubleAcute: "\u02DD",
      DiacriticalGrave: "`",
      DiacriticalTilde: "\u02DC",
      Diamond: "\u22C4",
      DifferentialD: "\u2146",
      Dopf: "\u{1D53B}",
      Dot: "\xA8",
      DotDot: "\u20DC",
      DotEqual: "\u2250",
      DoubleContourIntegral: "\u222F",
      DoubleDot: "\xA8",
      DoubleDownArrow: "\u21D3",
      DoubleLeftArrow: "\u21D0",
      DoubleLeftRightArrow: "\u21D4",
      DoubleLeftTee: "\u2AE4",
      DoubleLongLeftArrow: "\u27F8",
      DoubleLongLeftRightArrow: "\u27FA",
      DoubleLongRightArrow: "\u27F9",
      DoubleRightArrow: "\u21D2",
      DoubleRightTee: "\u22A8",
      DoubleUpArrow: "\u21D1",
      DoubleUpDownArrow: "\u21D5",
      DoubleVerticalBar: "\u2225",
      DownArrow: "\u2193",
      DownArrowBar: "\u2913",
      DownArrowUpArrow: "\u21F5",
      DownBreve: "\u0311",
      DownLeftRightVector: "\u2950",
      DownLeftTeeVector: "\u295E",
      DownLeftVector: "\u21BD",
      DownLeftVectorBar: "\u2956",
      DownRightTeeVector: "\u295F",
      DownRightVector: "\u21C1",
      DownRightVectorBar: "\u2957",
      DownTee: "\u22A4",
      DownTeeArrow: "\u21A7",
      Downarrow: "\u21D3",
      Dscr: "\u{1D49F}",
      Dstrok: "\u0110",
      ENG: "\u014A",
      ET: "\xD0",
      ETH: "\xD0",
      Eacut: "\xC9",
      Eacute: "\xC9",
      Ecaron: "\u011A",
      Ecir: "\xCA",
      Ecirc: "\xCA",
      Ecy: "\u042D",
      Edot: "\u0116",
      Efr: "\u{1D508}",
      Egrav: "\xC8",
      Egrave: "\xC8",
      Element: "\u2208",
      Emacr: "\u0112",
      EmptySmallSquare: "\u25FB",
      EmptyVerySmallSquare: "\u25AB",
      Eogon: "\u0118",
      Eopf: "\u{1D53C}",
      Epsilon: "\u0395",
      Equal: "\u2A75",
      EqualTilde: "\u2242",
      Equilibrium: "\u21CC",
      Escr: "\u2130",
      Esim: "\u2A73",
      Eta: "\u0397",
      Eum: "\xCB",
      Euml: "\xCB",
      Exists: "\u2203",
      ExponentialE: "\u2147",
      Fcy: "\u0424",
      Ffr: "\u{1D509}",
      FilledSmallSquare: "\u25FC",
      FilledVerySmallSquare: "\u25AA",
      Fopf: "\u{1D53D}",
      ForAll: "\u2200",
      Fouriertrf: "\u2131",
      Fscr: "\u2131",
      GJcy: "\u0403",
      G: ">",
      GT: ">",
      Gamma: "\u0393",
      Gammad: "\u03DC",
      Gbreve: "\u011E",
      Gcedil: "\u0122",
      Gcirc: "\u011C",
      Gcy: "\u0413",
      Gdot: "\u0120",
      Gfr: "\u{1D50A}",
      Gg: "\u22D9",
      Gopf: "\u{1D53E}",
      GreaterEqual: "\u2265",
      GreaterEqualLess: "\u22DB",
      GreaterFullEqual: "\u2267",
      GreaterGreater: "\u2AA2",
      GreaterLess: "\u2277",
      GreaterSlantEqual: "\u2A7E",
      GreaterTilde: "\u2273",
      Gscr: "\u{1D4A2}",
      Gt: "\u226B",
      HARDcy: "\u042A",
      Hacek: "\u02C7",
      Hat: "^",
      Hcirc: "\u0124",
      Hfr: "\u210C",
      HilbertSpace: "\u210B",
      Hopf: "\u210D",
      HorizontalLine: "\u2500",
      Hscr: "\u210B",
      Hstrok: "\u0126",
      HumpDownHump: "\u224E",
      HumpEqual: "\u224F",
      IEcy: "\u0415",
      IJlig: "\u0132",
      IOcy: "\u0401",
      Iacut: "\xCD",
      Iacute: "\xCD",
      Icir: "\xCE",
      Icirc: "\xCE",
      Icy: "\u0418",
      Idot: "\u0130",
      Ifr: "\u2111",
      Igrav: "\xCC",
      Igrave: "\xCC",
      Im: "\u2111",
      Imacr: "\u012A",
      ImaginaryI: "\u2148",
      Implies: "\u21D2",
      Int: "\u222C",
      Integral: "\u222B",
      Intersection: "\u22C2",
      InvisibleComma: "\u2063",
      InvisibleTimes: "\u2062",
      Iogon: "\u012E",
      Iopf: "\u{1D540}",
      Iota: "\u0399",
      Iscr: "\u2110",
      Itilde: "\u0128",
      Iukcy: "\u0406",
      Ium: "\xCF",
      Iuml: "\xCF",
      Jcirc: "\u0134",
      Jcy: "\u0419",
      Jfr: "\u{1D50D}",
      Jopf: "\u{1D541}",
      Jscr: "\u{1D4A5}",
      Jsercy: "\u0408",
      Jukcy: "\u0404",
      KHcy: "\u0425",
      KJcy: "\u040C",
      Kappa: "\u039A",
      Kcedil: "\u0136",
      Kcy: "\u041A",
      Kfr: "\u{1D50E}",
      Kopf: "\u{1D542}",
      Kscr: "\u{1D4A6}",
      LJcy: "\u0409",
      L: "<",
      LT: "<",
      Lacute: "\u0139",
      Lambda: "\u039B",
      Lang: "\u27EA",
      Laplacetrf: "\u2112",
      Larr: "\u219E",
      Lcaron: "\u013D",
      Lcedil: "\u013B",
      Lcy: "\u041B",
      LeftAngleBracket: "\u27E8",
      LeftArrow: "\u2190",
      LeftArrowBar: "\u21E4",
      LeftArrowRightArrow: "\u21C6",
      LeftCeiling: "\u2308",
      LeftDoubleBracket: "\u27E6",
      LeftDownTeeVector: "\u2961",
      LeftDownVector: "\u21C3",
      LeftDownVectorBar: "\u2959",
      LeftFloor: "\u230A",
      LeftRightArrow: "\u2194",
      LeftRightVector: "\u294E",
      LeftTee: "\u22A3",
      LeftTeeArrow: "\u21A4",
      LeftTeeVector: "\u295A",
      LeftTriangle: "\u22B2",
      LeftTriangleBar: "\u29CF",
      LeftTriangleEqual: "\u22B4",
      LeftUpDownVector: "\u2951",
      LeftUpTeeVector: "\u2960",
      LeftUpVector: "\u21BF",
      LeftUpVectorBar: "\u2958",
      LeftVector: "\u21BC",
      LeftVectorBar: "\u2952",
      Leftarrow: "\u21D0",
      Leftrightarrow: "\u21D4",
      LessEqualGreater: "\u22DA",
      LessFullEqual: "\u2266",
      LessGreater: "\u2276",
      LessLess: "\u2AA1",
      LessSlantEqual: "\u2A7D",
      LessTilde: "\u2272",
      Lfr: "\u{1D50F}",
      Ll: "\u22D8",
      Lleftarrow: "\u21DA",
      Lmidot: "\u013F",
      LongLeftArrow: "\u27F5",
      LongLeftRightArrow: "\u27F7",
      LongRightArrow: "\u27F6",
      Longleftarrow: "\u27F8",
      Longleftrightarrow: "\u27FA",
      Longrightarrow: "\u27F9",
      Lopf: "\u{1D543}",
      LowerLeftArrow: "\u2199",
      LowerRightArrow: "\u2198",
      Lscr: "\u2112",
      Lsh: "\u21B0",
      Lstrok: "\u0141",
      Lt: "\u226A",
      Map: "\u2905",
      Mcy: "\u041C",
      MediumSpace: "\u205F",
      Mellintrf: "\u2133",
      Mfr: "\u{1D510}",
      MinusPlus: "\u2213",
      Mopf: "\u{1D544}",
      Mscr: "\u2133",
      Mu: "\u039C",
      NJcy: "\u040A",
      Nacute: "\u0143",
      Ncaron: "\u0147",
      Ncedil: "\u0145",
      Ncy: "\u041D",
      NegativeMediumSpace: "\u200B",
      NegativeThickSpace: "\u200B",
      NegativeThinSpace: "\u200B",
      NegativeVeryThinSpace: "\u200B",
      NestedGreaterGreater: "\u226B",
      NestedLessLess: "\u226A",
      NewLine: "\n",
      Nfr: "\u{1D511}",
      NoBreak: "\u2060",
      NonBreakingSpace: "\xA0",
      Nopf: "\u2115",
      Not: "\u2AEC",
      NotCongruent: "\u2262",
      NotCupCap: "\u226D",
      NotDoubleVerticalBar: "\u2226",
      NotElement: "\u2209",
      NotEqual: "\u2260",
      NotEqualTilde: "\u2242\u0338",
      NotExists: "\u2204",
      NotGreater: "\u226F",
      NotGreaterEqual: "\u2271",
      NotGreaterFullEqual: "\u2267\u0338",
      NotGreaterGreater: "\u226B\u0338",
      NotGreaterLess: "\u2279",
      NotGreaterSlantEqual: "\u2A7E\u0338",
      NotGreaterTilde: "\u2275",
      NotHumpDownHump: "\u224E\u0338",
      NotHumpEqual: "\u224F\u0338",
      NotLeftTriangle: "\u22EA",
      NotLeftTriangleBar: "\u29CF\u0338",
      NotLeftTriangleEqual: "\u22EC",
      NotLess: "\u226E",
      NotLessEqual: "\u2270",
      NotLessGreater: "\u2278",
      NotLessLess: "\u226A\u0338",
      NotLessSlantEqual: "\u2A7D\u0338",
      NotLessTilde: "\u2274",
      NotNestedGreaterGreater: "\u2AA2\u0338",
      NotNestedLessLess: "\u2AA1\u0338",
      NotPrecedes: "\u2280",
      NotPrecedesEqual: "\u2AAF\u0338",
      NotPrecedesSlantEqual: "\u22E0",
      NotReverseElement: "\u220C",
      NotRightTriangle: "\u22EB",
      NotRightTriangleBar: "\u29D0\u0338",
      NotRightTriangleEqual: "\u22ED",
      NotSquareSubset: "\u228F\u0338",
      NotSquareSubsetEqual: "\u22E2",
      NotSquareSuperset: "\u2290\u0338",
      NotSquareSupersetEqual: "\u22E3",
      NotSubset: "\u2282\u20D2",
      NotSubsetEqual: "\u2288",
      NotSucceeds: "\u2281",
      NotSucceedsEqual: "\u2AB0\u0338",
      NotSucceedsSlantEqual: "\u22E1",
      NotSucceedsTilde: "\u227F\u0338",
      NotSuperset: "\u2283\u20D2",
      NotSupersetEqual: "\u2289",
      NotTilde: "\u2241",
      NotTildeEqual: "\u2244",
      NotTildeFullEqual: "\u2247",
      NotTildeTilde: "\u2249",
      NotVerticalBar: "\u2224",
      Nscr: "\u{1D4A9}",
      Ntild: "\xD1",
      Ntilde: "\xD1",
      Nu: "\u039D",
      OElig: "\u0152",
      Oacut: "\xD3",
      Oacute: "\xD3",
      Ocir: "\xD4",
      Ocirc: "\xD4",
      Ocy: "\u041E",
      Odblac: "\u0150",
      Ofr: "\u{1D512}",
      Ograv: "\xD2",
      Ograve: "\xD2",
      Omacr: "\u014C",
      Omega: "\u03A9",
      Omicron: "\u039F",
      Oopf: "\u{1D546}",
      OpenCurlyDoubleQuote: "\u201C",
      OpenCurlyQuote: "\u2018",
      Or: "\u2A54",
      Oscr: "\u{1D4AA}",
      Oslas: "\xD8",
      Oslash: "\xD8",
      Otild: "\xD5",
      Otilde: "\xD5",
      Otimes: "\u2A37",
      Oum: "\xD6",
      Ouml: "\xD6",
      OverBar: "\u203E",
      OverBrace: "\u23DE",
      OverBracket: "\u23B4",
      OverParenthesis: "\u23DC",
      PartialD: "\u2202",
      Pcy: "\u041F",
      Pfr: "\u{1D513}",
      Phi: "\u03A6",
      Pi: "\u03A0",
      PlusMinus: "\xB1",
      Poincareplane: "\u210C",
      Popf: "\u2119",
      Pr: "\u2ABB",
      Precedes: "\u227A",
      PrecedesEqual: "\u2AAF",
      PrecedesSlantEqual: "\u227C",
      PrecedesTilde: "\u227E",
      Prime: "\u2033",
      Product: "\u220F",
      Proportion: "\u2237",
      Proportional: "\u221D",
      Pscr: "\u{1D4AB}",
      Psi: "\u03A8",
      QUO: '"',
      QUOT: '"',
      Qfr: "\u{1D514}",
      Qopf: "\u211A",
      Qscr: "\u{1D4AC}",
      RBarr: "\u2910",
      RE: "\xAE",
      REG: "\xAE",
      Racute: "\u0154",
      Rang: "\u27EB",
      Rarr: "\u21A0",
      Rarrtl: "\u2916",
      Rcaron: "\u0158",
      Rcedil: "\u0156",
      Rcy: "\u0420",
      Re: "\u211C",
      ReverseElement: "\u220B",
      ReverseEquilibrium: "\u21CB",
      ReverseUpEquilibrium: "\u296F",
      Rfr: "\u211C",
      Rho: "\u03A1",
      RightAngleBracket: "\u27E9",
      RightArrow: "\u2192",
      RightArrowBar: "\u21E5",
      RightArrowLeftArrow: "\u21C4",
      RightCeiling: "\u2309",
      RightDoubleBracket: "\u27E7",
      RightDownTeeVector: "\u295D",
      RightDownVector: "\u21C2",
      RightDownVectorBar: "\u2955",
      RightFloor: "\u230B",
      RightTee: "\u22A2",
      RightTeeArrow: "\u21A6",
      RightTeeVector: "\u295B",
      RightTriangle: "\u22B3",
      RightTriangleBar: "\u29D0",
      RightTriangleEqual: "\u22B5",
      RightUpDownVector: "\u294F",
      RightUpTeeVector: "\u295C",
      RightUpVector: "\u21BE",
      RightUpVectorBar: "\u2954",
      RightVector: "\u21C0",
      RightVectorBar: "\u2953",
      Rightarrow: "\u21D2",
      Ropf: "\u211D",
      RoundImplies: "\u2970",
      Rrightarrow: "\u21DB",
      Rscr: "\u211B",
      Rsh: "\u21B1",
      RuleDelayed: "\u29F4",
      SHCHcy: "\u0429",
      SHcy: "\u0428",
      SOFTcy: "\u042C",
      Sacute: "\u015A",
      Sc: "\u2ABC",
      Scaron: "\u0160",
      Scedil: "\u015E",
      Scirc: "\u015C",
      Scy: "\u0421",
      Sfr: "\u{1D516}",
      ShortDownArrow: "\u2193",
      ShortLeftArrow: "\u2190",
      ShortRightArrow: "\u2192",
      ShortUpArrow: "\u2191",
      Sigma: "\u03A3",
      SmallCircle: "\u2218",
      Sopf: "\u{1D54A}",
      Sqrt: "\u221A",
      Square: "\u25A1",
      SquareIntersection: "\u2293",
      SquareSubset: "\u228F",
      SquareSubsetEqual: "\u2291",
      SquareSuperset: "\u2290",
      SquareSupersetEqual: "\u2292",
      SquareUnion: "\u2294",
      Sscr: "\u{1D4AE}",
      Star: "\u22C6",
      Sub: "\u22D0",
      Subset: "\u22D0",
      SubsetEqual: "\u2286",
      Succeeds: "\u227B",
      SucceedsEqual: "\u2AB0",
      SucceedsSlantEqual: "\u227D",
      SucceedsTilde: "\u227F",
      SuchThat: "\u220B",
      Sum: "\u2211",
      Sup: "\u22D1",
      Superset: "\u2283",
      SupersetEqual: "\u2287",
      Supset: "\u22D1",
      THOR: "\xDE",
      THORN: "\xDE",
      TRADE: "\u2122",
      TSHcy: "\u040B",
      TScy: "\u0426",
      Tab: "	",
      Tau: "\u03A4",
      Tcaron: "\u0164",
      Tcedil: "\u0162",
      Tcy: "\u0422",
      Tfr: "\u{1D517}",
      Therefore: "\u2234",
      Theta: "\u0398",
      ThickSpace: "\u205F\u200A",
      ThinSpace: "\u2009",
      Tilde: "\u223C",
      TildeEqual: "\u2243",
      TildeFullEqual: "\u2245",
      TildeTilde: "\u2248",
      Topf: "\u{1D54B}",
      TripleDot: "\u20DB",
      Tscr: "\u{1D4AF}",
      Tstrok: "\u0166",
      Uacut: "\xDA",
      Uacute: "\xDA",
      Uarr: "\u219F",
      Uarrocir: "\u2949",
      Ubrcy: "\u040E",
      Ubreve: "\u016C",
      Ucir: "\xDB",
      Ucirc: "\xDB",
      Ucy: "\u0423",
      Udblac: "\u0170",
      Ufr: "\u{1D518}",
      Ugrav: "\xD9",
      Ugrave: "\xD9",
      Umacr: "\u016A",
      UnderBar: "_",
      UnderBrace: "\u23DF",
      UnderBracket: "\u23B5",
      UnderParenthesis: "\u23DD",
      Union: "\u22C3",
      UnionPlus: "\u228E",
      Uogon: "\u0172",
      Uopf: "\u{1D54C}",
      UpArrow: "\u2191",
      UpArrowBar: "\u2912",
      UpArrowDownArrow: "\u21C5",
      UpDownArrow: "\u2195",
      UpEquilibrium: "\u296E",
      UpTee: "\u22A5",
      UpTeeArrow: "\u21A5",
      Uparrow: "\u21D1",
      Updownarrow: "\u21D5",
      UpperLeftArrow: "\u2196",
      UpperRightArrow: "\u2197",
      Upsi: "\u03D2",
      Upsilon: "\u03A5",
      Uring: "\u016E",
      Uscr: "\u{1D4B0}",
      Utilde: "\u0168",
      Uum: "\xDC",
      Uuml: "\xDC",
      VDash: "\u22AB",
      Vbar: "\u2AEB",
      Vcy: "\u0412",
      Vdash: "\u22A9",
      Vdashl: "\u2AE6",
      Vee: "\u22C1",
      Verbar: "\u2016",
      Vert: "\u2016",
      VerticalBar: "\u2223",
      VerticalLine: "|",
      VerticalSeparator: "\u2758",
      VerticalTilde: "\u2240",
      VeryThinSpace: "\u200A",
      Vfr: "\u{1D519}",
      Vopf: "\u{1D54D}",
      Vscr: "\u{1D4B1}",
      Vvdash: "\u22AA",
      Wcirc: "\u0174",
      Wedge: "\u22C0",
      Wfr: "\u{1D51A}",
      Wopf: "\u{1D54E}",
      Wscr: "\u{1D4B2}",
      Xfr: "\u{1D51B}",
      Xi: "\u039E",
      Xopf: "\u{1D54F}",
      Xscr: "\u{1D4B3}",
      YAcy: "\u042F",
      YIcy: "\u0407",
      YUcy: "\u042E",
      Yacut: "\xDD",
      Yacute: "\xDD",
      Ycirc: "\u0176",
      Ycy: "\u042B",
      Yfr: "\u{1D51C}",
      Yopf: "\u{1D550}",
      Yscr: "\u{1D4B4}",
      Yuml: "\u0178",
      ZHcy: "\u0416",
      Zacute: "\u0179",
      Zcaron: "\u017D",
      Zcy: "\u0417",
      Zdot: "\u017B",
      ZeroWidthSpace: "\u200B",
      Zeta: "\u0396",
      Zfr: "\u2128",
      Zopf: "\u2124",
      Zscr: "\u{1D4B5}",
      aacut: "\xE1",
      aacute: "\xE1",
      abreve: "\u0103",
      ac: "\u223E",
      acE: "\u223E\u0333",
      acd: "\u223F",
      acir: "\xE2",
      acirc: "\xE2",
      acut: "\xB4",
      acute: "\xB4",
      acy: "\u0430",
      aeli: "\xE6",
      aelig: "\xE6",
      af: "\u2061",
      afr: "\u{1D51E}",
      agrav: "\xE0",
      agrave: "\xE0",
      alefsym: "\u2135",
      aleph: "\u2135",
      alpha: "\u03B1",
      amacr: "\u0101",
      amalg: "\u2A3F",
      am: "&",
      amp: "&",
      and: "\u2227",
      andand: "\u2A55",
      andd: "\u2A5C",
      andslope: "\u2A58",
      andv: "\u2A5A",
      ang: "\u2220",
      ange: "\u29A4",
      angle: "\u2220",
      angmsd: "\u2221",
      angmsdaa: "\u29A8",
      angmsdab: "\u29A9",
      angmsdac: "\u29AA",
      angmsdad: "\u29AB",
      angmsdae: "\u29AC",
      angmsdaf: "\u29AD",
      angmsdag: "\u29AE",
      angmsdah: "\u29AF",
      angrt: "\u221F",
      angrtvb: "\u22BE",
      angrtvbd: "\u299D",
      angsph: "\u2222",
      angst: "\xC5",
      angzarr: "\u237C",
      aogon: "\u0105",
      aopf: "\u{1D552}",
      ap: "\u2248",
      apE: "\u2A70",
      apacir: "\u2A6F",
      ape: "\u224A",
      apid: "\u224B",
      apos: "'",
      approx: "\u2248",
      approxeq: "\u224A",
      arin: "\xE5",
      aring: "\xE5",
      ascr: "\u{1D4B6}",
      ast: "*",
      asymp: "\u2248",
      asympeq: "\u224D",
      atild: "\xE3",
      atilde: "\xE3",
      aum: "\xE4",
      auml: "\xE4",
      awconint: "\u2233",
      awint: "\u2A11",
      bNot: "\u2AED",
      backcong: "\u224C",
      backepsilon: "\u03F6",
      backprime: "\u2035",
      backsim: "\u223D",
      backsimeq: "\u22CD",
      barvee: "\u22BD",
      barwed: "\u2305",
      barwedge: "\u2305",
      bbrk: "\u23B5",
      bbrktbrk: "\u23B6",
      bcong: "\u224C",
      bcy: "\u0431",
      bdquo: "\u201E",
      becaus: "\u2235",
      because: "\u2235",
      bemptyv: "\u29B0",
      bepsi: "\u03F6",
      bernou: "\u212C",
      beta: "\u03B2",
      beth: "\u2136",
      between: "\u226C",
      bfr: "\u{1D51F}",
      bigcap: "\u22C2",
      bigcirc: "\u25EF",
      bigcup: "\u22C3",
      bigodot: "\u2A00",
      bigoplus: "\u2A01",
      bigotimes: "\u2A02",
      bigsqcup: "\u2A06",
      bigstar: "\u2605",
      bigtriangledown: "\u25BD",
      bigtriangleup: "\u25B3",
      biguplus: "\u2A04",
      bigvee: "\u22C1",
      bigwedge: "\u22C0",
      bkarow: "\u290D",
      blacklozenge: "\u29EB",
      blacksquare: "\u25AA",
      blacktriangle: "\u25B4",
      blacktriangledown: "\u25BE",
      blacktriangleleft: "\u25C2",
      blacktriangleright: "\u25B8",
      blank: "\u2423",
      blk12: "\u2592",
      blk14: "\u2591",
      blk34: "\u2593",
      block: "\u2588",
      bne: "=\u20E5",
      bnequiv: "\u2261\u20E5",
      bnot: "\u2310",
      bopf: "\u{1D553}",
      bot: "\u22A5",
      bottom: "\u22A5",
      bowtie: "\u22C8",
      boxDL: "\u2557",
      boxDR: "\u2554",
      boxDl: "\u2556",
      boxDr: "\u2553",
      boxH: "\u2550",
      boxHD: "\u2566",
      boxHU: "\u2569",
      boxHd: "\u2564",
      boxHu: "\u2567",
      boxUL: "\u255D",
      boxUR: "\u255A",
      boxUl: "\u255C",
      boxUr: "\u2559",
      boxV: "\u2551",
      boxVH: "\u256C",
      boxVL: "\u2563",
      boxVR: "\u2560",
      boxVh: "\u256B",
      boxVl: "\u2562",
      boxVr: "\u255F",
      boxbox: "\u29C9",
      boxdL: "\u2555",
      boxdR: "\u2552",
      boxdl: "\u2510",
      boxdr: "\u250C",
      boxh: "\u2500",
      boxhD: "\u2565",
      boxhU: "\u2568",
      boxhd: "\u252C",
      boxhu: "\u2534",
      boxminus: "\u229F",
      boxplus: "\u229E",
      boxtimes: "\u22A0",
      boxuL: "\u255B",
      boxuR: "\u2558",
      boxul: "\u2518",
      boxur: "\u2514",
      boxv: "\u2502",
      boxvH: "\u256A",
      boxvL: "\u2561",
      boxvR: "\u255E",
      boxvh: "\u253C",
      boxvl: "\u2524",
      boxvr: "\u251C",
      bprime: "\u2035",
      breve: "\u02D8",
      brvba: "\xA6",
      brvbar: "\xA6",
      bscr: "\u{1D4B7}",
      bsemi: "\u204F",
      bsim: "\u223D",
      bsime: "\u22CD",
      bsol: "\\",
      bsolb: "\u29C5",
      bsolhsub: "\u27C8",
      bull: "\u2022",
      bullet: "\u2022",
      bump: "\u224E",
      bumpE: "\u2AAE",
      bumpe: "\u224F",
      bumpeq: "\u224F",
      cacute: "\u0107",
      cap: "\u2229",
      capand: "\u2A44",
      capbrcup: "\u2A49",
      capcap: "\u2A4B",
      capcup: "\u2A47",
      capdot: "\u2A40",
      caps: "\u2229\uFE00",
      caret: "\u2041",
      caron: "\u02C7",
      ccaps: "\u2A4D",
      ccaron: "\u010D",
      ccedi: "\xE7",
      ccedil: "\xE7",
      ccirc: "\u0109",
      ccups: "\u2A4C",
      ccupssm: "\u2A50",
      cdot: "\u010B",
      cedi: "\xB8",
      cedil: "\xB8",
      cemptyv: "\u29B2",
      cen: "\xA2",
      cent: "\xA2",
      centerdot: "\xB7",
      cfr: "\u{1D520}",
      chcy: "\u0447",
      check: "\u2713",
      checkmark: "\u2713",
      chi: "\u03C7",
      cir: "\u25CB",
      cirE: "\u29C3",
      circ: "\u02C6",
      circeq: "\u2257",
      circlearrowleft: "\u21BA",
      circlearrowright: "\u21BB",
      circledR: "\xAE",
      circledS: "\u24C8",
      circledast: "\u229B",
      circledcirc: "\u229A",
      circleddash: "\u229D",
      cire: "\u2257",
      cirfnint: "\u2A10",
      cirmid: "\u2AEF",
      cirscir: "\u29C2",
      clubs: "\u2663",
      clubsuit: "\u2663",
      colon: ":",
      colone: "\u2254",
      coloneq: "\u2254",
      comma: ",",
      commat: "@",
      comp: "\u2201",
      compfn: "\u2218",
      complement: "\u2201",
      complexes: "\u2102",
      cong: "\u2245",
      congdot: "\u2A6D",
      conint: "\u222E",
      copf: "\u{1D554}",
      coprod: "\u2210",
      cop: "\xA9",
      copy: "\xA9",
      copysr: "\u2117",
      crarr: "\u21B5",
      cross: "\u2717",
      cscr: "\u{1D4B8}",
      csub: "\u2ACF",
      csube: "\u2AD1",
      csup: "\u2AD0",
      csupe: "\u2AD2",
      ctdot: "\u22EF",
      cudarrl: "\u2938",
      cudarrr: "\u2935",
      cuepr: "\u22DE",
      cuesc: "\u22DF",
      cularr: "\u21B6",
      cularrp: "\u293D",
      cup: "\u222A",
      cupbrcap: "\u2A48",
      cupcap: "\u2A46",
      cupcup: "\u2A4A",
      cupdot: "\u228D",
      cupor: "\u2A45",
      cups: "\u222A\uFE00",
      curarr: "\u21B7",
      curarrm: "\u293C",
      curlyeqprec: "\u22DE",
      curlyeqsucc: "\u22DF",
      curlyvee: "\u22CE",
      curlywedge: "\u22CF",
      curre: "\xA4",
      curren: "\xA4",
      curvearrowleft: "\u21B6",
      curvearrowright: "\u21B7",
      cuvee: "\u22CE",
      cuwed: "\u22CF",
      cwconint: "\u2232",
      cwint: "\u2231",
      cylcty: "\u232D",
      dArr: "\u21D3",
      dHar: "\u2965",
      dagger: "\u2020",
      daleth: "\u2138",
      darr: "\u2193",
      dash: "\u2010",
      dashv: "\u22A3",
      dbkarow: "\u290F",
      dblac: "\u02DD",
      dcaron: "\u010F",
      dcy: "\u0434",
      dd: "\u2146",
      ddagger: "\u2021",
      ddarr: "\u21CA",
      ddotseq: "\u2A77",
      de: "\xB0",
      deg: "\xB0",
      delta: "\u03B4",
      demptyv: "\u29B1",
      dfisht: "\u297F",
      dfr: "\u{1D521}",
      dharl: "\u21C3",
      dharr: "\u21C2",
      diam: "\u22C4",
      diamond: "\u22C4",
      diamondsuit: "\u2666",
      diams: "\u2666",
      die: "\xA8",
      digamma: "\u03DD",
      disin: "\u22F2",
      div: "\xF7",
      divid: "\xF7",
      divide: "\xF7",
      divideontimes: "\u22C7",
      divonx: "\u22C7",
      djcy: "\u0452",
      dlcorn: "\u231E",
      dlcrop: "\u230D",
      dollar: "$",
      dopf: "\u{1D555}",
      dot: "\u02D9",
      doteq: "\u2250",
      doteqdot: "\u2251",
      dotminus: "\u2238",
      dotplus: "\u2214",
      dotsquare: "\u22A1",
      doublebarwedge: "\u2306",
      downarrow: "\u2193",
      downdownarrows: "\u21CA",
      downharpoonleft: "\u21C3",
      downharpoonright: "\u21C2",
      drbkarow: "\u2910",
      drcorn: "\u231F",
      drcrop: "\u230C",
      dscr: "\u{1D4B9}",
      dscy: "\u0455",
      dsol: "\u29F6",
      dstrok: "\u0111",
      dtdot: "\u22F1",
      dtri: "\u25BF",
      dtrif: "\u25BE",
      duarr: "\u21F5",
      duhar: "\u296F",
      dwangle: "\u29A6",
      dzcy: "\u045F",
      dzigrarr: "\u27FF",
      eDDot: "\u2A77",
      eDot: "\u2251",
      eacut: "\xE9",
      eacute: "\xE9",
      easter: "\u2A6E",
      ecaron: "\u011B",
      ecir: "\xEA",
      ecirc: "\xEA",
      ecolon: "\u2255",
      ecy: "\u044D",
      edot: "\u0117",
      ee: "\u2147",
      efDot: "\u2252",
      efr: "\u{1D522}",
      eg: "\u2A9A",
      egrav: "\xE8",
      egrave: "\xE8",
      egs: "\u2A96",
      egsdot: "\u2A98",
      el: "\u2A99",
      elinters: "\u23E7",
      ell: "\u2113",
      els: "\u2A95",
      elsdot: "\u2A97",
      emacr: "\u0113",
      empty: "\u2205",
      emptyset: "\u2205",
      emptyv: "\u2205",
      emsp13: "\u2004",
      emsp14: "\u2005",
      emsp: "\u2003",
      eng: "\u014B",
      ensp: "\u2002",
      eogon: "\u0119",
      eopf: "\u{1D556}",
      epar: "\u22D5",
      eparsl: "\u29E3",
      eplus: "\u2A71",
      epsi: "\u03B5",
      epsilon: "\u03B5",
      epsiv: "\u03F5",
      eqcirc: "\u2256",
      eqcolon: "\u2255",
      eqsim: "\u2242",
      eqslantgtr: "\u2A96",
      eqslantless: "\u2A95",
      equals: "=",
      equest: "\u225F",
      equiv: "\u2261",
      equivDD: "\u2A78",
      eqvparsl: "\u29E5",
      erDot: "\u2253",
      erarr: "\u2971",
      escr: "\u212F",
      esdot: "\u2250",
      esim: "\u2242",
      eta: "\u03B7",
      et: "\xF0",
      eth: "\xF0",
      eum: "\xEB",
      euml: "\xEB",
      euro: "\u20AC",
      excl: "!",
      exist: "\u2203",
      expectation: "\u2130",
      exponentiale: "\u2147",
      fallingdotseq: "\u2252",
      fcy: "\u0444",
      female: "\u2640",
      ffilig: "\uFB03",
      fflig: "\uFB00",
      ffllig: "\uFB04",
      ffr: "\u{1D523}",
      filig: "\uFB01",
      fjlig: "fj",
      flat: "\u266D",
      fllig: "\uFB02",
      fltns: "\u25B1",
      fnof: "\u0192",
      fopf: "\u{1D557}",
      forall: "\u2200",
      fork: "\u22D4",
      forkv: "\u2AD9",
      fpartint: "\u2A0D",
      frac1: "\xBC",
      frac12: "\xBD",
      frac13: "\u2153",
      frac14: "\xBC",
      frac15: "\u2155",
      frac16: "\u2159",
      frac18: "\u215B",
      frac23: "\u2154",
      frac25: "\u2156",
      frac3: "\xBE",
      frac34: "\xBE",
      frac35: "\u2157",
      frac38: "\u215C",
      frac45: "\u2158",
      frac56: "\u215A",
      frac58: "\u215D",
      frac78: "\u215E",
      frasl: "\u2044",
      frown: "\u2322",
      fscr: "\u{1D4BB}",
      gE: "\u2267",
      gEl: "\u2A8C",
      gacute: "\u01F5",
      gamma: "\u03B3",
      gammad: "\u03DD",
      gap: "\u2A86",
      gbreve: "\u011F",
      gcirc: "\u011D",
      gcy: "\u0433",
      gdot: "\u0121",
      ge: "\u2265",
      gel: "\u22DB",
      geq: "\u2265",
      geqq: "\u2267",
      geqslant: "\u2A7E",
      ges: "\u2A7E",
      gescc: "\u2AA9",
      gesdot: "\u2A80",
      gesdoto: "\u2A82",
      gesdotol: "\u2A84",
      gesl: "\u22DB\uFE00",
      gesles: "\u2A94",
      gfr: "\u{1D524}",
      gg: "\u226B",
      ggg: "\u22D9",
      gimel: "\u2137",
      gjcy: "\u0453",
      gl: "\u2277",
      glE: "\u2A92",
      gla: "\u2AA5",
      glj: "\u2AA4",
      gnE: "\u2269",
      gnap: "\u2A8A",
      gnapprox: "\u2A8A",
      gne: "\u2A88",
      gneq: "\u2A88",
      gneqq: "\u2269",
      gnsim: "\u22E7",
      gopf: "\u{1D558}",
      grave: "`",
      gscr: "\u210A",
      gsim: "\u2273",
      gsime: "\u2A8E",
      gsiml: "\u2A90",
      g: ">",
      gt: ">",
      gtcc: "\u2AA7",
      gtcir: "\u2A7A",
      gtdot: "\u22D7",
      gtlPar: "\u2995",
      gtquest: "\u2A7C",
      gtrapprox: "\u2A86",
      gtrarr: "\u2978",
      gtrdot: "\u22D7",
      gtreqless: "\u22DB",
      gtreqqless: "\u2A8C",
      gtrless: "\u2277",
      gtrsim: "\u2273",
      gvertneqq: "\u2269\uFE00",
      gvnE: "\u2269\uFE00",
      hArr: "\u21D4",
      hairsp: "\u200A",
      half: "\xBD",
      hamilt: "\u210B",
      hardcy: "\u044A",
      harr: "\u2194",
      harrcir: "\u2948",
      harrw: "\u21AD",
      hbar: "\u210F",
      hcirc: "\u0125",
      hearts: "\u2665",
      heartsuit: "\u2665",
      hellip: "\u2026",
      hercon: "\u22B9",
      hfr: "\u{1D525}",
      hksearow: "\u2925",
      hkswarow: "\u2926",
      hoarr: "\u21FF",
      homtht: "\u223B",
      hookleftarrow: "\u21A9",
      hookrightarrow: "\u21AA",
      hopf: "\u{1D559}",
      horbar: "\u2015",
      hscr: "\u{1D4BD}",
      hslash: "\u210F",
      hstrok: "\u0127",
      hybull: "\u2043",
      hyphen: "\u2010",
      iacut: "\xED",
      iacute: "\xED",
      ic: "\u2063",
      icir: "\xEE",
      icirc: "\xEE",
      icy: "\u0438",
      iecy: "\u0435",
      iexc: "\xA1",
      iexcl: "\xA1",
      iff: "\u21D4",
      ifr: "\u{1D526}",
      igrav: "\xEC",
      igrave: "\xEC",
      ii: "\u2148",
      iiiint: "\u2A0C",
      iiint: "\u222D",
      iinfin: "\u29DC",
      iiota: "\u2129",
      ijlig: "\u0133",
      imacr: "\u012B",
      image: "\u2111",
      imagline: "\u2110",
      imagpart: "\u2111",
      imath: "\u0131",
      imof: "\u22B7",
      imped: "\u01B5",
      in: "\u2208",
      incare: "\u2105",
      infin: "\u221E",
      infintie: "\u29DD",
      inodot: "\u0131",
      int: "\u222B",
      intcal: "\u22BA",
      integers: "\u2124",
      intercal: "\u22BA",
      intlarhk: "\u2A17",
      intprod: "\u2A3C",
      iocy: "\u0451",
      iogon: "\u012F",
      iopf: "\u{1D55A}",
      iota: "\u03B9",
      iprod: "\u2A3C",
      iques: "\xBF",
      iquest: "\xBF",
      iscr: "\u{1D4BE}",
      isin: "\u2208",
      isinE: "\u22F9",
      isindot: "\u22F5",
      isins: "\u22F4",
      isinsv: "\u22F3",
      isinv: "\u2208",
      it: "\u2062",
      itilde: "\u0129",
      iukcy: "\u0456",
      ium: "\xEF",
      iuml: "\xEF",
      jcirc: "\u0135",
      jcy: "\u0439",
      jfr: "\u{1D527}",
      jmath: "\u0237",
      jopf: "\u{1D55B}",
      jscr: "\u{1D4BF}",
      jsercy: "\u0458",
      jukcy: "\u0454",
      kappa: "\u03BA",
      kappav: "\u03F0",
      kcedil: "\u0137",
      kcy: "\u043A",
      kfr: "\u{1D528}",
      kgreen: "\u0138",
      khcy: "\u0445",
      kjcy: "\u045C",
      kopf: "\u{1D55C}",
      kscr: "\u{1D4C0}",
      lAarr: "\u21DA",
      lArr: "\u21D0",
      lAtail: "\u291B",
      lBarr: "\u290E",
      lE: "\u2266",
      lEg: "\u2A8B",
      lHar: "\u2962",
      lacute: "\u013A",
      laemptyv: "\u29B4",
      lagran: "\u2112",
      lambda: "\u03BB",
      lang: "\u27E8",
      langd: "\u2991",
      langle: "\u27E8",
      lap: "\u2A85",
      laqu: "\xAB",
      laquo: "\xAB",
      larr: "\u2190",
      larrb: "\u21E4",
      larrbfs: "\u291F",
      larrfs: "\u291D",
      larrhk: "\u21A9",
      larrlp: "\u21AB",
      larrpl: "\u2939",
      larrsim: "\u2973",
      larrtl: "\u21A2",
      lat: "\u2AAB",
      latail: "\u2919",
      late: "\u2AAD",
      lates: "\u2AAD\uFE00",
      lbarr: "\u290C",
      lbbrk: "\u2772",
      lbrace: "{",
      lbrack: "[",
      lbrke: "\u298B",
      lbrksld: "\u298F",
      lbrkslu: "\u298D",
      lcaron: "\u013E",
      lcedil: "\u013C",
      lceil: "\u2308",
      lcub: "{",
      lcy: "\u043B",
      ldca: "\u2936",
      ldquo: "\u201C",
      ldquor: "\u201E",
      ldrdhar: "\u2967",
      ldrushar: "\u294B",
      ldsh: "\u21B2",
      le: "\u2264",
      leftarrow: "\u2190",
      leftarrowtail: "\u21A2",
      leftharpoondown: "\u21BD",
      leftharpoonup: "\u21BC",
      leftleftarrows: "\u21C7",
      leftrightarrow: "\u2194",
      leftrightarrows: "\u21C6",
      leftrightharpoons: "\u21CB",
      leftrightsquigarrow: "\u21AD",
      leftthreetimes: "\u22CB",
      leg: "\u22DA",
      leq: "\u2264",
      leqq: "\u2266",
      leqslant: "\u2A7D",
      les: "\u2A7D",
      lescc: "\u2AA8",
      lesdot: "\u2A7F",
      lesdoto: "\u2A81",
      lesdotor: "\u2A83",
      lesg: "\u22DA\uFE00",
      lesges: "\u2A93",
      lessapprox: "\u2A85",
      lessdot: "\u22D6",
      lesseqgtr: "\u22DA",
      lesseqqgtr: "\u2A8B",
      lessgtr: "\u2276",
      lesssim: "\u2272",
      lfisht: "\u297C",
      lfloor: "\u230A",
      lfr: "\u{1D529}",
      lg: "\u2276",
      lgE: "\u2A91",
      lhard: "\u21BD",
      lharu: "\u21BC",
      lharul: "\u296A",
      lhblk: "\u2584",
      ljcy: "\u0459",
      ll: "\u226A",
      llarr: "\u21C7",
      llcorner: "\u231E",
      llhard: "\u296B",
      lltri: "\u25FA",
      lmidot: "\u0140",
      lmoust: "\u23B0",
      lmoustache: "\u23B0",
      lnE: "\u2268",
      lnap: "\u2A89",
      lnapprox: "\u2A89",
      lne: "\u2A87",
      lneq: "\u2A87",
      lneqq: "\u2268",
      lnsim: "\u22E6",
      loang: "\u27EC",
      loarr: "\u21FD",
      lobrk: "\u27E6",
      longleftarrow: "\u27F5",
      longleftrightarrow: "\u27F7",
      longmapsto: "\u27FC",
      longrightarrow: "\u27F6",
      looparrowleft: "\u21AB",
      looparrowright: "\u21AC",
      lopar: "\u2985",
      lopf: "\u{1D55D}",
      loplus: "\u2A2D",
      lotimes: "\u2A34",
      lowast: "\u2217",
      lowbar: "_",
      loz: "\u25CA",
      lozenge: "\u25CA",
      lozf: "\u29EB",
      lpar: "(",
      lparlt: "\u2993",
      lrarr: "\u21C6",
      lrcorner: "\u231F",
      lrhar: "\u21CB",
      lrhard: "\u296D",
      lrm: "\u200E",
      lrtri: "\u22BF",
      lsaquo: "\u2039",
      lscr: "\u{1D4C1}",
      lsh: "\u21B0",
      lsim: "\u2272",
      lsime: "\u2A8D",
      lsimg: "\u2A8F",
      lsqb: "[",
      lsquo: "\u2018",
      lsquor: "\u201A",
      lstrok: "\u0142",
      l: "<",
      lt: "<",
      ltcc: "\u2AA6",
      ltcir: "\u2A79",
      ltdot: "\u22D6",
      lthree: "\u22CB",
      ltimes: "\u22C9",
      ltlarr: "\u2976",
      ltquest: "\u2A7B",
      ltrPar: "\u2996",
      ltri: "\u25C3",
      ltrie: "\u22B4",
      ltrif: "\u25C2",
      lurdshar: "\u294A",
      luruhar: "\u2966",
      lvertneqq: "\u2268\uFE00",
      lvnE: "\u2268\uFE00",
      mDDot: "\u223A",
      mac: "\xAF",
      macr: "\xAF",
      male: "\u2642",
      malt: "\u2720",
      maltese: "\u2720",
      map: "\u21A6",
      mapsto: "\u21A6",
      mapstodown: "\u21A7",
      mapstoleft: "\u21A4",
      mapstoup: "\u21A5",
      marker: "\u25AE",
      mcomma: "\u2A29",
      mcy: "\u043C",
      mdash: "\u2014",
      measuredangle: "\u2221",
      mfr: "\u{1D52A}",
      mho: "\u2127",
      micr: "\xB5",
      micro: "\xB5",
      mid: "\u2223",
      midast: "*",
      midcir: "\u2AF0",
      middo: "\xB7",
      middot: "\xB7",
      minus: "\u2212",
      minusb: "\u229F",
      minusd: "\u2238",
      minusdu: "\u2A2A",
      mlcp: "\u2ADB",
      mldr: "\u2026",
      mnplus: "\u2213",
      models: "\u22A7",
      mopf: "\u{1D55E}",
      mp: "\u2213",
      mscr: "\u{1D4C2}",
      mstpos: "\u223E",
      mu: "\u03BC",
      multimap: "\u22B8",
      mumap: "\u22B8",
      nGg: "\u22D9\u0338",
      nGt: "\u226B\u20D2",
      nGtv: "\u226B\u0338",
      nLeftarrow: "\u21CD",
      nLeftrightarrow: "\u21CE",
      nLl: "\u22D8\u0338",
      nLt: "\u226A\u20D2",
      nLtv: "\u226A\u0338",
      nRightarrow: "\u21CF",
      nVDash: "\u22AF",
      nVdash: "\u22AE",
      nabla: "\u2207",
      nacute: "\u0144",
      nang: "\u2220\u20D2",
      nap: "\u2249",
      napE: "\u2A70\u0338",
      napid: "\u224B\u0338",
      napos: "\u0149",
      napprox: "\u2249",
      natur: "\u266E",
      natural: "\u266E",
      naturals: "\u2115",
      nbs: "\xA0",
      nbsp: "\xA0",
      nbump: "\u224E\u0338",
      nbumpe: "\u224F\u0338",
      ncap: "\u2A43",
      ncaron: "\u0148",
      ncedil: "\u0146",
      ncong: "\u2247",
      ncongdot: "\u2A6D\u0338",
      ncup: "\u2A42",
      ncy: "\u043D",
      ndash: "\u2013",
      ne: "\u2260",
      neArr: "\u21D7",
      nearhk: "\u2924",
      nearr: "\u2197",
      nearrow: "\u2197",
      nedot: "\u2250\u0338",
      nequiv: "\u2262",
      nesear: "\u2928",
      nesim: "\u2242\u0338",
      nexist: "\u2204",
      nexists: "\u2204",
      nfr: "\u{1D52B}",
      ngE: "\u2267\u0338",
      nge: "\u2271",
      ngeq: "\u2271",
      ngeqq: "\u2267\u0338",
      ngeqslant: "\u2A7E\u0338",
      nges: "\u2A7E\u0338",
      ngsim: "\u2275",
      ngt: "\u226F",
      ngtr: "\u226F",
      nhArr: "\u21CE",
      nharr: "\u21AE",
      nhpar: "\u2AF2",
      ni: "\u220B",
      nis: "\u22FC",
      nisd: "\u22FA",
      niv: "\u220B",
      njcy: "\u045A",
      nlArr: "\u21CD",
      nlE: "\u2266\u0338",
      nlarr: "\u219A",
      nldr: "\u2025",
      nle: "\u2270",
      nleftarrow: "\u219A",
      nleftrightarrow: "\u21AE",
      nleq: "\u2270",
      nleqq: "\u2266\u0338",
      nleqslant: "\u2A7D\u0338",
      nles: "\u2A7D\u0338",
      nless: "\u226E",
      nlsim: "\u2274",
      nlt: "\u226E",
      nltri: "\u22EA",
      nltrie: "\u22EC",
      nmid: "\u2224",
      nopf: "\u{1D55F}",
      no: "\xAC",
      not: "\xAC",
      notin: "\u2209",
      notinE: "\u22F9\u0338",
      notindot: "\u22F5\u0338",
      notinva: "\u2209",
      notinvb: "\u22F7",
      notinvc: "\u22F6",
      notni: "\u220C",
      notniva: "\u220C",
      notnivb: "\u22FE",
      notnivc: "\u22FD",
      npar: "\u2226",
      nparallel: "\u2226",
      nparsl: "\u2AFD\u20E5",
      npart: "\u2202\u0338",
      npolint: "\u2A14",
      npr: "\u2280",
      nprcue: "\u22E0",
      npre: "\u2AAF\u0338",
      nprec: "\u2280",
      npreceq: "\u2AAF\u0338",
      nrArr: "\u21CF",
      nrarr: "\u219B",
      nrarrc: "\u2933\u0338",
      nrarrw: "\u219D\u0338",
      nrightarrow: "\u219B",
      nrtri: "\u22EB",
      nrtrie: "\u22ED",
      nsc: "\u2281",
      nsccue: "\u22E1",
      nsce: "\u2AB0\u0338",
      nscr: "\u{1D4C3}",
      nshortmid: "\u2224",
      nshortparallel: "\u2226",
      nsim: "\u2241",
      nsime: "\u2244",
      nsimeq: "\u2244",
      nsmid: "\u2224",
      nspar: "\u2226",
      nsqsube: "\u22E2",
      nsqsupe: "\u22E3",
      nsub: "\u2284",
      nsubE: "\u2AC5\u0338",
      nsube: "\u2288",
      nsubset: "\u2282\u20D2",
      nsubseteq: "\u2288",
      nsubseteqq: "\u2AC5\u0338",
      nsucc: "\u2281",
      nsucceq: "\u2AB0\u0338",
      nsup: "\u2285",
      nsupE: "\u2AC6\u0338",
      nsupe: "\u2289",
      nsupset: "\u2283\u20D2",
      nsupseteq: "\u2289",
      nsupseteqq: "\u2AC6\u0338",
      ntgl: "\u2279",
      ntild: "\xF1",
      ntilde: "\xF1",
      ntlg: "\u2278",
      ntriangleleft: "\u22EA",
      ntrianglelefteq: "\u22EC",
      ntriangleright: "\u22EB",
      ntrianglerighteq: "\u22ED",
      nu: "\u03BD",
      num: "#",
      numero: "\u2116",
      numsp: "\u2007",
      nvDash: "\u22AD",
      nvHarr: "\u2904",
      nvap: "\u224D\u20D2",
      nvdash: "\u22AC",
      nvge: "\u2265\u20D2",
      nvgt: ">\u20D2",
      nvinfin: "\u29DE",
      nvlArr: "\u2902",
      nvle: "\u2264\u20D2",
      nvlt: "<\u20D2",
      nvltrie: "\u22B4\u20D2",
      nvrArr: "\u2903",
      nvrtrie: "\u22B5\u20D2",
      nvsim: "\u223C\u20D2",
      nwArr: "\u21D6",
      nwarhk: "\u2923",
      nwarr: "\u2196",
      nwarrow: "\u2196",
      nwnear: "\u2927",
      oS: "\u24C8",
      oacut: "\xF3",
      oacute: "\xF3",
      oast: "\u229B",
      ocir: "\xF4",
      ocirc: "\xF4",
      ocy: "\u043E",
      odash: "\u229D",
      odblac: "\u0151",
      odiv: "\u2A38",
      odot: "\u2299",
      odsold: "\u29BC",
      oelig: "\u0153",
      ofcir: "\u29BF",
      ofr: "\u{1D52C}",
      ogon: "\u02DB",
      ograv: "\xF2",
      ograve: "\xF2",
      ogt: "\u29C1",
      ohbar: "\u29B5",
      ohm: "\u03A9",
      oint: "\u222E",
      olarr: "\u21BA",
      olcir: "\u29BE",
      olcross: "\u29BB",
      oline: "\u203E",
      olt: "\u29C0",
      omacr: "\u014D",
      omega: "\u03C9",
      omicron: "\u03BF",
      omid: "\u29B6",
      ominus: "\u2296",
      oopf: "\u{1D560}",
      opar: "\u29B7",
      operp: "\u29B9",
      oplus: "\u2295",
      or: "\u2228",
      orarr: "\u21BB",
      ord: "\xBA",
      order: "\u2134",
      orderof: "\u2134",
      ordf: "\xAA",
      ordm: "\xBA",
      origof: "\u22B6",
      oror: "\u2A56",
      orslope: "\u2A57",
      orv: "\u2A5B",
      oscr: "\u2134",
      oslas: "\xF8",
      oslash: "\xF8",
      osol: "\u2298",
      otild: "\xF5",
      otilde: "\xF5",
      otimes: "\u2297",
      otimesas: "\u2A36",
      oum: "\xF6",
      ouml: "\xF6",
      ovbar: "\u233D",
      par: "\xB6",
      para: "\xB6",
      parallel: "\u2225",
      parsim: "\u2AF3",
      parsl: "\u2AFD",
      part: "\u2202",
      pcy: "\u043F",
      percnt: "%",
      period: ".",
      permil: "\u2030",
      perp: "\u22A5",
      pertenk: "\u2031",
      pfr: "\u{1D52D}",
      phi: "\u03C6",
      phiv: "\u03D5",
      phmmat: "\u2133",
      phone: "\u260E",
      pi: "\u03C0",
      pitchfork: "\u22D4",
      piv: "\u03D6",
      planck: "\u210F",
      planckh: "\u210E",
      plankv: "\u210F",
      plus: "+",
      plusacir: "\u2A23",
      plusb: "\u229E",
      pluscir: "\u2A22",
      plusdo: "\u2214",
      plusdu: "\u2A25",
      pluse: "\u2A72",
      plusm: "\xB1",
      plusmn: "\xB1",
      plussim: "\u2A26",
      plustwo: "\u2A27",
      pm: "\xB1",
      pointint: "\u2A15",
      popf: "\u{1D561}",
      poun: "\xA3",
      pound: "\xA3",
      pr: "\u227A",
      prE: "\u2AB3",
      prap: "\u2AB7",
      prcue: "\u227C",
      pre: "\u2AAF",
      prec: "\u227A",
      precapprox: "\u2AB7",
      preccurlyeq: "\u227C",
      preceq: "\u2AAF",
      precnapprox: "\u2AB9",
      precneqq: "\u2AB5",
      precnsim: "\u22E8",
      precsim: "\u227E",
      prime: "\u2032",
      primes: "\u2119",
      prnE: "\u2AB5",
      prnap: "\u2AB9",
      prnsim: "\u22E8",
      prod: "\u220F",
      profalar: "\u232E",
      profline: "\u2312",
      profsurf: "\u2313",
      prop: "\u221D",
      propto: "\u221D",
      prsim: "\u227E",
      prurel: "\u22B0",
      pscr: "\u{1D4C5}",
      psi: "\u03C8",
      puncsp: "\u2008",
      qfr: "\u{1D52E}",
      qint: "\u2A0C",
      qopf: "\u{1D562}",
      qprime: "\u2057",
      qscr: "\u{1D4C6}",
      quaternions: "\u210D",
      quatint: "\u2A16",
      quest: "?",
      questeq: "\u225F",
      quo: '"',
      quot: '"',
      rAarr: "\u21DB",
      rArr: "\u21D2",
      rAtail: "\u291C",
      rBarr: "\u290F",
      rHar: "\u2964",
      race: "\u223D\u0331",
      racute: "\u0155",
      radic: "\u221A",
      raemptyv: "\u29B3",
      rang: "\u27E9",
      rangd: "\u2992",
      range: "\u29A5",
      rangle: "\u27E9",
      raqu: "\xBB",
      raquo: "\xBB",
      rarr: "\u2192",
      rarrap: "\u2975",
      rarrb: "\u21E5",
      rarrbfs: "\u2920",
      rarrc: "\u2933",
      rarrfs: "\u291E",
      rarrhk: "\u21AA",
      rarrlp: "\u21AC",
      rarrpl: "\u2945",
      rarrsim: "\u2974",
      rarrtl: "\u21A3",
      rarrw: "\u219D",
      ratail: "\u291A",
      ratio: "\u2236",
      rationals: "\u211A",
      rbarr: "\u290D",
      rbbrk: "\u2773",
      rbrace: "}",
      rbrack: "]",
      rbrke: "\u298C",
      rbrksld: "\u298E",
      rbrkslu: "\u2990",
      rcaron: "\u0159",
      rcedil: "\u0157",
      rceil: "\u2309",
      rcub: "}",
      rcy: "\u0440",
      rdca: "\u2937",
      rdldhar: "\u2969",
      rdquo: "\u201D",
      rdquor: "\u201D",
      rdsh: "\u21B3",
      real: "\u211C",
      realine: "\u211B",
      realpart: "\u211C",
      reals: "\u211D",
      rect: "\u25AD",
      re: "\xAE",
      reg: "\xAE",
      rfisht: "\u297D",
      rfloor: "\u230B",
      rfr: "\u{1D52F}",
      rhard: "\u21C1",
      rharu: "\u21C0",
      rharul: "\u296C",
      rho: "\u03C1",
      rhov: "\u03F1",
      rightarrow: "\u2192",
      rightarrowtail: "\u21A3",
      rightharpoondown: "\u21C1",
      rightharpoonup: "\u21C0",
      rightleftarrows: "\u21C4",
      rightleftharpoons: "\u21CC",
      rightrightarrows: "\u21C9",
      rightsquigarrow: "\u219D",
      rightthreetimes: "\u22CC",
      ring: "\u02DA",
      risingdotseq: "\u2253",
      rlarr: "\u21C4",
      rlhar: "\u21CC",
      rlm: "\u200F",
      rmoust: "\u23B1",
      rmoustache: "\u23B1",
      rnmid: "\u2AEE",
      roang: "\u27ED",
      roarr: "\u21FE",
      robrk: "\u27E7",
      ropar: "\u2986",
      ropf: "\u{1D563}",
      roplus: "\u2A2E",
      rotimes: "\u2A35",
      rpar: ")",
      rpargt: "\u2994",
      rppolint: "\u2A12",
      rrarr: "\u21C9",
      rsaquo: "\u203A",
      rscr: "\u{1D4C7}",
      rsh: "\u21B1",
      rsqb: "]",
      rsquo: "\u2019",
      rsquor: "\u2019",
      rthree: "\u22CC",
      rtimes: "\u22CA",
      rtri: "\u25B9",
      rtrie: "\u22B5",
      rtrif: "\u25B8",
      rtriltri: "\u29CE",
      ruluhar: "\u2968",
      rx: "\u211E",
      sacute: "\u015B",
      sbquo: "\u201A",
      sc: "\u227B",
      scE: "\u2AB4",
      scap: "\u2AB8",
      scaron: "\u0161",
      sccue: "\u227D",
      sce: "\u2AB0",
      scedil: "\u015F",
      scirc: "\u015D",
      scnE: "\u2AB6",
      scnap: "\u2ABA",
      scnsim: "\u22E9",
      scpolint: "\u2A13",
      scsim: "\u227F",
      scy: "\u0441",
      sdot: "\u22C5",
      sdotb: "\u22A1",
      sdote: "\u2A66",
      seArr: "\u21D8",
      searhk: "\u2925",
      searr: "\u2198",
      searrow: "\u2198",
      sec: "\xA7",
      sect: "\xA7",
      semi: ";",
      seswar: "\u2929",
      setminus: "\u2216",
      setmn: "\u2216",
      sext: "\u2736",
      sfr: "\u{1D530}",
      sfrown: "\u2322",
      sharp: "\u266F",
      shchcy: "\u0449",
      shcy: "\u0448",
      shortmid: "\u2223",
      shortparallel: "\u2225",
      sh: "\xAD",
      shy: "\xAD",
      sigma: "\u03C3",
      sigmaf: "\u03C2",
      sigmav: "\u03C2",
      sim: "\u223C",
      simdot: "\u2A6A",
      sime: "\u2243",
      simeq: "\u2243",
      simg: "\u2A9E",
      simgE: "\u2AA0",
      siml: "\u2A9D",
      simlE: "\u2A9F",
      simne: "\u2246",
      simplus: "\u2A24",
      simrarr: "\u2972",
      slarr: "\u2190",
      smallsetminus: "\u2216",
      smashp: "\u2A33",
      smeparsl: "\u29E4",
      smid: "\u2223",
      smile: "\u2323",
      smt: "\u2AAA",
      smte: "\u2AAC",
      smtes: "\u2AAC\uFE00",
      softcy: "\u044C",
      sol: "/",
      solb: "\u29C4",
      solbar: "\u233F",
      sopf: "\u{1D564}",
      spades: "\u2660",
      spadesuit: "\u2660",
      spar: "\u2225",
      sqcap: "\u2293",
      sqcaps: "\u2293\uFE00",
      sqcup: "\u2294",
      sqcups: "\u2294\uFE00",
      sqsub: "\u228F",
      sqsube: "\u2291",
      sqsubset: "\u228F",
      sqsubseteq: "\u2291",
      sqsup: "\u2290",
      sqsupe: "\u2292",
      sqsupset: "\u2290",
      sqsupseteq: "\u2292",
      squ: "\u25A1",
      square: "\u25A1",
      squarf: "\u25AA",
      squf: "\u25AA",
      srarr: "\u2192",
      sscr: "\u{1D4C8}",
      ssetmn: "\u2216",
      ssmile: "\u2323",
      sstarf: "\u22C6",
      star: "\u2606",
      starf: "\u2605",
      straightepsilon: "\u03F5",
      straightphi: "\u03D5",
      strns: "\xAF",
      sub: "\u2282",
      subE: "\u2AC5",
      subdot: "\u2ABD",
      sube: "\u2286",
      subedot: "\u2AC3",
      submult: "\u2AC1",
      subnE: "\u2ACB",
      subne: "\u228A",
      subplus: "\u2ABF",
      subrarr: "\u2979",
      subset: "\u2282",
      subseteq: "\u2286",
      subseteqq: "\u2AC5",
      subsetneq: "\u228A",
      subsetneqq: "\u2ACB",
      subsim: "\u2AC7",
      subsub: "\u2AD5",
      subsup: "\u2AD3",
      succ: "\u227B",
      succapprox: "\u2AB8",
      succcurlyeq: "\u227D",
      succeq: "\u2AB0",
      succnapprox: "\u2ABA",
      succneqq: "\u2AB6",
      succnsim: "\u22E9",
      succsim: "\u227F",
      sum: "\u2211",
      sung: "\u266A",
      sup: "\u2283",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      supE: "\u2AC6",
      supdot: "\u2ABE",
      supdsub: "\u2AD8",
      supe: "\u2287",
      supedot: "\u2AC4",
      suphsol: "\u27C9",
      suphsub: "\u2AD7",
      suplarr: "\u297B",
      supmult: "\u2AC2",
      supnE: "\u2ACC",
      supne: "\u228B",
      supplus: "\u2AC0",
      supset: "\u2283",
      supseteq: "\u2287",
      supseteqq: "\u2AC6",
      supsetneq: "\u228B",
      supsetneqq: "\u2ACC",
      supsim: "\u2AC8",
      supsub: "\u2AD4",
      supsup: "\u2AD6",
      swArr: "\u21D9",
      swarhk: "\u2926",
      swarr: "\u2199",
      swarrow: "\u2199",
      swnwar: "\u292A",
      szli: "\xDF",
      szlig: "\xDF",
      target: "\u2316",
      tau: "\u03C4",
      tbrk: "\u23B4",
      tcaron: "\u0165",
      tcedil: "\u0163",
      tcy: "\u0442",
      tdot: "\u20DB",
      telrec: "\u2315",
      tfr: "\u{1D531}",
      there4: "\u2234",
      therefore: "\u2234",
      theta: "\u03B8",
      thetasym: "\u03D1",
      thetav: "\u03D1",
      thickapprox: "\u2248",
      thicksim: "\u223C",
      thinsp: "\u2009",
      thkap: "\u2248",
      thksim: "\u223C",
      thor: "\xFE",
      thorn: "\xFE",
      tilde: "\u02DC",
      time: "\xD7",
      times: "\xD7",
      timesb: "\u22A0",
      timesbar: "\u2A31",
      timesd: "\u2A30",
      tint: "\u222D",
      toea: "\u2928",
      top: "\u22A4",
      topbot: "\u2336",
      topcir: "\u2AF1",
      topf: "\u{1D565}",
      topfork: "\u2ADA",
      tosa: "\u2929",
      tprime: "\u2034",
      trade: "\u2122",
      triangle: "\u25B5",
      triangledown: "\u25BF",
      triangleleft: "\u25C3",
      trianglelefteq: "\u22B4",
      triangleq: "\u225C",
      triangleright: "\u25B9",
      trianglerighteq: "\u22B5",
      tridot: "\u25EC",
      trie: "\u225C",
      triminus: "\u2A3A",
      triplus: "\u2A39",
      trisb: "\u29CD",
      tritime: "\u2A3B",
      trpezium: "\u23E2",
      tscr: "\u{1D4C9}",
      tscy: "\u0446",
      tshcy: "\u045B",
      tstrok: "\u0167",
      twixt: "\u226C",
      twoheadleftarrow: "\u219E",
      twoheadrightarrow: "\u21A0",
      uArr: "\u21D1",
      uHar: "\u2963",
      uacut: "\xFA",
      uacute: "\xFA",
      uarr: "\u2191",
      ubrcy: "\u045E",
      ubreve: "\u016D",
      ucir: "\xFB",
      ucirc: "\xFB",
      ucy: "\u0443",
      udarr: "\u21C5",
      udblac: "\u0171",
      udhar: "\u296E",
      ufisht: "\u297E",
      ufr: "\u{1D532}",
      ugrav: "\xF9",
      ugrave: "\xF9",
      uharl: "\u21BF",
      uharr: "\u21BE",
      uhblk: "\u2580",
      ulcorn: "\u231C",
      ulcorner: "\u231C",
      ulcrop: "\u230F",
      ultri: "\u25F8",
      umacr: "\u016B",
      um: "\xA8",
      uml: "\xA8",
      uogon: "\u0173",
      uopf: "\u{1D566}",
      uparrow: "\u2191",
      updownarrow: "\u2195",
      upharpoonleft: "\u21BF",
      upharpoonright: "\u21BE",
      uplus: "\u228E",
      upsi: "\u03C5",
      upsih: "\u03D2",
      upsilon: "\u03C5",
      upuparrows: "\u21C8",
      urcorn: "\u231D",
      urcorner: "\u231D",
      urcrop: "\u230E",
      uring: "\u016F",
      urtri: "\u25F9",
      uscr: "\u{1D4CA}",
      utdot: "\u22F0",
      utilde: "\u0169",
      utri: "\u25B5",
      utrif: "\u25B4",
      uuarr: "\u21C8",
      uum: "\xFC",
      uuml: "\xFC",
      uwangle: "\u29A7",
      vArr: "\u21D5",
      vBar: "\u2AE8",
      vBarv: "\u2AE9",
      vDash: "\u22A8",
      vangrt: "\u299C",
      varepsilon: "\u03F5",
      varkappa: "\u03F0",
      varnothing: "\u2205",
      varphi: "\u03D5",
      varpi: "\u03D6",
      varpropto: "\u221D",
      varr: "\u2195",
      varrho: "\u03F1",
      varsigma: "\u03C2",
      varsubsetneq: "\u228A\uFE00",
      varsubsetneqq: "\u2ACB\uFE00",
      varsupsetneq: "\u228B\uFE00",
      varsupsetneqq: "\u2ACC\uFE00",
      vartheta: "\u03D1",
      vartriangleleft: "\u22B2",
      vartriangleright: "\u22B3",
      vcy: "\u0432",
      vdash: "\u22A2",
      vee: "\u2228",
      veebar: "\u22BB",
      veeeq: "\u225A",
      vellip: "\u22EE",
      verbar: "|",
      vert: "|",
      vfr: "\u{1D533}",
      vltri: "\u22B2",
      vnsub: "\u2282\u20D2",
      vnsup: "\u2283\u20D2",
      vopf: "\u{1D567}",
      vprop: "\u221D",
      vrtri: "\u22B3",
      vscr: "\u{1D4CB}",
      vsubnE: "\u2ACB\uFE00",
      vsubne: "\u228A\uFE00",
      vsupnE: "\u2ACC\uFE00",
      vsupne: "\u228B\uFE00",
      vzigzag: "\u299A",
      wcirc: "\u0175",
      wedbar: "\u2A5F",
      wedge: "\u2227",
      wedgeq: "\u2259",
      weierp: "\u2118",
      wfr: "\u{1D534}",
      wopf: "\u{1D568}",
      wp: "\u2118",
      wr: "\u2240",
      wreath: "\u2240",
      wscr: "\u{1D4CC}",
      xcap: "\u22C2",
      xcirc: "\u25EF",
      xcup: "\u22C3",
      xdtri: "\u25BD",
      xfr: "\u{1D535}",
      xhArr: "\u27FA",
      xharr: "\u27F7",
      xi: "\u03BE",
      xlArr: "\u27F8",
      xlarr: "\u27F5",
      xmap: "\u27FC",
      xnis: "\u22FB",
      xodot: "\u2A00",
      xopf: "\u{1D569}",
      xoplus: "\u2A01",
      xotime: "\u2A02",
      xrArr: "\u27F9",
      xrarr: "\u27F6",
      xscr: "\u{1D4CD}",
      xsqcup: "\u2A06",
      xuplus: "\u2A04",
      xutri: "\u25B3",
      xvee: "\u22C1",
      xwedge: "\u22C0",
      yacut: "\xFD",
      yacute: "\xFD",
      yacy: "\u044F",
      ycirc: "\u0177",
      ycy: "\u044B",
      ye: "\xA5",
      yen: "\xA5",
      yfr: "\u{1D536}",
      yicy: "\u0457",
      yopf: "\u{1D56A}",
      yscr: "\u{1D4CE}",
      yucy: "\u044E",
      yum: "\xFF",
      yuml: "\xFF",
      zacute: "\u017A",
      zcaron: "\u017E",
      zcy: "\u0437",
      zdot: "\u017C",
      zeetrf: "\u2128",
      zeta: "\u03B6",
      zfr: "\u{1D537}",
      zhcy: "\u0436",
      zigrarr: "\u21DD",
      zopf: "\u{1D56B}",
      zscr: "\u{1D4CF}",
      zwj: "\u200D",
      zwnj: "\u200C"
    };
  }
});

// ../../node_modules/parse-entities/decode-entity.js
var require_decode_entity = __commonJS({
  "../../node_modules/parse-entities/decode-entity.js"(exports, module2) {
    "use strict";
    var characterEntities = require_character_entities();
    module2.exports = decodeEntity;
    var own = {}.hasOwnProperty;
    function decodeEntity(characters) {
      return own.call(characterEntities, characters) ? characterEntities[characters] : false;
    }
  }
});

// ../../node_modules/parse-entities/index.js
var require_parse_entities = __commonJS({
  "../../node_modules/parse-entities/index.js"(exports, module2) {
    "use strict";
    var legacy = require_character_entities_legacy();
    var invalid = require_character_reference_invalid();
    var decimal = require_is_decimal();
    var hexadecimal = require_is_hexadecimal();
    var alphanumerical = require_is_alphanumerical();
    var decodeEntity = require_decode_entity();
    module2.exports = parseEntities;
    var own = {}.hasOwnProperty;
    var fromCharCode = String.fromCharCode;
    var noop = Function.prototype;
    var defaults = {
      warning: null,
      reference: null,
      text: null,
      warningContext: null,
      referenceContext: null,
      textContext: null,
      position: {},
      additional: null,
      attribute: false,
      nonTerminated: true
    };
    var tab = 9;
    var lineFeed = 10;
    var formFeed = 12;
    var space = 32;
    var ampersand = 38;
    var semicolon = 59;
    var lessThan = 60;
    var equalsTo = 61;
    var numberSign = 35;
    var uppercaseX = 88;
    var lowercaseX = 120;
    var replacementCharacter = 65533;
    var name = "named";
    var hexa = "hexadecimal";
    var deci = "decimal";
    var bases = {};
    bases[hexa] = 16;
    bases[deci] = 10;
    var tests = {};
    tests[name] = alphanumerical;
    tests[deci] = decimal;
    tests[hexa] = hexadecimal;
    var namedNotTerminated = 1;
    var numericNotTerminated = 2;
    var namedEmpty = 3;
    var numericEmpty = 4;
    var namedUnknown = 5;
    var numericDisallowed = 6;
    var numericProhibited = 7;
    var messages = {};
    messages[namedNotTerminated] = "Named character references must be terminated by a semicolon";
    messages[numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
    messages[namedEmpty] = "Named character references cannot be empty";
    messages[numericEmpty] = "Numeric character references cannot be empty";
    messages[namedUnknown] = "Named character references must be known";
    messages[numericDisallowed] = "Numeric character references cannot be disallowed";
    messages[numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
    function parseEntities(value, options) {
      var settings = {};
      var option;
      var key;
      if (!options) {
        options = {};
      }
      for (key in defaults) {
        option = options[key];
        settings[key] = option === null || option === void 0 ? defaults[key] : option;
      }
      if (settings.position.indent || settings.position.start) {
        settings.indent = settings.position.indent || [];
        settings.position = settings.position.start;
      }
      return parse(value, settings);
    }
    function parse(value, settings) {
      var additional = settings.additional;
      var nonTerminated = settings.nonTerminated;
      var handleText = settings.text;
      var handleReference = settings.reference;
      var handleWarning = settings.warning;
      var textContext = settings.textContext;
      var referenceContext = settings.referenceContext;
      var warningContext = settings.warningContext;
      var pos = settings.position;
      var indent = settings.indent || [];
      var length2 = value.length;
      var index = 0;
      var lines = -1;
      var column = pos.column || 1;
      var line = pos.line || 1;
      var queue = "";
      var result = [];
      var entityCharacters;
      var namedEntity;
      var terminated;
      var characters;
      var character;
      var reference;
      var following;
      var warning;
      var reason;
      var output;
      var entity;
      var begin;
      var start;
      var type;
      var test;
      var prev;
      var next;
      var diff;
      var end;
      if (typeof additional === "string") {
        additional = additional.charCodeAt(0);
      }
      prev = now();
      warning = handleWarning ? parseError : noop;
      index--;
      length2++;
      while (++index < length2) {
        if (character === lineFeed) {
          column = indent[lines] || 1;
        }
        character = value.charCodeAt(index);
        if (character === ampersand) {
          following = value.charCodeAt(index + 1);
          if (following === tab || following === lineFeed || following === formFeed || following === space || following === ampersand || following === lessThan || following !== following || additional && following === additional) {
            queue += fromCharCode(character);
            column++;
            continue;
          }
          start = index + 1;
          begin = start;
          end = start;
          if (following === numberSign) {
            end = ++begin;
            following = value.charCodeAt(end);
            if (following === uppercaseX || following === lowercaseX) {
              type = hexa;
              end = ++begin;
            } else {
              type = deci;
            }
          } else {
            type = name;
          }
          entityCharacters = "";
          entity = "";
          characters = "";
          test = tests[type];
          end--;
          while (++end < length2) {
            following = value.charCodeAt(end);
            if (!test(following)) {
              break;
            }
            characters += fromCharCode(following);
            if (type === name && own.call(legacy, characters)) {
              entityCharacters = characters;
              entity = legacy[characters];
            }
          }
          terminated = value.charCodeAt(end) === semicolon;
          if (terminated) {
            end++;
            namedEntity = type === name ? decodeEntity(characters) : false;
            if (namedEntity) {
              entityCharacters = characters;
              entity = namedEntity;
            }
          }
          diff = 1 + end - start;
          if (!terminated && !nonTerminated) {
          } else if (!characters) {
            if (type !== name) {
              warning(numericEmpty, diff);
            }
          } else if (type === name) {
            if (terminated && !entity) {
              warning(namedUnknown, 1);
            } else {
              if (entityCharacters !== characters) {
                end = begin + entityCharacters.length;
                diff = 1 + end - begin;
                terminated = false;
              }
              if (!terminated) {
                reason = entityCharacters ? namedNotTerminated : namedEmpty;
                if (settings.attribute) {
                  following = value.charCodeAt(end);
                  if (following === equalsTo) {
                    warning(reason, diff);
                    entity = null;
                  } else if (alphanumerical(following)) {
                    entity = null;
                  } else {
                    warning(reason, diff);
                  }
                } else {
                  warning(reason, diff);
                }
              }
            }
            reference = entity;
          } else {
            if (!terminated) {
              warning(numericNotTerminated, diff);
            }
            reference = parseInt(characters, bases[type]);
            if (prohibited(reference)) {
              warning(numericProhibited, diff);
              reference = fromCharCode(replacementCharacter);
            } else if (reference in invalid) {
              warning(numericDisallowed, diff);
              reference = invalid[reference];
            } else {
              output = "";
              if (disallowed(reference)) {
                warning(numericDisallowed, diff);
              }
              if (reference > 65535) {
                reference -= 65536;
                output += fromCharCode(reference >>> (10 & 1023) | 55296);
                reference = 56320 | reference & 1023;
              }
              reference = output + fromCharCode(reference);
            }
          }
          if (reference) {
            flush();
            prev = now();
            index = end - 1;
            column += end - start + 1;
            result.push(reference);
            next = now();
            next.offset++;
            if (handleReference) {
              handleReference.call(
                referenceContext,
                reference,
                { start: prev, end: next },
                value.slice(start - 1, end)
              );
            }
            prev = next;
          } else {
            characters = value.slice(start - 1, end);
            queue += characters;
            column += characters.length;
            index = end - 1;
          }
        } else {
          if (character === 10) {
            line++;
            lines++;
            column = 0;
          }
          if (character === character) {
            queue += fromCharCode(character);
            column++;
          } else {
            flush();
          }
        }
      }
      return result.join("");
      function now() {
        return {
          line,
          column,
          offset: index + (pos.offset || 0)
        };
      }
      function parseError(code, offset) {
        var position = now();
        position.column += offset;
        position.offset += offset;
        handleWarning.call(warningContext, messages[code], position, code);
      }
      function flush() {
        if (queue) {
          result.push(queue);
          if (handleText) {
            handleText.call(textContext, queue, { start: prev, end: now() });
          }
          queue = "";
        }
      }
    }
    function prohibited(code) {
      return code >= 55296 && code <= 57343 || code > 1114111;
    }
    function disallowed(code) {
      return code >= 1 && code <= 8 || code === 11 || code >= 13 && code <= 31 || code >= 127 && code <= 159 || code >= 64976 && code <= 65007 || (code & 65535) === 65535 || (code & 65535) === 65534;
    }
  }
});

// ../../node_modules/refractor/node_modules/prismjs/components/prism-core.js
var require_prism_core = __commonJS({
  "../../node_modules/refractor/node_modules/prismjs/components/prism-core.js"(exports, module2) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism = function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _ = {
        manual: _self2.Prism && _self2.Prism.manual,
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone;
            var id;
            switch (_.util.type(o)) {
              case "Object":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = {};
                visited[id] = clone;
                for (var key in o) {
                  if (o.hasOwnProperty(key)) {
                    clone[key] = deepClone(o[key], visited);
                  }
                }
                return clone;
              case "Array":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = [];
                visited[id] = clone;
                o.forEach(function(v, i) {
                  clone[i] = deepClone(v, visited);
                });
                return clone;
              default:
                return o;
            }
          },
          getLanguage: function(element) {
            while (element) {
              var m = lang.exec(element.className);
              if (m) {
                return m[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if ("currentScript" in document && 1 < 2) {
              return document.currentScript;
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i in scripts) {
                  if (scripts[i].src == src) {
                    return scripts[i];
                  }
                }
              }
              return null;
            }
          },
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        languages: {
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          extend: function(id, redef) {
            var lang2 = _.util.clone(_.languages[id]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          insertBefore: function(inside, before, insert, root) {
            root = root || _.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _.languages.DFS(_.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          DFS: function DFS(o, callback, type, visited) {
            visited = visited || {};
            var objId = _.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type || i);
                var property = o[i];
                var propertyType = _.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        highlightAll: function(async, callback) {
          _.highlightAllUnder(document, async, callback);
        },
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _.hooks.run("before-all-elements-highlight", env);
          for (var i = 0, element; element = env.elements[i++]; ) {
            _.highlightElement(element, async === true, env.callback);
          }
        },
        highlightElement: function(element, async, callback) {
          var language = _.util.getLanguage(element);
          var grammar = _.languages[language];
          _.util.setLanguage(element, language);
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _.util.setLanguage(parent, language);
          }
          var code = element.textContent;
          var env = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _.hooks.run("after-highlight", env);
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
          }
        },
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _.tokenize(env.code, env.grammar);
          _.hooks.run("after-tokenize", env);
          return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        hooks: {
          all: {},
          add: function(name, callback) {
            var hooks = _.hooks.all;
            hooks[name] = hooks[name] || [];
            hooks[name].push(callback);
          },
          run: function(name, env) {
            var callbacks = _.hooks.all[name];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      _self2.Prism = _;
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s = "";
          o.forEach(function(e) {
            s += stringify(e, language);
          });
          return s;
        }
        var env = {
          type: o.type,
          content: stringify(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) {
          attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token + "," + j) {
              return;
            }
            var patternObj = patterns[j];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text, lookbehind);
                if (!match || match.index >= text.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p = pos;
                p += currentNode.value.length;
                while (from >= p) {
                  currentNode = currentNode.next;
                  p += currentNode.value.length;
                }
                p -= currentNode.value.length;
                pos = p;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                  removeCount++;
                  p += k.value.length;
                }
                removeCount--;
                str = text.slice(pos, p);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count) {
        var next = node.next;
        for (var i = 0; i < count && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _;
        }
        if (!_.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_.highlight(code, _.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _;
      }
      var script = _.util.currentScript();
      if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_.manual) {
          _.highlightAll();
        }
      }
      if (!_.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _;
    }(_self);
    if (typeof module2 !== "undefined" && module2.exports) {
      module2.exports = Prism;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism;
    }
  }
});

// ../../node_modules/refractor/lang/clike.js
var require_clike = __commonJS({
  "../../node_modules/refractor/lang/clike.js"(exports, module2) {
    "use strict";
    module2.exports = clike;
    clike.displayName = "clike";
    clike.aliases = [];
    function clike(Prism) {
      Prism.languages.clike = {
        comment: [
          {
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        string: {
          pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          greedy: true
        },
        "class-name": {
          pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
          lookbehind: true,
          inside: {
            punctuation: /[.\\]/
          }
        },
        keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
        boolean: /\b(?:false|true)\b/,
        function: /\b\w+(?=\()/,
        number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
        punctuation: /[{}[\];(),.:]/
      };
    }
  }
});

// ../../node_modules/refractor/lang/javascript.js
var require_javascript = __commonJS({
  "../../node_modules/refractor/lang/javascript.js"(exports, module2) {
    "use strict";
    module2.exports = javascript;
    javascript.displayName = "javascript";
    javascript.aliases = ["js"];
    function javascript(Prism) {
      Prism.languages.javascript = Prism.languages.extend("clike", {
        "class-name": [
          Prism.languages.clike["class-name"],
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
            lookbehind: true
          }
        ],
        keyword: [
          {
            pattern: /((?:^|\})\s*)catch\b/,
            lookbehind: true
          },
          {
            pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
            lookbehind: true
          }
        ],
        function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
        number: {
          pattern: RegExp(
            /(^|[^\w$])/.source + "(?:" + (/NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
          ),
          lookbehind: true
        },
        operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
      });
      Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
      Prism.languages.insertBefore("javascript", "keyword", {
        regex: {
          pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
          lookbehind: true,
          greedy: true,
          inside: {
            "regex-source": {
              pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
              lookbehind: true,
              alias: "language-regex",
              inside: Prism.languages.regex
            },
            "regex-delimiter": /^\/|\/$/,
            "regex-flags": /^[a-z]+$/
          }
        },
        "function-variable": {
          pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
          alias: "function"
        },
        parameter: [
          {
            pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
            lookbehind: true,
            inside: Prism.languages.javascript
          },
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
            lookbehind: true,
            inside: Prism.languages.javascript
          },
          {
            pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
            lookbehind: true,
            inside: Prism.languages.javascript
          },
          {
            pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
            lookbehind: true,
            inside: Prism.languages.javascript
          }
        ],
        constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
      });
      Prism.languages.insertBefore("javascript", "string", {
        hashbang: {
          pattern: /^#!.*/,
          greedy: true,
          alias: "comment"
        },
        "template-string": {
          pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
          greedy: true,
          inside: {
            "template-punctuation": {
              pattern: /^`|`$/,
              alias: "string"
            },
            interpolation: {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
              lookbehind: true,
              inside: {
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                },
                rest: Prism.languages.javascript
              }
            },
            string: /[\s\S]+/
          }
        },
        "string-property": {
          pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
          lookbehind: true,
          greedy: true,
          alias: "property"
        }
      });
      Prism.languages.insertBefore("javascript", "operator", {
        "literal-property": {
          pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
          lookbehind: true,
          alias: "property"
        }
      });
      if (Prism.languages.markup) {
        Prism.languages.markup.tag.addInlined("script", "javascript");
        Prism.languages.markup.tag.addAttribute(
          /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
          "javascript"
        );
      }
      Prism.languages.js = Prism.languages.javascript;
    }
  }
});

// ../../node_modules/refractor/core.js
var require_core = __commonJS({
  "../../node_modules/refractor/core.js"(exports, module2) {
    "use strict";
    var ctx = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};
    var restore = capture();
    ctx.Prism = { manual: true, disableWorkerMessageHandler: true };
    var h = require_hastscript();
    var decode = require_parse_entities();
    var Prism = require_prism_core();
    var markup2 = require_markup();
    var css2 = require_css();
    var clike = require_clike();
    var js = require_javascript();
    restore();
    var own = {}.hasOwnProperty;
    function Refractor() {
    }
    Refractor.prototype = Prism;
    var refract = new Refractor();
    module2.exports = refract;
    refract.highlight = highlight;
    refract.register = register;
    refract.alias = alias;
    refract.registered = registered;
    refract.listLanguages = listLanguages;
    register(markup2);
    register(css2);
    register(clike);
    register(js);
    refract.util.encode = encode;
    refract.Token.stringify = stringify;
    function register(grammar) {
      if (typeof grammar !== "function" || !grammar.displayName) {
        throw new Error("Expected `function` for `grammar`, got `" + grammar + "`");
      }
      if (refract.languages[grammar.displayName] === void 0) {
        grammar(refract);
      }
    }
    function alias(name, alias2) {
      var languages = refract.languages;
      var map = name;
      var key;
      var list;
      var length2;
      var index;
      if (alias2) {
        map = {};
        map[name] = alias2;
      }
      for (key in map) {
        list = map[key];
        list = typeof list === "string" ? [list] : list;
        length2 = list.length;
        index = -1;
        while (++index < length2) {
          languages[list[index]] = languages[key];
        }
      }
    }
    function highlight(value, name) {
      var sup = Prism.highlight;
      var grammar;
      if (typeof value !== "string") {
        throw new Error("Expected `string` for `value`, got `" + value + "`");
      }
      if (refract.util.type(name) === "Object") {
        grammar = name;
        name = null;
      } else {
        if (typeof name !== "string") {
          throw new Error("Expected `string` for `name`, got `" + name + "`");
        }
        if (own.call(refract.languages, name)) {
          grammar = refract.languages[name];
        } else {
          throw new Error("Unknown language: `" + name + "` is not registered");
        }
      }
      return sup.call(this, value, grammar, name);
    }
    function registered(language) {
      if (typeof language !== "string") {
        throw new Error("Expected `string` for `language`, got `" + language + "`");
      }
      return own.call(refract.languages, language);
    }
    function listLanguages() {
      var languages = refract.languages;
      var list = [];
      var language;
      for (language in languages) {
        if (own.call(languages, language) && typeof languages[language] === "object") {
          list.push(language);
        }
      }
      return list;
    }
    function stringify(value, language, parent) {
      var env;
      if (typeof value === "string") {
        return { type: "text", value };
      }
      if (refract.util.type(value) === "Array") {
        return stringifyAll(value, language);
      }
      env = {
        type: value.type,
        content: refract.Token.stringify(value.content, language, parent),
        tag: "span",
        classes: ["token", value.type],
        attributes: {},
        language,
        parent
      };
      if (value.alias) {
        env.classes = env.classes.concat(value.alias);
      }
      refract.hooks.run("wrap", env);
      return h(
        env.tag + "." + env.classes.join("."),
        attributes(env.attributes),
        env.content
      );
    }
    function stringifyAll(values, language) {
      var result = [];
      var length2 = values.length;
      var index = -1;
      var value;
      while (++index < length2) {
        value = values[index];
        if (value !== "" && value !== null && value !== void 0) {
          result.push(value);
        }
      }
      index = -1;
      length2 = result.length;
      while (++index < length2) {
        value = result[index];
        result[index] = refract.Token.stringify(value, language, result);
      }
      return result;
    }
    function encode(tokens) {
      return tokens;
    }
    function attributes(attrs) {
      var key;
      for (key in attrs) {
        attrs[key] = decode(attrs[key]);
      }
      return attrs;
    }
    function capture() {
      var defined = "Prism" in ctx;
      var current = defined ? ctx.Prism : void 0;
      return restore2;
      function restore2() {
        if (defined) {
          ctx.Prism = current;
        } else {
          delete ctx.Prism;
        }
        defined = void 0;
        current = void 0;
      }
    }
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/prism-light.js
var import_core, SyntaxHighlighter, prism_light_default;
var init_prism_light = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/prism-light.js"() {
    init_highlight();
    import_core = __toESM(require_core());
    SyntaxHighlighter = highlight_default(import_core.default, {});
    SyntaxHighlighter.registerLanguage = function(_, language) {
      return import_core.default.register(language);
    };
    SyntaxHighlighter.alias = function(name, aliases) {
      return import_core.default.alias(name, aliases);
    };
    prism_light_default = SyntaxHighlighter;
  }
});

// ../../node_modules/react-syntax-highlighter/dist/esm/index.js
var init_esm2 = __esm({
  "../../node_modules/react-syntax-highlighter/dist/esm/index.js"() {
    init_create_element();
  }
});

// src/ActionBar/ActionBar.tsx
var import_react4, import_theming3, Container, ActionButton, ActionBar;
var init_ActionBar = __esm({
  "src/ActionBar/ActionBar.tsx"() {
    import_react4 = __toESM(require("react"));
    import_theming3 = require("@storybook/theming");
    Container = import_theming3.styled.div(({ theme }) => ({
      position: "absolute",
      bottom: 0,
      right: 0,
      maxWidth: "100%",
      display: "flex",
      background: theme.background.content,
      zIndex: 1
    }));
    ActionButton = import_theming3.styled.button(
      ({ theme }) => ({
        margin: 0,
        border: "0 none",
        padding: "4px 10px",
        cursor: "pointer",
        display: "flex",
        alignItems: "center",
        color: theme.color.defaultText,
        background: theme.background.content,
        fontSize: 12,
        lineHeight: "16px",
        fontFamily: theme.typography.fonts.base,
        fontWeight: theme.typography.weight.bold,
        borderTop: `1px solid ${theme.appBorderColor}`,
        borderLeft: `1px solid ${theme.appBorderColor}`,
        marginLeft: -1,
        borderRadius: `4px 0 0 0`,
        "&:not(:last-child)": { borderRight: `1px solid ${theme.appBorderColor}` },
        "& + *": {
          borderLeft: `1px solid ${theme.appBorderColor}`,
          borderRadius: 0
        },
        "&:focus": {
          boxShadow: `${theme.color.secondary} 0 -3px 0 0 inset`,
          outline: "0 none"
        }
      }),
      ({ disabled }) => disabled && {
        cursor: "not-allowed",
        opacity: 0.5
      }
    );
    ActionButton.displayName = "ActionButton";
    ActionBar = ({ actionItems, ...props }) => /* @__PURE__ */ import_react4.default.createElement(Container, {
      ...props
    }, actionItems.map(({ title, className, onClick, disabled }, index) => /* @__PURE__ */ import_react4.default.createElement(ActionButton, {
      key: index,
      className,
      onClick,
      disabled
    }, title)));
  }
});

// src/ScrollArea/GlobalScrollAreaStyles.tsx
var GlobalScrollAreaStyles_exports = {};
__export(GlobalScrollAreaStyles_exports, {
  default: () => GlobalScrollAreaStyles_default,
  getScrollAreaStyles: () => getScrollAreaStyles
});
var import_react5, import_theming4, hsResizeObserverDummyAnimation, getScrollAreaStyles, GlobalScrollAreaStyles, GlobalScrollAreaStyles_default;
var init_GlobalScrollAreaStyles = __esm({
  "src/ScrollArea/GlobalScrollAreaStyles.tsx"() {
    import_react5 = __toESM(require("react"));
    import_theming4 = require("@storybook/theming");
    hsResizeObserverDummyAnimation = import_theming4.keyframes`0%{z-index:0}to{z-index:-1}`;
    getScrollAreaStyles = (theme) => ({
      "html.os-html, html.os-html>.os-host": {
        display: "block",
        overflow: "hidden",
        boxSizing: "border-box",
        height: "100%!important",
        width: "100%!important",
        minWidth: "100%!important",
        minHeight: "100%!important",
        margin: "0!important",
        position: "absolute!important"
      },
      "html.os-html>.os-host>.os-padding": {
        position: "absolute"
      },
      "body.os-dragging, body.os-dragging *": {
        cursor: "default"
      },
      ".os-host, .os-host-textarea": {
        position: "relative",
        overflow: "visible!important",
        flexDirection: "column",
        flexWrap: "nowrap",
        justifyContent: "flex-start",
        alignContent: "flex-start",
        alignItems: "flex-start"
      },
      ".os-host-flexbox": {
        overflow: "hidden!important",
        display: "flex"
      },
      ".os-host-flexbox>.os-size-auto-observer": {
        height: "inherit!important"
      },
      ".os-host-flexbox>.os-content-glue": {
        flexGrow: 1,
        flexShrink: 0
      },
      ".os-host-flexbox>.os-size-auto-observer, .os-host-flexbox>.os-content-glue": {
        minHeight: 0,
        minWidth: 0,
        flexGrow: 0,
        flexShrink: 1,
        flexBasis: "auto"
      },
      "#os-dummy-scrollbar-size": {
        position: "fixed",
        opacity: 0,
        visibility: "hidden",
        overflow: "scroll",
        height: 500,
        width: 500
      },
      "#os-dummy-scrollbar-size>div": {
        width: "200%",
        height: "200%",
        margin: 10
      },
      "#os-dummy-scrollbar-size, .os-viewport": {},
      ".os-viewport-native-scrollbars-invisible#os-dummy-scrollbar-size, .os-viewport-native-scrollbars-invisible.os-viewport": {
        scrollbarWidth: "none!important"
      },
      ".os-viewport-native-scrollbars-invisible#os-dummy-scrollbar-size::-webkit-scrollbar, .os-viewport-native-scrollbars-invisible.os-viewport::-webkit-scrollbar, .os-viewport-native-scrollbars-invisible#os-dummy-scrollbar-size::-webkit-scrollbar-corner, .os-viewport-native-scrollbars-invisible.os-viewport::-webkit-scrollbar-corner": {
        display: "none!important",
        width: "0!important",
        height: "0!important",
        visibility: "hidden!important",
        background: "0 0!important"
      },
      ".os-content-glue": {
        boxSizing: "inherit",
        maxHeight: "100%",
        maxWidth: "100%",
        width: "100%",
        pointerEvents: "none"
      },
      ".os-padding": {
        boxSizing: "inherit",
        direction: "inherit",
        position: "absolute",
        overflow: "visible",
        padding: 0,
        margin: 0,
        left: 0,
        top: 0,
        bottom: 0,
        right: 0,
        width: "auto!important",
        height: "auto!important",
        zIndex: 1
      },
      ".os-host-overflow>.os-padding": {
        overflow: "hidden"
      },
      ".os-viewport": {
        direction: "inherit!important",
        boxSizing: "inherit!important",
        resize: "none!important",
        outline: "0!important",
        position: "absolute",
        overflow: "hidden",
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        padding: 0,
        margin: 0
      },
      ".os-content-arrange": {
        position: "absolute",
        zIndex: -1,
        minHeight: 1,
        minWidth: 1,
        pointerEvents: "none"
      },
      ".os-content": {
        direction: "inherit",
        boxSizing: "border-box!important",
        position: "relative",
        display: "block",
        height: "100%",
        width: "100%",
        visibility: "visible"
      },
      ".os-content:before, .os-content:after": {
        content: "''",
        display: "table",
        width: 0,
        height: 0,
        lineHeight: 0,
        fontSize: 0
      },
      ".os-content>.os-textarea": {
        boxSizing: "border-box!important",
        direction: "inherit!important",
        background: "0 0!important",
        outline: "0 transparent!important",
        overflow: "hidden!important",
        position: "absolute!important",
        display: "block!important",
        top: "0!important",
        left: "0!important",
        margin: "0!important",
        borderRadius: "0!important",
        float: "none!important",
        filter: "none!important",
        border: "0!important",
        resize: "none!important",
        transform: "none!important",
        maxWidth: "none!important",
        maxHeight: "none!important",
        boxShadow: "none!important",
        perspective: "none!important",
        opacity: "1!important",
        zIndex: "1!important",
        clip: "auto!important",
        verticalAlign: "baseline!important",
        padding: 0
      },
      ".os-host-rtl>.os-padding>.os-viewport>.os-content>.os-textarea": {
        right: "0!important"
      },
      ".os-content>.os-textarea-cover": {
        zIndex: -1,
        pointerEvents: "none"
      },
      ".os-content>.os-textarea[wrap=off]": {
        whiteSpace: "pre!important",
        margin: "0!important"
      },
      ".os-text-inherit": {
        fontFamily: "inherit",
        fontSize: "inherit",
        fontWeight: "inherit",
        fontStyle: "inherit",
        fontVariant: "inherit",
        textTransform: "inherit",
        textDecoration: "inherit",
        textIndent: "inherit",
        textAlign: "inherit",
        textShadow: "inherit",
        textOverflow: "inherit",
        letterSpacing: "inherit",
        wordSpacing: "inherit",
        lineHeight: "inherit",
        unicodeBidi: "inherit",
        direction: "inherit",
        color: "inherit",
        cursor: "text"
      },
      ".os-resize-observer, .os-resize-observer-host": {
        boxSizing: "inherit",
        display: "block",
        opacity: 0,
        position: "absolute",
        top: 0,
        left: 0,
        height: "100%",
        width: "100%",
        overflow: "hidden",
        pointerEvents: "none",
        zIndex: -1
      },
      ".os-resize-observer-host": {
        padding: "inherit",
        border: "inherit",
        borderColor: "transparent",
        borderStyle: "solid",
        boxSizing: "border-box"
      },
      ".os-resize-observer-host:after": {
        content: "''"
      },
      ".os-resize-observer-host>.os-resize-observer, .os-resize-observer-host:after": {
        height: "200%",
        width: "200%",
        padding: "inherit",
        border: "inherit",
        margin: 0,
        display: "block",
        boxSizing: "content-box"
      },
      ".os-resize-observer.observed, object.os-resize-observer": {
        boxSizing: "border-box!important"
      },
      ".os-size-auto-observer": {
        boxSizing: "inherit!important",
        height: "100%",
        width: "inherit",
        maxWidth: 1,
        position: "relative",
        float: "left",
        maxHeight: 1,
        overflow: "hidden",
        zIndex: -1,
        padding: 0,
        margin: 0,
        pointerEvents: "none",
        flexGrow: "inherit",
        flexShrink: 0,
        flexBasis: 0
      },
      ".os-size-auto-observer>.os-resize-observer": {
        width: "1000%",
        height: "1000%",
        minHeight: 1,
        minWidth: 1
      },
      ".os-resize-observer-item": {
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        overflow: "hidden",
        zIndex: -1,
        opacity: 0,
        direction: "ltr!important",
        flex: "none!important"
      },
      ".os-resize-observer-item-final": {
        position: "absolute",
        left: 0,
        top: 0,
        transition: "none!important",
        flex: "none!important"
      },
      ".os-resize-observer": {
        animationDuration: ".001s",
        animationName: `${hsResizeObserverDummyAnimation}`
      },
      ".os-host-transition>.os-scrollbar, .os-host-transition>.os-scrollbar-corner": {
        transition: "opacity .3s,visibility .3s,top .3s,right .3s,bottom .3s,left .3s"
      },
      "html.os-html>.os-host>.os-scrollbar": {
        position: "absolute",
        zIndex: 999999
      },
      ".os-scrollbar, .os-scrollbar-corner": {
        position: "absolute",
        opacity: 1,
        zIndex: 1
      },
      ".os-scrollbar-corner": {
        bottom: 0,
        right: 0,
        height: 10,
        width: 10,
        backgroundColor: "transparent"
      },
      ".os-scrollbar": {
        pointerEvents: "none",
        padding: 2,
        boxSizing: "border-box",
        background: 0
      },
      ".os-scrollbar-track": {
        pointerEvents: "auto",
        position: "relative",
        height: "100%",
        width: "100%",
        padding: "0!important",
        border: "0!important"
      },
      ".os-scrollbar-handle": {
        pointerEvents: "auto",
        position: "absolute",
        width: "100%",
        height: "100%"
      },
      ".os-scrollbar-handle-off, .os-scrollbar-track-off": {
        pointerEvents: "none"
      },
      ".os-scrollbar.os-scrollbar-unusable, .os-scrollbar.os-scrollbar-unusable *": {
        pointerEvents: "none!important"
      },
      ".os-scrollbar.os-scrollbar-unusable .os-scrollbar-handle": {
        opacity: "0!important"
      },
      ".os-scrollbar-horizontal": {
        bottom: 0,
        left: 0,
        right: 10,
        height: 10
      },
      ".os-scrollbar-vertical": {
        top: 0,
        right: 0,
        bottom: 10,
        width: 10
      },
      ".os-host-rtl>.os-scrollbar-horizontal": {
        right: 0
      },
      ".os-host-rtl>.os-scrollbar-vertical": {
        right: "auto",
        left: 0
      },
      ".os-host-rtl>.os-scrollbar-corner": {
        right: "auto",
        left: 0
      },
      ".os-scrollbar-auto-hidden, .os-padding+.os-scrollbar-corner, .os-host-resize-disabled.os-host-scrollbar-horizontal-hidden>.os-scrollbar-corner, .os-host-scrollbar-horizontal-hidden>.os-scrollbar-horizontal, .os-host-resize-disabled.os-host-scrollbar-vertical-hidden>.os-scrollbar-corner, .os-host-scrollbar-vertical-hidden>.os-scrollbar-vertical, .os-scrollbar-horizontal.os-scrollbar-auto-hidden+.os-scrollbar-vertical+.os-scrollbar-corner, .os-scrollbar-horizontal+.os-scrollbar-vertical.os-scrollbar-auto-hidden+.os-scrollbar-corner, .os-scrollbar-horizontal.os-scrollbar-auto-hidden+.os-scrollbar-vertical.os-scrollbar-auto-hidden+.os-scrollbar-corner": {
        opacity: 0,
        visibility: "hidden",
        pointerEvents: "none"
      },
      ".os-scrollbar-corner-resize-both": {
        cursor: "nwse-resize"
      },
      ".os-host-rtl>.os-scrollbar-corner-resize-both": {
        cursor: "nesw-resize"
      },
      ".os-scrollbar-corner-resize-horizontal": {
        cursor: "ew-resize"
      },
      ".os-scrollbar-corner-resize-vertical": {
        cursor: "ns-resize"
      },
      ".os-dragging .os-scrollbar-corner.os-scrollbar-corner-resize": {
        cursor: "default"
      },
      ".os-host-resize-disabled.os-host-scrollbar-horizontal-hidden>.os-scrollbar-vertical": {
        top: 0,
        bottom: 0
      },
      ".os-host-resize-disabled.os-host-scrollbar-vertical-hidden>.os-scrollbar-horizontal, .os-host-rtl.os-host-resize-disabled.os-host-scrollbar-vertical-hidden>.os-scrollbar-horizontal": {
        right: 0,
        left: 0
      },
      ".os-scrollbar:hover, .os-scrollbar-corner.os-scrollbar-corner-resize": {
        opacity: "1!important",
        visibility: "visible!important"
      },
      ".os-scrollbar-corner.os-scrollbar-corner-resize": {
        backgroundImage: "linear-gradient(135deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0)  50%, rgba(0,0,0,0.4) 50%, rgba(0,0,0,0.4) 100%)",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "100% 100%",
        pointerEvents: "auto!important"
      },
      ".os-host-rtl>.os-scrollbar-corner.os-scrollbar-corner-resize": {
        transform: "scale(-1,1)"
      },
      ".os-host-overflow": {
        overflow: "hidden!important"
      },
      ".os-theme-dark.os-host-rtl>.os-scrollbar-horizontal": {
        left: 10,
        right: 0
      },
      ".os-scrollbar.os-scrollbar-unusable": {
        background: 0
      },
      ".os-scrollbar>.os-scrollbar-track": {
        background: 0
      },
      ".os-scrollbar-horizontal>.os-scrollbar-track>.os-scrollbar-handle": {
        minWidth: 30
      },
      ".os-scrollbar-vertical>.os-scrollbar-track>.os-scrollbar-handle": {
        minHeight: 30
      },
      ".os-theme-dark.os-host-transition>.os-scrollbar>.os-scrollbar-track>.os-scrollbar-handle": {
        transition: "background-color .3s"
      },
      ".os-scrollbar>.os-scrollbar-track>.os-scrollbar-handle, .os-scrollbar>.os-scrollbar-track": {
        borderRadius: 10
      },
      ".os-scrollbar>.os-scrollbar-track>.os-scrollbar-handle": {
        background: theme.textMutedColor,
        opacity: 0.5
      },
      ".os-scrollbar:hover>.os-scrollbar-track>.os-scrollbar-handle": {
        opacity: 0.6
      },
      ".os-scrollbar-horizontal .os-scrollbar-handle:before, .os-scrollbar-vertical .os-scrollbar-handle:before": {
        content: "''",
        position: "absolute",
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        display: "block"
      },
      ".os-theme-dark.os-host-scrollbar-horizontal-hidden>.os-scrollbar-horizontal .os-scrollbar-handle:before, .os-theme-dark.os-host-scrollbar-vertical-hidden>.os-scrollbar-vertical .os-scrollbar-handle:before": {
        display: "none"
      },
      ".os-scrollbar-horizontal .os-scrollbar-handle:before": {
        top: -6,
        bottom: -2
      },
      ".os-scrollbar-vertical .os-scrollbar-handle:before": {
        left: -6,
        right: -2
      },
      ".os-host-rtl.os-scrollbar-vertical .os-scrollbar-handle:before": {
        right: -6,
        left: -2
      }
    });
    GlobalScrollAreaStyles = () => /* @__PURE__ */ import_react5.default.createElement(import_theming4.Global, {
      styles: getScrollAreaStyles
    });
    GlobalScrollAreaStyles_default = GlobalScrollAreaStyles;
  }
});

// ../../node_modules/overlayscrollbars/js/OverlayScrollbars.js
var require_OverlayScrollbars = __commonJS({
  "../../node_modules/overlayscrollbars/js/OverlayScrollbars.js"(exports, module2) {
    (function(global3, factory) {
      if (typeof define === "function" && define.amd)
        define(function() {
          return factory(global3, global3.document, void 0);
        });
      else if (typeof module2 === "object" && typeof module2.exports === "object")
        module2.exports = factory(global3, global3.document, void 0);
      else
        factory(global3, global3.document, void 0);
    })(
      typeof window !== "undefined" ? window : exports,
      function(window2, document3, undefined2) {
        "use strict";
        var PLUGINNAME = "OverlayScrollbars";
        var TYPES = {
          o: "object",
          f: "function",
          a: "array",
          s: "string",
          b: "boolean",
          n: "number",
          u: "undefined",
          z: "null"
        };
        var LEXICON = {
          c: "class",
          s: "style",
          i: "id",
          l: "length",
          p: "prototype",
          ti: "tabindex",
          oH: "offsetHeight",
          cH: "clientHeight",
          sH: "scrollHeight",
          oW: "offsetWidth",
          cW: "clientWidth",
          sW: "scrollWidth",
          hOP: "hasOwnProperty",
          bCR: "getBoundingClientRect"
        };
        var VENDORS = function() {
          var jsCache = {};
          var cssCache = {};
          var cssPrefixes = ["-webkit-", "-moz-", "-o-", "-ms-"];
          var jsPrefixes = ["WebKit", "Moz", "O", "MS"];
          function firstLetterToUpper(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
          }
          return {
            _cssPrefixes: cssPrefixes,
            _jsPrefixes: jsPrefixes,
            _cssProperty: function(name) {
              var result = cssCache[name];
              if (cssCache[LEXICON.hOP](name))
                return result;
              var uppercasedName = firstLetterToUpper(name);
              var elmStyle = document3.createElement("div")[LEXICON.s];
              var resultPossibilities;
              var i = 0;
              var v;
              var currVendorWithoutDashes;
              for (; i < cssPrefixes.length; i++) {
                currVendorWithoutDashes = cssPrefixes[i].replace(/-/g, "");
                resultPossibilities = [
                  name,
                  cssPrefixes[i] + name,
                  currVendorWithoutDashes + uppercasedName,
                  firstLetterToUpper(currVendorWithoutDashes) + uppercasedName
                ];
                for (v = 0; v < resultPossibilities[LEXICON.l]; v++) {
                  if (elmStyle[resultPossibilities[v]] !== undefined2) {
                    result = resultPossibilities[v];
                    break;
                  }
                }
              }
              cssCache[name] = result;
              return result;
            },
            _cssPropertyValue: function(property, values, suffix) {
              var name = property + " " + values;
              var result = cssCache[name];
              if (cssCache[LEXICON.hOP](name))
                return result;
              var dummyStyle = document3.createElement("div")[LEXICON.s];
              var possbleValues = values.split(" ");
              var preparedSuffix = suffix || "";
              var i = 0;
              var v = -1;
              var prop;
              for (; i < possbleValues[LEXICON.l]; i++) {
                for (; v < VENDORS._cssPrefixes[LEXICON.l]; v++) {
                  prop = v < 0 ? possbleValues[i] : VENDORS._cssPrefixes[v] + possbleValues[i];
                  dummyStyle.cssText = property + ":" + prop + preparedSuffix;
                  if (dummyStyle[LEXICON.l]) {
                    result = prop;
                    break;
                  }
                }
              }
              cssCache[name] = result;
              return result;
            },
            _jsAPI: function(name, isInterface, fallback) {
              var i = 0;
              var result = jsCache[name];
              if (!jsCache[LEXICON.hOP](name)) {
                result = window2[name];
                for (; i < jsPrefixes[LEXICON.l]; i++)
                  result = result || window2[(isInterface ? jsPrefixes[i] : jsPrefixes[i].toLowerCase()) + firstLetterToUpper(name)];
                jsCache[name] = result;
              }
              return result || fallback;
            }
          };
        }();
        var COMPATIBILITY = function() {
          function windowSize(x) {
            return x ? window2.innerWidth || document3.documentElement[LEXICON.cW] || document3.body[LEXICON.cW] : window2.innerHeight || document3.documentElement[LEXICON.cH] || document3.body[LEXICON.cH];
          }
          function bind(func, thisObj) {
            if (typeof func != TYPES.f) {
              throw "Can't bind function!";
            }
            var proto = LEXICON.p;
            var aArgs = Array[proto].slice.call(arguments, 2);
            var fNOP = function() {
            };
            var fBound = function() {
              return func.apply(this instanceof fNOP ? this : thisObj, aArgs.concat(Array[proto].slice.call(arguments)));
            };
            if (func[proto])
              fNOP[proto] = func[proto];
            fBound[proto] = new fNOP();
            return fBound;
          }
          return {
            wW: bind(windowSize, 0, true),
            wH: bind(windowSize, 0),
            mO: bind(VENDORS._jsAPI, 0, "MutationObserver", true),
            rO: bind(VENDORS._jsAPI, 0, "ResizeObserver", true),
            rAF: bind(VENDORS._jsAPI, 0, "requestAnimationFrame", false, function(func) {
              return window2.setTimeout(func, 1e3 / 60);
            }),
            cAF: bind(VENDORS._jsAPI, 0, "cancelAnimationFrame", false, function(id) {
              return window2.clearTimeout(id);
            }),
            now: function() {
              return Date.now && Date.now() || new Date().getTime();
            },
            stpP: function(event) {
              if (event.stopPropagation)
                event.stopPropagation();
              else
                event.cancelBubble = true;
            },
            prvD: function(event) {
              if (event.preventDefault && event.cancelable)
                event.preventDefault();
              else
                event.returnValue = false;
            },
            page: function(event) {
              event = event.originalEvent || event;
              var strPage = "page";
              var strClient = "client";
              var strX = "X";
              var strY = "Y";
              var target = event.target || event.srcElement || document3;
              var eventDoc = target.ownerDocument || document3;
              var doc = eventDoc.documentElement;
              var body = eventDoc.body;
              if (event.touches !== undefined2) {
                var touch = event.touches[0];
                return {
                  x: touch[strPage + strX],
                  y: touch[strPage + strY]
                };
              }
              if (!event[strPage + strX] && event[strClient + strX] && event[strClient + strX] != null) {
                return {
                  x: event[strClient + strX] + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0),
                  y: event[strClient + strY] + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)
                };
              }
              return {
                x: event[strPage + strX],
                y: event[strPage + strY]
              };
            },
            mBtn: function(event) {
              var button = event.button;
              if (!event.which && button !== undefined2)
                return button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
              else
                return event.which;
            },
            inA: function(item, arr) {
              for (var i = 0; i < arr[LEXICON.l]; i++)
                try {
                  if (arr[i] === item)
                    return i;
                } catch (e) {
                }
              return -1;
            },
            isA: function(arr) {
              var def = Array.isArray;
              return def ? def(arr) : this.type(arr) == TYPES.a;
            },
            type: function(obj) {
              if (obj === undefined2)
                return obj + "";
              if (obj === null)
                return obj + "";
              return Object[LEXICON.p].toString.call(obj).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
            },
            bind
          };
        }();
        var MATH = Math;
        var JQUERY = window2.jQuery;
        var EASING = function() {
          var _easingsMath = {
            p: MATH.PI,
            c: MATH.cos,
            s: MATH.sin,
            w: MATH.pow,
            t: MATH.sqrt,
            n: MATH.asin,
            a: MATH.abs,
            o: 1.70158
          };
          return {
            swing: function(x, t, b, c, d) {
              return 0.5 - _easingsMath.c(x * _easingsMath.p) / 2;
            },
            linear: function(x, t, b, c, d) {
              return x;
            },
            easeInQuad: function(x, t, b, c, d) {
              return c * (t /= d) * t + b;
            },
            easeOutQuad: function(x, t, b, c, d) {
              return -c * (t /= d) * (t - 2) + b;
            },
            easeInOutQuad: function(x, t, b, c, d) {
              return (t /= d / 2) < 1 ? c / 2 * t * t + b : -c / 2 * (--t * (t - 2) - 1) + b;
            },
            easeInCubic: function(x, t, b, c, d) {
              return c * (t /= d) * t * t + b;
            },
            easeOutCubic: function(x, t, b, c, d) {
              return c * ((t = t / d - 1) * t * t + 1) + b;
            },
            easeInOutCubic: function(x, t, b, c, d) {
              return (t /= d / 2) < 1 ? c / 2 * t * t * t + b : c / 2 * ((t -= 2) * t * t + 2) + b;
            },
            easeInQuart: function(x, t, b, c, d) {
              return c * (t /= d) * t * t * t + b;
            },
            easeOutQuart: function(x, t, b, c, d) {
              return -c * ((t = t / d - 1) * t * t * t - 1) + b;
            },
            easeInOutQuart: function(x, t, b, c, d) {
              return (t /= d / 2) < 1 ? c / 2 * t * t * t * t + b : -c / 2 * ((t -= 2) * t * t * t - 2) + b;
            },
            easeInQuint: function(x, t, b, c, d) {
              return c * (t /= d) * t * t * t * t + b;
            },
            easeOutQuint: function(x, t, b, c, d) {
              return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
            },
            easeInOutQuint: function(x, t, b, c, d) {
              return (t /= d / 2) < 1 ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
            },
            easeInSine: function(x, t, b, c, d) {
              return -c * _easingsMath.c(t / d * (_easingsMath.p / 2)) + c + b;
            },
            easeOutSine: function(x, t, b, c, d) {
              return c * _easingsMath.s(t / d * (_easingsMath.p / 2)) + b;
            },
            easeInOutSine: function(x, t, b, c, d) {
              return -c / 2 * (_easingsMath.c(_easingsMath.p * t / d) - 1) + b;
            },
            easeInExpo: function(x, t, b, c, d) {
              return t == 0 ? b : c * _easingsMath.w(2, 10 * (t / d - 1)) + b;
            },
            easeOutExpo: function(x, t, b, c, d) {
              return t == d ? b + c : c * (-_easingsMath.w(2, -10 * t / d) + 1) + b;
            },
            easeInOutExpo: function(x, t, b, c, d) {
              if (t == 0)
                return b;
              if (t == d)
                return b + c;
              if ((t /= d / 2) < 1)
                return c / 2 * _easingsMath.w(2, 10 * (t - 1)) + b;
              return c / 2 * (-_easingsMath.w(2, -10 * --t) + 2) + b;
            },
            easeInCirc: function(x, t, b, c, d) {
              return -c * (_easingsMath.t(1 - (t /= d) * t) - 1) + b;
            },
            easeOutCirc: function(x, t, b, c, d) {
              return c * _easingsMath.t(1 - (t = t / d - 1) * t) + b;
            },
            easeInOutCirc: function(x, t, b, c, d) {
              return (t /= d / 2) < 1 ? -c / 2 * (_easingsMath.t(1 - t * t) - 1) + b : c / 2 * (_easingsMath.t(1 - (t -= 2) * t) + 1) + b;
            },
            easeInElastic: function(x, t, b, c, d) {
              var s = _easingsMath.o;
              var p = 0;
              var a = c;
              if (t == 0)
                return b;
              if ((t /= d) == 1)
                return b + c;
              if (!p)
                p = d * 0.3;
              if (a < _easingsMath.a(c)) {
                a = c;
                s = p / 4;
              } else
                s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
              return -(a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;
            },
            easeOutElastic: function(x, t, b, c, d) {
              var s = _easingsMath.o;
              var p = 0;
              var a = c;
              if (t == 0)
                return b;
              if ((t /= d) == 1)
                return b + c;
              if (!p)
                p = d * 0.3;
              if (a < _easingsMath.a(c)) {
                a = c;
                s = p / 4;
              } else
                s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
              return a * _easingsMath.w(2, -10 * t) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) + c + b;
            },
            easeInOutElastic: function(x, t, b, c, d) {
              var s = _easingsMath.o;
              var p = 0;
              var a = c;
              if (t == 0)
                return b;
              if ((t /= d / 2) == 2)
                return b + c;
              if (!p)
                p = d * (0.3 * 1.5);
              if (a < _easingsMath.a(c)) {
                a = c;
                s = p / 4;
              } else
                s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
              if (t < 1)
                return -0.5 * (a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;
              return a * _easingsMath.w(2, -10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) * 0.5 + c + b;
            },
            easeInBack: function(x, t, b, c, d, s) {
              s = s || _easingsMath.o;
              return c * (t /= d) * t * ((s + 1) * t - s) + b;
            },
            easeOutBack: function(x, t, b, c, d, s) {
              s = s || _easingsMath.o;
              return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
            },
            easeInOutBack: function(x, t, b, c, d, s) {
              s = s || _easingsMath.o;
              return (t /= d / 2) < 1 ? c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b : c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
            },
            easeInBounce: function(x, t, b, c, d) {
              return c - this.easeOutBounce(x, d - t, 0, c, d) + b;
            },
            easeOutBounce: function(x, t, b, c, d) {
              var o = 7.5625;
              if ((t /= d) < 1 / 2.75) {
                return c * (o * t * t) + b;
              } else if (t < 2 / 2.75) {
                return c * (o * (t -= 1.5 / 2.75) * t + 0.75) + b;
              } else if (t < 2.5 / 2.75) {
                return c * (o * (t -= 2.25 / 2.75) * t + 0.9375) + b;
              } else {
                return c * (o * (t -= 2.625 / 2.75) * t + 0.984375) + b;
              }
            },
            easeInOutBounce: function(x, t, b, c, d) {
              return t < d / 2 ? this.easeInBounce(x, t * 2, 0, c, d) * 0.5 + b : this.easeOutBounce(x, t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
            }
          };
        }();
        var FRAMEWORK = function() {
          var _rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
          var _strSpace = " ";
          var _strEmpty = "";
          var _strScrollLeft = "scrollLeft";
          var _strScrollTop = "scrollTop";
          var _animations = [];
          var _type = COMPATIBILITY.type;
          var _cssNumber = {
            animationIterationCount: true,
            columnCount: true,
            fillOpacity: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            widows: true,
            zIndex: true,
            zoom: true
          };
          function extend() {
            var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {}, i = 1, length2 = arguments[LEXICON.l], deep = false;
            if (_type(target) == TYPES.b) {
              deep = target;
              target = arguments[1] || {};
              i = 2;
            }
            if (_type(target) != TYPES.o && !_type(target) == TYPES.f) {
              target = {};
            }
            if (length2 === i) {
              target = FakejQuery;
              --i;
            }
            for (; i < length2; i++) {
              if ((options = arguments[i]) != null) {
                for (name in options) {
                  src = target[name];
                  copy = options[name];
                  if (target === copy) {
                    continue;
                  }
                  if (deep && copy && (isPlainObject(copy) || (copyIsArray = COMPATIBILITY.isA(copy)))) {
                    if (copyIsArray) {
                      copyIsArray = false;
                      clone = src && COMPATIBILITY.isA(src) ? src : [];
                    } else {
                      clone = src && isPlainObject(src) ? src : {};
                    }
                    target[name] = extend(deep, clone, copy);
                  } else if (copy !== undefined2) {
                    target[name] = copy;
                  }
                }
              }
            }
            return target;
          }
          ;
          function inArray(item, arr, fromIndex) {
            for (var i = fromIndex || 0; i < arr[LEXICON.l]; i++)
              if (arr[i] === item)
                return i;
            return -1;
          }
          function isFunction(obj) {
            return _type(obj) == TYPES.f;
          }
          ;
          function isEmptyObject(obj) {
            for (var name in obj)
              return false;
            return true;
          }
          ;
          function isPlainObject(obj) {
            if (!obj || _type(obj) != TYPES.o)
              return false;
            var key;
            var proto = LEXICON.p;
            var hasOwnProperty = Object[proto].hasOwnProperty;
            var hasOwnConstructor = hasOwnProperty.call(obj, "constructor");
            var hasIsPrototypeOf = obj.constructor && obj.constructor[proto] && hasOwnProperty.call(obj.constructor[proto], "isPrototypeOf");
            if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
              return false;
            }
            for (key in obj) {
            }
            return _type(key) == TYPES.u || hasOwnProperty.call(obj, key);
          }
          ;
          function each(obj, callback) {
            var i = 0;
            if (isArrayLike(obj)) {
              for (; i < obj[LEXICON.l]; i++) {
                if (callback.call(obj[i], i, obj[i]) === false)
                  break;
              }
            } else {
              for (i in obj) {
                if (callback.call(obj[i], i, obj[i]) === false)
                  break;
              }
            }
            return obj;
          }
          ;
          function isArrayLike(obj) {
            var length2 = !!obj && [LEXICON.l] in obj && obj[LEXICON.l];
            var t = _type(obj);
            return isFunction(t) ? false : t == TYPES.a || length2 === 0 || _type(length2) == TYPES.n && length2 > 0 && length2 - 1 in obj;
          }
          function stripAndCollapse(value) {
            var tokens = value.match(_rnothtmlwhite) || [];
            return tokens.join(_strSpace);
          }
          function matches(elem, selector) {
            var nodeList = (elem.parentNode || document3).querySelectorAll(selector) || [];
            var i = nodeList[LEXICON.l];
            while (i--)
              if (nodeList[i] == elem)
                return true;
            return false;
          }
          function insertAdjacentElement(el, strategy, child) {
            if (COMPATIBILITY.isA(child)) {
              for (var i = 0; i < child[LEXICON.l]; i++)
                insertAdjacentElement(el, strategy, child[i]);
            } else if (_type(child) == TYPES.s)
              el.insertAdjacentHTML(strategy, child);
            else
              el.insertAdjacentElement(strategy, child.nodeType ? child : child[0]);
          }
          function setCSSVal(el, prop, val) {
            try {
              if (el[LEXICON.s][prop] !== undefined2)
                el[LEXICON.s][prop] = parseCSSVal(prop, val);
            } catch (e) {
            }
          }
          function parseCSSVal(prop, val) {
            if (!_cssNumber[prop.toLowerCase()] && _type(val) == TYPES.n)
              val += "px";
            return val;
          }
          function startNextAnimationInQ(animObj, removeFromQ) {
            var index;
            var nextAnim;
            if (removeFromQ !== false)
              animObj.q.splice(0, 1);
            if (animObj.q[LEXICON.l] > 0) {
              nextAnim = animObj.q[0];
              animate(animObj.el, nextAnim.props, nextAnim.duration, nextAnim.easing, nextAnim.complete, true);
            } else {
              index = inArray(animObj, _animations);
              if (index > -1)
                _animations.splice(index, 1);
            }
          }
          function setAnimationValue(el, prop, value) {
            if (prop === _strScrollLeft || prop === _strScrollTop)
              el[prop] = value;
            else
              setCSSVal(el, prop, value);
          }
          function animate(el, props, options, easing, complete, guaranteedNext) {
            var hasOptions = isPlainObject(options);
            var from = {};
            var to = {};
            var i = 0;
            var key;
            var animObj;
            var start;
            var progress;
            var step;
            var specialEasing;
            var duration;
            if (hasOptions) {
              easing = options.easing;
              start = options.start;
              progress = options.progress;
              step = options.step;
              specialEasing = options.specialEasing;
              complete = options.complete;
              duration = options.duration;
            } else
              duration = options;
            specialEasing = specialEasing || {};
            duration = duration || 400;
            easing = easing || "swing";
            guaranteedNext = guaranteedNext || false;
            for (; i < _animations[LEXICON.l]; i++) {
              if (_animations[i].el === el) {
                animObj = _animations[i];
                break;
              }
            }
            if (!animObj) {
              animObj = {
                el,
                q: []
              };
              _animations.push(animObj);
            }
            for (key in props) {
              if (key === _strScrollLeft || key === _strScrollTop)
                from[key] = el[key];
              else
                from[key] = FakejQuery(el).css(key);
            }
            for (key in from) {
              if (from[key] !== props[key] && props[key] !== undefined2)
                to[key] = props[key];
            }
            if (!isEmptyObject(to)) {
              var timeNow;
              var end;
              var percent;
              var fromVal;
              var toVal;
              var easedVal;
              var timeStart;
              var frame;
              var elapsed;
              var qPos = guaranteedNext ? 0 : inArray(qObj, animObj.q);
              var qObj = {
                props: to,
                duration: hasOptions ? options : duration,
                easing,
                complete
              };
              if (qPos === -1) {
                qPos = animObj.q[LEXICON.l];
                animObj.q.push(qObj);
              }
              if (qPos === 0) {
                if (duration > 0) {
                  timeStart = COMPATIBILITY.now();
                  frame = function() {
                    timeNow = COMPATIBILITY.now();
                    elapsed = timeNow - timeStart;
                    end = qObj.stop || elapsed >= duration;
                    percent = 1 - (MATH.max(0, timeStart + duration - timeNow) / duration || 0);
                    for (key in to) {
                      fromVal = parseFloat(from[key]);
                      toVal = parseFloat(to[key]);
                      easedVal = (toVal - fromVal) * EASING[specialEasing[key] || easing](percent, percent * duration, 0, 1, duration) + fromVal;
                      setAnimationValue(el, key, easedVal);
                      if (isFunction(step)) {
                        step(easedVal, {
                          elem: el,
                          prop: key,
                          start: fromVal,
                          now: easedVal,
                          end: toVal,
                          pos: percent,
                          options: {
                            easing,
                            speacialEasing: specialEasing,
                            duration,
                            complete,
                            step
                          },
                          startTime: timeStart
                        });
                      }
                    }
                    if (isFunction(progress))
                      progress({}, percent, MATH.max(0, duration - elapsed));
                    if (end) {
                      startNextAnimationInQ(animObj);
                      if (isFunction(complete))
                        complete();
                    } else
                      qObj.frame = COMPATIBILITY.rAF()(frame);
                  };
                  qObj.frame = COMPATIBILITY.rAF()(frame);
                } else {
                  for (key in to)
                    setAnimationValue(el, key, to[key]);
                  startNextAnimationInQ(animObj);
                }
              }
            } else if (guaranteedNext)
              startNextAnimationInQ(animObj);
          }
          function stop(el, clearQ, jumpToEnd) {
            var animObj;
            var qObj;
            var key;
            var i = 0;
            for (; i < _animations[LEXICON.l]; i++) {
              animObj = _animations[i];
              if (animObj.el === el) {
                if (animObj.q[LEXICON.l] > 0) {
                  qObj = animObj.q[0];
                  qObj.stop = true;
                  COMPATIBILITY.cAF()(qObj.frame);
                  animObj.q.splice(0, 1);
                  if (jumpToEnd)
                    for (key in qObj.props)
                      setAnimationValue(el, key, qObj.props[key]);
                  if (clearQ)
                    animObj.q = [];
                  else
                    startNextAnimationInQ(animObj, false);
                }
                break;
              }
            }
          }
          function elementIsVisible(el) {
            return !!(el[LEXICON.oW] || el[LEXICON.oH] || el.getClientRects()[LEXICON.l]);
          }
          function FakejQuery(selector) {
            if (arguments[LEXICON.l] === 0)
              return this;
            var base = new FakejQuery();
            var elements = selector;
            var i = 0;
            var elms;
            var el;
            if (_type(selector) == TYPES.s) {
              elements = [];
              if (selector.charAt(0) === "<") {
                el = document3.createElement("div");
                el.innerHTML = selector;
                elms = el.children;
              } else {
                elms = document3.querySelectorAll(selector);
              }
              for (; i < elms[LEXICON.l]; i++)
                elements.push(elms[i]);
            }
            if (elements) {
              if (_type(elements) != TYPES.s && (!isArrayLike(elements) || elements === window2 || elements === elements.self))
                elements = [elements];
              for (i = 0; i < elements[LEXICON.l]; i++)
                base[i] = elements[i];
              base[LEXICON.l] = elements[LEXICON.l];
            }
            return base;
          }
          ;
          FakejQuery[LEXICON.p] = {
            on: function(eventName, handler) {
              eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
              var eventNameLength = eventName[LEXICON.l];
              var i = 0;
              var el;
              return this.each(function() {
                el = this;
                try {
                  if (el.addEventListener) {
                    for (; i < eventNameLength; i++)
                      el.addEventListener(eventName[i], handler);
                  } else if (el.detachEvent) {
                    for (; i < eventNameLength; i++)
                      el.attachEvent("on" + eventName[i], handler);
                  }
                } catch (e) {
                }
              });
            },
            off: function(eventName, handler) {
              eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
              var eventNameLength = eventName[LEXICON.l];
              var i = 0;
              var el;
              return this.each(function() {
                el = this;
                try {
                  if (el.removeEventListener) {
                    for (; i < eventNameLength; i++)
                      el.removeEventListener(eventName[i], handler);
                  } else if (el.detachEvent) {
                    for (; i < eventNameLength; i++)
                      el.detachEvent("on" + eventName[i], handler);
                  }
                } catch (e) {
                }
              });
            },
            one: function(eventName, handler) {
              eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
              return this.each(function() {
                var el = FakejQuery(this);
                FakejQuery.each(eventName, function(i, oneEventName) {
                  var oneHandler = function(e) {
                    handler.call(this, e);
                    el.off(oneEventName, oneHandler);
                  };
                  el.on(oneEventName, oneHandler);
                });
              });
            },
            trigger: function(eventName) {
              var el;
              var event;
              return this.each(function() {
                el = this;
                if (document3.createEvent) {
                  event = document3.createEvent("HTMLEvents");
                  event.initEvent(eventName, true, false);
                  el.dispatchEvent(event);
                } else {
                  el.fireEvent("on" + eventName);
                }
              });
            },
            append: function(child) {
              return this.each(function() {
                insertAdjacentElement(this, "beforeend", child);
              });
            },
            prepend: function(child) {
              return this.each(function() {
                insertAdjacentElement(this, "afterbegin", child);
              });
            },
            before: function(child) {
              return this.each(function() {
                insertAdjacentElement(this, "beforebegin", child);
              });
            },
            after: function(child) {
              return this.each(function() {
                insertAdjacentElement(this, "afterend", child);
              });
            },
            remove: function() {
              return this.each(function() {
                var el = this;
                var parentNode = el.parentNode;
                if (parentNode != null)
                  parentNode.removeChild(el);
              });
            },
            unwrap: function() {
              var parents = [];
              var i;
              var el;
              var parent;
              this.each(function() {
                parent = this.parentNode;
                if (inArray(parent, parents) === -1)
                  parents.push(parent);
              });
              for (i = 0; i < parents[LEXICON.l]; i++) {
                el = parents[i];
                parent = el.parentNode;
                while (el.firstChild)
                  parent.insertBefore(el.firstChild, el);
                parent.removeChild(el);
              }
              return this;
            },
            wrapAll: function(wrapperHTML) {
              var i;
              var nodes = this;
              var wrapper = FakejQuery(wrapperHTML)[0];
              var deepest = wrapper;
              var parent = nodes[0].parentNode;
              var previousSibling = nodes[0].previousSibling;
              while (deepest.childNodes[LEXICON.l] > 0)
                deepest = deepest.childNodes[0];
              for (i = 0; nodes[LEXICON.l] - i; deepest.firstChild === nodes[0] && i++)
                deepest.appendChild(nodes[i]);
              var nextSibling = previousSibling ? previousSibling.nextSibling : parent.firstChild;
              parent.insertBefore(wrapper, nextSibling);
              return this;
            },
            wrapInner: function(wrapperHTML) {
              return this.each(function() {
                var el = FakejQuery(this);
                var contents = el.contents();
                if (contents[LEXICON.l])
                  contents.wrapAll(wrapperHTML);
                else
                  el.append(wrapperHTML);
              });
            },
            wrap: function(wrapperHTML) {
              return this.each(function() {
                FakejQuery(this).wrapAll(wrapperHTML);
              });
            },
            css: function(styles, val) {
              var el;
              var key;
              var cptStyle;
              var getCptStyle = window2.getComputedStyle;
              if (_type(styles) == TYPES.s) {
                if (val === undefined2) {
                  el = this[0];
                  cptStyle = getCptStyle ? getCptStyle(el, null) : el.currentStyle[styles];
                  return getCptStyle ? cptStyle != null ? cptStyle.getPropertyValue(styles) : el[LEXICON.s][styles] : cptStyle;
                } else {
                  return this.each(function() {
                    setCSSVal(this, styles, val);
                  });
                }
              } else {
                return this.each(function() {
                  for (key in styles)
                    setCSSVal(this, key, styles[key]);
                });
              }
            },
            hasClass: function(className) {
              var elem, i = 0;
              var classNamePrepared = _strSpace + className + _strSpace;
              var classList;
              while (elem = this[i++]) {
                classList = elem.classList;
                if (classList && classList.contains(className))
                  return true;
                else if (elem.nodeType === 1 && (_strSpace + stripAndCollapse(elem.className + _strEmpty) + _strSpace).indexOf(classNamePrepared) > -1)
                  return true;
              }
              return false;
            },
            addClass: function(className) {
              var classes;
              var elem;
              var cur;
              var curValue;
              var clazz;
              var finalValue;
              var supportClassList;
              var elmClassList;
              var i = 0;
              var v = 0;
              if (className) {
                classes = className.match(_rnothtmlwhite) || [];
                while (elem = this[i++]) {
                  elmClassList = elem.classList;
                  if (supportClassList === undefined2)
                    supportClassList = elmClassList !== undefined2;
                  if (supportClassList) {
                    while (clazz = classes[v++])
                      elmClassList.add(clazz);
                  } else {
                    curValue = elem.className + _strEmpty;
                    cur = elem.nodeType === 1 && _strSpace + stripAndCollapse(curValue) + _strSpace;
                    if (cur) {
                      while (clazz = classes[v++])
                        if (cur.indexOf(_strSpace + clazz + _strSpace) < 0)
                          cur += clazz + _strSpace;
                      finalValue = stripAndCollapse(cur);
                      if (curValue !== finalValue)
                        elem.className = finalValue;
                    }
                  }
                }
              }
              return this;
            },
            removeClass: function(className) {
              var classes;
              var elem;
              var cur;
              var curValue;
              var clazz;
              var finalValue;
              var supportClassList;
              var elmClassList;
              var i = 0;
              var v = 0;
              if (className) {
                classes = className.match(_rnothtmlwhite) || [];
                while (elem = this[i++]) {
                  elmClassList = elem.classList;
                  if (supportClassList === undefined2)
                    supportClassList = elmClassList !== undefined2;
                  if (supportClassList) {
                    while (clazz = classes[v++])
                      elmClassList.remove(clazz);
                  } else {
                    curValue = elem.className + _strEmpty;
                    cur = elem.nodeType === 1 && _strSpace + stripAndCollapse(curValue) + _strSpace;
                    if (cur) {
                      while (clazz = classes[v++])
                        while (cur.indexOf(_strSpace + clazz + _strSpace) > -1)
                          cur = cur.replace(_strSpace + clazz + _strSpace, _strSpace);
                      finalValue = stripAndCollapse(cur);
                      if (curValue !== finalValue)
                        elem.className = finalValue;
                    }
                  }
                }
              }
              return this;
            },
            hide: function() {
              return this.each(function() {
                this[LEXICON.s].display = "none";
              });
            },
            show: function() {
              return this.each(function() {
                this[LEXICON.s].display = "block";
              });
            },
            attr: function(attrName, value) {
              var i = 0;
              var el;
              while (el = this[i++]) {
                if (value === undefined2)
                  return el.getAttribute(attrName);
                el.setAttribute(attrName, value);
              }
              return this;
            },
            removeAttr: function(attrName) {
              return this.each(function() {
                this.removeAttribute(attrName);
              });
            },
            offset: function() {
              var el = this[0];
              var rect = el[LEXICON.bCR]();
              var scrollLeft = window2.pageXOffset || document3.documentElement[_strScrollLeft];
              var scrollTop = window2.pageYOffset || document3.documentElement[_strScrollTop];
              return {
                top: rect.top + scrollTop,
                left: rect.left + scrollLeft
              };
            },
            position: function() {
              var el = this[0];
              return {
                top: el.offsetTop,
                left: el.offsetLeft
              };
            },
            scrollLeft: function(value) {
              var i = 0;
              var el;
              while (el = this[i++]) {
                if (value === undefined2)
                  return el[_strScrollLeft];
                el[_strScrollLeft] = value;
              }
              return this;
            },
            scrollTop: function(value) {
              var i = 0;
              var el;
              while (el = this[i++]) {
                if (value === undefined2)
                  return el[_strScrollTop];
                el[_strScrollTop] = value;
              }
              return this;
            },
            val: function(value) {
              var el = this[0];
              if (!value)
                return el.value;
              el.value = value;
              return this;
            },
            first: function() {
              return this.eq(0);
            },
            last: function() {
              return this.eq(-1);
            },
            eq: function(index) {
              return FakejQuery(this[index >= 0 ? index : this[LEXICON.l] + index]);
            },
            find: function(selector) {
              var children = [];
              var i;
              this.each(function() {
                var el = this;
                var ch = el.querySelectorAll(selector);
                for (i = 0; i < ch[LEXICON.l]; i++)
                  children.push(ch[i]);
              });
              return FakejQuery(children);
            },
            children: function(selector) {
              var children = [];
              var el;
              var ch;
              var i;
              this.each(function() {
                ch = this.children;
                for (i = 0; i < ch[LEXICON.l]; i++) {
                  el = ch[i];
                  if (selector) {
                    if (el.matches && el.matches(selector) || matches(el, selector))
                      children.push(el);
                  } else
                    children.push(el);
                }
              });
              return FakejQuery(children);
            },
            parent: function(selector) {
              var parents = [];
              var parent;
              this.each(function() {
                parent = this.parentNode;
                if (selector ? FakejQuery(parent).is(selector) : true)
                  parents.push(parent);
              });
              return FakejQuery(parents);
            },
            is: function(selector) {
              var el;
              var i;
              for (i = 0; i < this[LEXICON.l]; i++) {
                el = this[i];
                if (selector === ":visible")
                  return elementIsVisible(el);
                if (selector === ":hidden")
                  return !elementIsVisible(el);
                if (el.matches && el.matches(selector) || matches(el, selector))
                  return true;
              }
              return false;
            },
            contents: function() {
              var contents = [];
              var childs;
              var i;
              this.each(function() {
                childs = this.childNodes;
                for (i = 0; i < childs[LEXICON.l]; i++)
                  contents.push(childs[i]);
              });
              return FakejQuery(contents);
            },
            each: function(callback) {
              return each(this, callback);
            },
            animate: function(props, duration, easing, complete) {
              return this.each(function() {
                animate(this, props, duration, easing, complete);
              });
            },
            stop: function(clearQ, jump) {
              return this.each(function() {
                stop(this, clearQ, jump);
              });
            }
          };
          extend(FakejQuery, {
            extend,
            inArray,
            isEmptyObject,
            isPlainObject,
            each
          });
          return FakejQuery;
        }();
        var INSTANCES = function() {
          var _targets = [];
          var _instancePropertyString = "__overlayScrollbars__";
          return function(target, instance) {
            var argLen = arguments[LEXICON.l];
            if (argLen < 1) {
              return _targets;
            } else {
              if (instance) {
                target[_instancePropertyString] = instance;
                _targets.push(target);
              } else {
                var index = COMPATIBILITY.inA(target, _targets);
                if (index > -1) {
                  if (argLen > 1) {
                    delete target[_instancePropertyString];
                    _targets.splice(index, 1);
                  } else {
                    return _targets[index][_instancePropertyString];
                  }
                }
              }
            }
          };
        }();
        var PLUGIN = function() {
          var _plugin;
          var _pluginsGlobals;
          var _pluginsAutoUpdateLoop;
          var _pluginsExtensions = [];
          var _pluginsOptions = function() {
            var type = COMPATIBILITY.type;
            var possibleTemplateTypes = [
              TYPES.b,
              TYPES.n,
              TYPES.s,
              TYPES.a,
              TYPES.o,
              TYPES.f,
              TYPES.z
            ];
            var restrictedStringsSplit = " ";
            var restrictedStringsPossibilitiesSplit = ":";
            var classNameAllowedValues = [TYPES.z, TYPES.s];
            var numberAllowedValues = TYPES.n;
            var booleanNullAllowedValues = [TYPES.z, TYPES.b];
            var booleanTrueTemplate = [true, TYPES.b];
            var booleanFalseTemplate = [false, TYPES.b];
            var callbackTemplate = [null, [TYPES.z, TYPES.f]];
            var updateOnLoadTemplate = [["img"], [TYPES.s, TYPES.a, TYPES.z]];
            var inheritedAttrsTemplate = [["style", "class"], [TYPES.s, TYPES.a, TYPES.z]];
            var resizeAllowedValues = "n:none b:both h:horizontal v:vertical";
            var overflowBehaviorAllowedValues = "v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden";
            var scrollbarsVisibilityAllowedValues = "v:visible h:hidden a:auto";
            var scrollbarsAutoHideAllowedValues = "n:never s:scroll l:leave m:move";
            var optionsDefaultsAndTemplate = {
              className: ["os-theme-dark", classNameAllowedValues],
              resize: ["none", resizeAllowedValues],
              sizeAutoCapable: booleanTrueTemplate,
              clipAlways: booleanTrueTemplate,
              normalizeRTL: booleanTrueTemplate,
              paddingAbsolute: booleanFalseTemplate,
              autoUpdate: [null, booleanNullAllowedValues],
              autoUpdateInterval: [33, numberAllowedValues],
              updateOnLoad: updateOnLoadTemplate,
              nativeScrollbarsOverlaid: {
                showNativeScrollbars: booleanFalseTemplate,
                initialize: booleanTrueTemplate
              },
              overflowBehavior: {
                x: ["scroll", overflowBehaviorAllowedValues],
                y: ["scroll", overflowBehaviorAllowedValues]
              },
              scrollbars: {
                visibility: ["auto", scrollbarsVisibilityAllowedValues],
                autoHide: ["never", scrollbarsAutoHideAllowedValues],
                autoHideDelay: [800, numberAllowedValues],
                dragScrolling: booleanTrueTemplate,
                clickScrolling: booleanFalseTemplate,
                touchSupport: booleanTrueTemplate,
                snapHandle: booleanFalseTemplate
              },
              textarea: {
                dynWidth: booleanFalseTemplate,
                dynHeight: booleanFalseTemplate,
                inheritedAttrs: inheritedAttrsTemplate
              },
              callbacks: {
                onInitialized: callbackTemplate,
                onInitializationWithdrawn: callbackTemplate,
                onDestroyed: callbackTemplate,
                onScrollStart: callbackTemplate,
                onScroll: callbackTemplate,
                onScrollStop: callbackTemplate,
                onOverflowChanged: callbackTemplate,
                onOverflowAmountChanged: callbackTemplate,
                onDirectionChanged: callbackTemplate,
                onContentSizeChanged: callbackTemplate,
                onHostSizeChanged: callbackTemplate,
                onUpdated: callbackTemplate
              }
            };
            var convert = function(template) {
              var recursive = function(obj) {
                var key;
                var val;
                var valType;
                for (key in obj) {
                  if (!obj[LEXICON.hOP](key))
                    continue;
                  val = obj[key];
                  valType = type(val);
                  if (valType == TYPES.a)
                    obj[key] = val[template ? 1 : 0];
                  else if (valType == TYPES.o)
                    obj[key] = recursive(val);
                }
                return obj;
              };
              return recursive(FRAMEWORK.extend(true, {}, optionsDefaultsAndTemplate));
            };
            return {
              _defaults: convert(),
              _template: convert(true),
              _validate: function(obj, template, writeErrors, diffObj) {
                var validatedOptions = {};
                var validatedOptionsPrepared = {};
                var objectCopy = FRAMEWORK.extend(true, {}, obj);
                var inArray = FRAMEWORK.inArray;
                var isEmptyObj = FRAMEWORK.isEmptyObject;
                var checkObjectProps = function(data, template2, diffData, validatedOptions2, validatedOptionsPrepared2, prevPropName) {
                  for (var prop in template2) {
                    if (template2[LEXICON.hOP](prop) && data[LEXICON.hOP](prop)) {
                      var isValid = false;
                      var isDiff = false;
                      var templateValue = template2[prop];
                      var templateValueType = type(templateValue);
                      var templateIsComplex = templateValueType == TYPES.o;
                      var templateTypes = !COMPATIBILITY.isA(templateValue) ? [templateValue] : templateValue;
                      var dataDiffValue = diffData[prop];
                      var dataValue = data[prop];
                      var dataValueType = type(dataValue);
                      var propPrefix = prevPropName ? prevPropName + "." : "";
                      var error = 'The option "' + propPrefix + prop + `" wasn't set, because`;
                      var errorPossibleTypes = [];
                      var errorRestrictedStrings = [];
                      var restrictedStringValuesSplit;
                      var restrictedStringValuesPossibilitiesSplit;
                      var isRestrictedValue;
                      var mainPossibility;
                      var currType;
                      var i;
                      var v;
                      var j;
                      dataDiffValue = dataDiffValue === undefined2 ? {} : dataDiffValue;
                      if (templateIsComplex && dataValueType == TYPES.o) {
                        validatedOptions2[prop] = {};
                        validatedOptionsPrepared2[prop] = {};
                        checkObjectProps(dataValue, templateValue, dataDiffValue, validatedOptions2[prop], validatedOptionsPrepared2[prop], propPrefix + prop);
                        FRAMEWORK.each([data, validatedOptions2, validatedOptionsPrepared2], function(index, value) {
                          if (isEmptyObj(value[prop])) {
                            delete value[prop];
                          }
                        });
                      } else if (!templateIsComplex) {
                        for (i = 0; i < templateTypes[LEXICON.l]; i++) {
                          currType = templateTypes[i];
                          templateValueType = type(currType);
                          isRestrictedValue = templateValueType == TYPES.s && inArray(currType, possibleTemplateTypes) === -1;
                          if (isRestrictedValue) {
                            errorPossibleTypes.push(TYPES.s);
                            restrictedStringValuesSplit = currType.split(restrictedStringsSplit);
                            errorRestrictedStrings = errorRestrictedStrings.concat(restrictedStringValuesSplit);
                            for (v = 0; v < restrictedStringValuesSplit[LEXICON.l]; v++) {
                              restrictedStringValuesPossibilitiesSplit = restrictedStringValuesSplit[v].split(restrictedStringsPossibilitiesSplit);
                              mainPossibility = restrictedStringValuesPossibilitiesSplit[0];
                              for (j = 0; j < restrictedStringValuesPossibilitiesSplit[LEXICON.l]; j++) {
                                if (dataValue === restrictedStringValuesPossibilitiesSplit[j]) {
                                  isValid = true;
                                  break;
                                }
                              }
                              if (isValid)
                                break;
                            }
                          } else {
                            errorPossibleTypes.push(currType);
                            if (dataValueType === currType) {
                              isValid = true;
                              break;
                            }
                          }
                        }
                        if (isValid) {
                          isDiff = dataValue !== dataDiffValue;
                          if (isDiff)
                            validatedOptions2[prop] = dataValue;
                          if (isRestrictedValue ? inArray(dataDiffValue, restrictedStringValuesPossibilitiesSplit) < 0 : isDiff)
                            validatedOptionsPrepared2[prop] = isRestrictedValue ? mainPossibility : dataValue;
                        } else if (writeErrors) {
                          console.warn(error + " it doesn't accept the type [ " + dataValueType.toUpperCase() + ' ] with the value of "' + dataValue + '".\r\nAccepted types are: [ ' + errorPossibleTypes.join(", ").toUpperCase() + " ]." + (errorRestrictedStrings[length] > 0 ? "\r\nValid strings are: [ " + errorRestrictedStrings.join(", ").split(restrictedStringsPossibilitiesSplit).join(", ") + " ]." : ""));
                        }
                        delete data[prop];
                      }
                    }
                  }
                };
                checkObjectProps(objectCopy, template, diffObj || {}, validatedOptions, validatedOptionsPrepared);
                if (!isEmptyObj(objectCopy) && writeErrors)
                  console.warn("The following options are discarded due to invalidity:\r\n" + window2.JSON.stringify(objectCopy, null, 2));
                return {
                  _default: validatedOptions,
                  _prepared: validatedOptionsPrepared
                };
              }
            };
          }();
          function initOverlayScrollbarsStatics() {
            if (!_pluginsGlobals)
              _pluginsGlobals = new OverlayScrollbarsGlobals(_pluginsOptions._defaults);
            if (!_pluginsAutoUpdateLoop)
              _pluginsAutoUpdateLoop = new OverlayScrollbarsAutoUpdateLoop(_pluginsGlobals);
          }
          function OverlayScrollbarsGlobals(defaultOptions) {
            var _base = this;
            var strOverflow = "overflow";
            var strHidden = "hidden";
            var strScroll = "scroll";
            var bodyElement = FRAMEWORK("body");
            var scrollbarDummyElement = FRAMEWORK('<div id="os-dummy-scrollbar-size"><div></div></div>');
            var scrollbarDummyElement0 = scrollbarDummyElement[0];
            var dummyContainerChild = FRAMEWORK(scrollbarDummyElement.children("div").eq(0));
            bodyElement.append(scrollbarDummyElement);
            scrollbarDummyElement.hide().show();
            var nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement0);
            var nativeScrollbarIsOverlaid = {
              x: nativeScrollbarSize.x === 0,
              y: nativeScrollbarSize.y === 0
            };
            var msie = function() {
              var ua = window2.navigator.userAgent;
              var strIndexOf = "indexOf";
              var strSubString = "substring";
              var msie2 = ua[strIndexOf]("MSIE ");
              var trident = ua[strIndexOf]("Trident/");
              var edge = ua[strIndexOf]("Edge/");
              var rv = ua[strIndexOf]("rv:");
              var result;
              var parseIntFunc = parseInt;
              if (msie2 > 0)
                result = parseIntFunc(ua[strSubString](msie2 + 5, ua[strIndexOf](".", msie2)), 10);
              else if (trident > 0)
                result = parseIntFunc(ua[strSubString](rv + 3, ua[strIndexOf](".", rv)), 10);
              else if (edge > 0)
                result = parseIntFunc(ua[strSubString](edge + 5, ua[strIndexOf](".", edge)), 10);
              return result;
            }();
            FRAMEWORK.extend(_base, {
              defaultOptions,
              msie,
              autoUpdateLoop: false,
              autoUpdateRecommended: !COMPATIBILITY.mO(),
              nativeScrollbarSize,
              nativeScrollbarIsOverlaid,
              nativeScrollbarStyling: function() {
                var result = false;
                scrollbarDummyElement.addClass("os-viewport-native-scrollbars-invisible");
                try {
                  result = scrollbarDummyElement.css("scrollbar-width") === "none" && (msie > 9 || !msie) || window2.getComputedStyle(scrollbarDummyElement0, "::-webkit-scrollbar").getPropertyValue("display") === "none";
                } catch (ex) {
                }
                return result;
              }(),
              overlayScrollbarDummySize: { x: 30, y: 30 },
              cssCalc: VENDORS._cssPropertyValue("width", "calc", "(1px)") || null,
              restrictedMeasuring: function() {
                scrollbarDummyElement.css(strOverflow, strHidden);
                var scrollSize = {
                  w: scrollbarDummyElement0[LEXICON.sW],
                  h: scrollbarDummyElement0[LEXICON.sH]
                };
                scrollbarDummyElement.css(strOverflow, "visible");
                var scrollSize2 = {
                  w: scrollbarDummyElement0[LEXICON.sW],
                  h: scrollbarDummyElement0[LEXICON.sH]
                };
                return scrollSize.w - scrollSize2.w !== 0 || scrollSize.h - scrollSize2.h !== 0;
              }(),
              rtlScrollBehavior: function() {
                scrollbarDummyElement.css({ "overflow-y": strHidden, "overflow-x": strScroll, "direction": "rtl" }).scrollLeft(0);
                var dummyContainerOffset = scrollbarDummyElement.offset();
                var dummyContainerChildOffset = dummyContainerChild.offset();
                scrollbarDummyElement.scrollLeft(-999);
                var dummyContainerChildOffsetAfterScroll = dummyContainerChild.offset();
                return {
                  i: dummyContainerOffset.left === dummyContainerChildOffset.left,
                  n: dummyContainerChildOffset.left !== dummyContainerChildOffsetAfterScroll.left
                };
              }(),
              supportTransform: !!VENDORS._cssProperty("transform"),
              supportTransition: !!VENDORS._cssProperty("transition"),
              supportPassiveEvents: function() {
                var supportsPassive = false;
                try {
                  window2.addEventListener("test", null, Object.defineProperty({}, "passive", {
                    get: function() {
                      supportsPassive = true;
                    }
                  }));
                } catch (e) {
                }
                return supportsPassive;
              }(),
              supportResizeObserver: !!COMPATIBILITY.rO(),
              supportMutationObserver: !!COMPATIBILITY.mO()
            });
            scrollbarDummyElement.removeAttr(LEXICON.s).remove();
            (function() {
              if (nativeScrollbarIsOverlaid.x && nativeScrollbarIsOverlaid.y)
                return;
              var abs = MATH.abs;
              var windowWidth = COMPATIBILITY.wW();
              var windowHeight = COMPATIBILITY.wH();
              var windowDpr = getWindowDPR();
              var onResize = function() {
                if (INSTANCES().length > 0) {
                  var newW = COMPATIBILITY.wW();
                  var newH = COMPATIBILITY.wH();
                  var deltaW = newW - windowWidth;
                  var deltaH = newH - windowHeight;
                  if (deltaW === 0 && deltaH === 0)
                    return;
                  var deltaWRatio = MATH.round(newW / (windowWidth / 100));
                  var deltaHRatio = MATH.round(newH / (windowHeight / 100));
                  var absDeltaW = abs(deltaW);
                  var absDeltaH = abs(deltaH);
                  var absDeltaWRatio = abs(deltaWRatio);
                  var absDeltaHRatio = abs(deltaHRatio);
                  var newDPR = getWindowDPR();
                  var deltaIsBigger = absDeltaW > 2 && absDeltaH > 2;
                  var difference = !differenceIsBiggerThanOne(absDeltaWRatio, absDeltaHRatio);
                  var dprChanged = newDPR !== windowDpr && windowDpr > 0;
                  var isZoom = deltaIsBigger && difference && dprChanged;
                  var oldScrollbarSize = _base.nativeScrollbarSize;
                  var newScrollbarSize;
                  if (isZoom) {
                    bodyElement.append(scrollbarDummyElement);
                    newScrollbarSize = _base.nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement[0]);
                    scrollbarDummyElement.remove();
                    if (oldScrollbarSize.x !== newScrollbarSize.x || oldScrollbarSize.y !== newScrollbarSize.y) {
                      FRAMEWORK.each(INSTANCES(), function() {
                        if (INSTANCES(this))
                          INSTANCES(this).update("zoom");
                      });
                    }
                  }
                  windowWidth = newW;
                  windowHeight = newH;
                  windowDpr = newDPR;
                }
              };
              function differenceIsBiggerThanOne(valOne, valTwo) {
                var absValOne = abs(valOne);
                var absValTwo = abs(valTwo);
                return !(absValOne === absValTwo || absValOne + 1 === absValTwo || absValOne - 1 === absValTwo);
              }
              function getWindowDPR() {
                var dDPI = window2.screen.deviceXDPI || 0;
                var sDPI = window2.screen.logicalXDPI || 1;
                return window2.devicePixelRatio || dDPI / sDPI;
              }
              FRAMEWORK(window2).on("resize", onResize);
            })();
            function calcNativeScrollbarSize(measureElement) {
              return {
                x: measureElement[LEXICON.oH] - measureElement[LEXICON.cH],
                y: measureElement[LEXICON.oW] - measureElement[LEXICON.cW]
              };
            }
          }
          function OverlayScrollbarsAutoUpdateLoop(globals) {
            var _base = this;
            var _inArray = FRAMEWORK.inArray;
            var _getNow = COMPATIBILITY.now;
            var _strAutoUpdate = "autoUpdate";
            var _strAutoUpdateInterval = _strAutoUpdate + "Interval";
            var _strLength = LEXICON.l;
            var _loopingInstances = [];
            var _loopingInstancesIntervalCache = [];
            var _loopIsActive = false;
            var _loopIntervalDefault = 33;
            var _loopInterval = _loopIntervalDefault;
            var _loopTimeOld = _getNow();
            var _loopID;
            var loop = function() {
              if (_loopingInstances[_strLength] > 0 && _loopIsActive) {
                _loopID = COMPATIBILITY.rAF()(function() {
                  loop();
                });
                var timeNew = _getNow();
                var timeDelta = timeNew - _loopTimeOld;
                var lowestInterval;
                var instance;
                var instanceOptions;
                var instanceAutoUpdateAllowed;
                var instanceAutoUpdateInterval;
                var now;
                if (timeDelta > _loopInterval) {
                  _loopTimeOld = timeNew - timeDelta % _loopInterval;
                  lowestInterval = _loopIntervalDefault;
                  for (var i = 0; i < _loopingInstances[_strLength]; i++) {
                    instance = _loopingInstances[i];
                    if (instance !== undefined2) {
                      instanceOptions = instance.options();
                      instanceAutoUpdateAllowed = instanceOptions[_strAutoUpdate];
                      instanceAutoUpdateInterval = MATH.max(1, instanceOptions[_strAutoUpdateInterval]);
                      now = _getNow();
                      if ((instanceAutoUpdateAllowed === true || instanceAutoUpdateAllowed === null) && now - _loopingInstancesIntervalCache[i] > instanceAutoUpdateInterval) {
                        instance.update("auto");
                        _loopingInstancesIntervalCache[i] = new Date(now += instanceAutoUpdateInterval);
                      }
                      lowestInterval = MATH.max(1, MATH.min(lowestInterval, instanceAutoUpdateInterval));
                    }
                  }
                  _loopInterval = lowestInterval;
                }
              } else {
                _loopInterval = _loopIntervalDefault;
              }
            };
            _base.add = function(instance) {
              if (_inArray(instance, _loopingInstances) === -1) {
                _loopingInstances.push(instance);
                _loopingInstancesIntervalCache.push(_getNow());
                if (_loopingInstances[_strLength] > 0 && !_loopIsActive) {
                  _loopIsActive = true;
                  globals.autoUpdateLoop = _loopIsActive;
                  loop();
                }
              }
            };
            _base.remove = function(instance) {
              var index = _inArray(instance, _loopingInstances);
              if (index > -1) {
                _loopingInstancesIntervalCache.splice(index, 1);
                _loopingInstances.splice(index, 1);
                if (_loopingInstances[_strLength] === 0 && _loopIsActive) {
                  _loopIsActive = false;
                  globals.autoUpdateLoop = _loopIsActive;
                  if (_loopID !== undefined2) {
                    COMPATIBILITY.cAF()(_loopID);
                    _loopID = -1;
                  }
                }
              }
            };
          }
          function OverlayScrollbarsInstance(pluginTargetElement, options, extensions, globals, autoUpdateLoop) {
            var type = COMPATIBILITY.type;
            var inArray = FRAMEWORK.inArray;
            var each = FRAMEWORK.each;
            var _base = new _plugin();
            var _frameworkProto = FRAMEWORK[LEXICON.p];
            if (!isHTMLElement(pluginTargetElement))
              return;
            if (INSTANCES(pluginTargetElement)) {
              var inst = INSTANCES(pluginTargetElement);
              inst.options(options);
              return inst;
            }
            var _nativeScrollbarIsOverlaid;
            var _overlayScrollbarDummySize;
            var _rtlScrollBehavior;
            var _autoUpdateRecommended;
            var _msieVersion;
            var _nativeScrollbarStyling;
            var _cssCalc;
            var _nativeScrollbarSize;
            var _supportTransition;
            var _supportTransform;
            var _supportPassiveEvents;
            var _supportResizeObserver;
            var _supportMutationObserver;
            var _restrictedMeasuring;
            var _initialized;
            var _destroyed;
            var _isTextarea;
            var _isBody;
            var _documentMixed;
            var _domExists;
            var _isBorderBox;
            var _sizeAutoObserverAdded;
            var _paddingX;
            var _paddingY;
            var _borderX;
            var _borderY;
            var _marginX;
            var _marginY;
            var _isRTL;
            var _sleeping;
            var _contentBorderSize = {};
            var _scrollHorizontalInfo = {};
            var _scrollVerticalInfo = {};
            var _viewportSize = {};
            var _nativeScrollbarMinSize = {};
            var _strMinusHidden = "-hidden";
            var _strMarginMinus = "margin-";
            var _strPaddingMinus = "padding-";
            var _strBorderMinus = "border-";
            var _strTop = "top";
            var _strRight = "right";
            var _strBottom = "bottom";
            var _strLeft = "left";
            var _strMinMinus = "min-";
            var _strMaxMinus = "max-";
            var _strWidth = "width";
            var _strHeight = "height";
            var _strFloat = "float";
            var _strEmpty = "";
            var _strAuto = "auto";
            var _strSync = "sync";
            var _strScroll = "scroll";
            var _strHundredPercent = "100%";
            var _strX = "x";
            var _strY = "y";
            var _strDot = ".";
            var _strSpace = " ";
            var _strScrollbar = "scrollbar";
            var _strMinusHorizontal = "-horizontal";
            var _strMinusVertical = "-vertical";
            var _strScrollLeft = _strScroll + "Left";
            var _strScrollTop = _strScroll + "Top";
            var _strMouseTouchDownEvent = "mousedown touchstart";
            var _strMouseTouchUpEvent = "mouseup touchend touchcancel";
            var _strMouseTouchMoveEvent = "mousemove touchmove";
            var _strMouseEnter = "mouseenter";
            var _strMouseLeave = "mouseleave";
            var _strKeyDownEvent = "keydown";
            var _strKeyUpEvent = "keyup";
            var _strSelectStartEvent = "selectstart";
            var _strTransitionEndEvent = "transitionend webkitTransitionEnd oTransitionEnd";
            var _strResizeObserverProperty = "__overlayScrollbarsRO__";
            var _cassNamesPrefix = "os-";
            var _classNameHTMLElement = _cassNamesPrefix + "html";
            var _classNameHostElement = _cassNamesPrefix + "host";
            var _classNameHostElementForeign = _classNameHostElement + "-foreign";
            var _classNameHostTextareaElement = _classNameHostElement + "-textarea";
            var _classNameHostScrollbarHorizontalHidden = _classNameHostElement + "-" + _strScrollbar + _strMinusHorizontal + _strMinusHidden;
            var _classNameHostScrollbarVerticalHidden = _classNameHostElement + "-" + _strScrollbar + _strMinusVertical + _strMinusHidden;
            var _classNameHostTransition = _classNameHostElement + "-transition";
            var _classNameHostRTL = _classNameHostElement + "-rtl";
            var _classNameHostResizeDisabled = _classNameHostElement + "-resize-disabled";
            var _classNameHostScrolling = _classNameHostElement + "-scrolling";
            var _classNameHostOverflow = _classNameHostElement + "-overflow";
            var _classNameHostOverflow = _classNameHostElement + "-overflow";
            var _classNameHostOverflowX = _classNameHostOverflow + "-x";
            var _classNameHostOverflowY = _classNameHostOverflow + "-y";
            var _classNameTextareaElement = _cassNamesPrefix + "textarea";
            var _classNameTextareaCoverElement = _classNameTextareaElement + "-cover";
            var _classNamePaddingElement = _cassNamesPrefix + "padding";
            var _classNameViewportElement = _cassNamesPrefix + "viewport";
            var _classNameViewportNativeScrollbarsInvisible = _classNameViewportElement + "-native-scrollbars-invisible";
            var _classNameViewportNativeScrollbarsOverlaid = _classNameViewportElement + "-native-scrollbars-overlaid";
            var _classNameContentElement = _cassNamesPrefix + "content";
            var _classNameContentArrangeElement = _cassNamesPrefix + "content-arrange";
            var _classNameContentGlueElement = _cassNamesPrefix + "content-glue";
            var _classNameSizeAutoObserverElement = _cassNamesPrefix + "size-auto-observer";
            var _classNameResizeObserverElement = _cassNamesPrefix + "resize-observer";
            var _classNameResizeObserverItemElement = _cassNamesPrefix + "resize-observer-item";
            var _classNameResizeObserverItemFinalElement = _classNameResizeObserverItemElement + "-final";
            var _classNameTextInherit = _cassNamesPrefix + "text-inherit";
            var _classNameScrollbar = _cassNamesPrefix + _strScrollbar;
            var _classNameScrollbarTrack = _classNameScrollbar + "-track";
            var _classNameScrollbarTrackOff = _classNameScrollbarTrack + "-off";
            var _classNameScrollbarHandle = _classNameScrollbar + "-handle";
            var _classNameScrollbarHandleOff = _classNameScrollbarHandle + "-off";
            var _classNameScrollbarUnusable = _classNameScrollbar + "-unusable";
            var _classNameScrollbarAutoHidden = _classNameScrollbar + "-" + _strAuto + _strMinusHidden;
            var _classNameScrollbarCorner = _classNameScrollbar + "-corner";
            var _classNameScrollbarCornerResize = _classNameScrollbarCorner + "-resize";
            var _classNameScrollbarCornerResizeB = _classNameScrollbarCornerResize + "-both";
            var _classNameScrollbarCornerResizeH = _classNameScrollbarCornerResize + _strMinusHorizontal;
            var _classNameScrollbarCornerResizeV = _classNameScrollbarCornerResize + _strMinusVertical;
            var _classNameScrollbarHorizontal = _classNameScrollbar + _strMinusHorizontal;
            var _classNameScrollbarVertical = _classNameScrollbar + _strMinusVertical;
            var _classNameDragging = _cassNamesPrefix + "dragging";
            var _classNameThemeNone = _cassNamesPrefix + "theme-none";
            var _classNamesDynamicDestroy = [
              _classNameViewportNativeScrollbarsInvisible,
              _classNameViewportNativeScrollbarsOverlaid,
              _classNameScrollbarTrackOff,
              _classNameScrollbarHandleOff,
              _classNameScrollbarUnusable,
              _classNameScrollbarAutoHidden,
              _classNameScrollbarCornerResize,
              _classNameScrollbarCornerResizeB,
              _classNameScrollbarCornerResizeH,
              _classNameScrollbarCornerResizeV,
              _classNameDragging
            ].join(_strSpace);
            var _callbacksInitQeueue = [];
            var _viewportAttrsFromTarget = [LEXICON.ti];
            var _defaultOptions;
            var _currentOptions;
            var _currentPreparedOptions;
            var _extensions = {};
            var _extensionsPrivateMethods = "added removed on contract";
            var _lastUpdateTime;
            var _swallowedUpdateHints = {};
            var _swallowedUpdateTimeout;
            var _swallowUpdateLag = 42;
            var _updateOnLoadEventName = "load";
            var _updateOnLoadElms = [];
            var _windowElement;
            var _documentElement;
            var _htmlElement;
            var _bodyElement;
            var _targetElement;
            var _hostElement;
            var _sizeAutoObserverElement;
            var _sizeObserverElement;
            var _paddingElement;
            var _viewportElement;
            var _contentElement;
            var _contentArrangeElement;
            var _contentGlueElement;
            var _textareaCoverElement;
            var _scrollbarCornerElement;
            var _scrollbarHorizontalElement;
            var _scrollbarHorizontalTrackElement;
            var _scrollbarHorizontalHandleElement;
            var _scrollbarVerticalElement;
            var _scrollbarVerticalTrackElement;
            var _scrollbarVerticalHandleElement;
            var _windowElementNative;
            var _documentElementNative;
            var _targetElementNative;
            var _hostElementNative;
            var _sizeAutoObserverElementNative;
            var _sizeObserverElementNative;
            var _paddingElementNative;
            var _viewportElementNative;
            var _contentElementNative;
            var _hostSizeCache;
            var _contentScrollSizeCache;
            var _arrangeContentSizeCache;
            var _hasOverflowCache;
            var _hideOverflowCache;
            var _widthAutoCache;
            var _heightAutoCache;
            var _cssBoxSizingCache;
            var _cssPaddingCache;
            var _cssBorderCache;
            var _cssMarginCache;
            var _cssDirectionCache;
            var _cssDirectionDetectedCache;
            var _paddingAbsoluteCache;
            var _clipAlwaysCache;
            var _contentGlueSizeCache;
            var _overflowBehaviorCache;
            var _overflowAmountCache;
            var _ignoreOverlayScrollbarHidingCache;
            var _autoUpdateCache;
            var _sizeAutoCapableCache;
            var _contentElementScrollSizeChangeDetectedCache;
            var _hostElementSizeChangeDetectedCache;
            var _scrollbarsVisibilityCache;
            var _scrollbarsAutoHideCache;
            var _scrollbarsClickScrollingCache;
            var _scrollbarsDragScrollingCache;
            var _resizeCache;
            var _normalizeRTLCache;
            var _classNameCache;
            var _oldClassName;
            var _textareaAutoWrappingCache;
            var _textareaInfoCache;
            var _textareaSizeCache;
            var _textareaDynHeightCache;
            var _textareaDynWidthCache;
            var _bodyMinSizeCache;
            var _updateAutoCache = {};
            var _mutationObserverHost;
            var _mutationObserverContent;
            var _mutationObserverHostCallback;
            var _mutationObserverContentCallback;
            var _mutationObserversConnected;
            var _mutationObserverAttrsTextarea = ["wrap", "cols", "rows"];
            var _mutationObserverAttrsHost = [LEXICON.i, LEXICON.c, LEXICON.s, "open"].concat(_viewportAttrsFromTarget);
            var _destroyEvents = [];
            var _textareaHasFocus;
            var _scrollbarsAutoHideTimeoutId;
            var _scrollbarsAutoHideMoveTimeoutId;
            var _scrollbarsAutoHideDelay;
            var _scrollbarsAutoHideNever;
            var _scrollbarsAutoHideScroll;
            var _scrollbarsAutoHideMove;
            var _scrollbarsAutoHideLeave;
            var _scrollbarsHandleHovered;
            var _scrollbarsHandlesDefineScrollPos;
            var _resizeNone;
            var _resizeBoth;
            var _resizeHorizontal;
            var _resizeVertical;
            function setupResponsiveEventListener(element, eventNames, listener, remove2, passiveOrOptions) {
              var collected = COMPATIBILITY.isA(eventNames) && COMPATIBILITY.isA(listener);
              var method = remove2 ? "removeEventListener" : "addEventListener";
              var onOff = remove2 ? "off" : "on";
              var events = collected ? false : eventNames.split(_strSpace);
              var i = 0;
              var passiveOrOptionsIsObj = FRAMEWORK.isPlainObject(passiveOrOptions);
              var passive = _supportPassiveEvents && (passiveOrOptionsIsObj ? passiveOrOptions._passive : passiveOrOptions) || false;
              var capture = passiveOrOptionsIsObj && (passiveOrOptions._capture || false);
              var nativeParam = _supportPassiveEvents ? {
                passive,
                capture
              } : capture;
              if (collected) {
                for (; i < eventNames[LEXICON.l]; i++)
                  setupResponsiveEventListener(element, eventNames[i], listener[i], remove2, passiveOrOptions);
              } else {
                for (; i < events[LEXICON.l]; i++) {
                  if (_supportPassiveEvents) {
                    element[0][method](events[i], listener, nativeParam);
                  } else {
                    element[onOff](events[i], listener);
                  }
                }
              }
            }
            function addDestroyEventListener(element, eventNames, listener, passive) {
              setupResponsiveEventListener(element, eventNames, listener, false, passive);
              _destroyEvents.push(COMPATIBILITY.bind(setupResponsiveEventListener, 0, element, eventNames, listener, true, passive));
            }
            function setupResizeObserver(targetElement, onElementResizedCallback) {
              if (targetElement) {
                var resizeObserver = COMPATIBILITY.rO();
                var strAnimationStartEvent = "animationstart mozAnimationStart webkitAnimationStart MSAnimationStart";
                var strChildNodes = "childNodes";
                var constScroll = 3333333;
                var callback = function() {
                  targetElement[_strScrollTop](constScroll)[_strScrollLeft](_isRTL ? _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll : constScroll);
                  onElementResizedCallback();
                };
                if (onElementResizedCallback) {
                  if (_supportResizeObserver) {
                    var element = targetElement.addClass("observed").append(generateDiv(_classNameResizeObserverElement)).contents()[0];
                    var observer = element[_strResizeObserverProperty] = new resizeObserver(callback);
                    observer.observe(element);
                  } else {
                    if (_msieVersion > 9 || !_autoUpdateRecommended) {
                      targetElement.prepend(
                        generateDiv(
                          _classNameResizeObserverElement,
                          generateDiv(
                            { c: _classNameResizeObserverItemElement, dir: "ltr" },
                            generateDiv(
                              _classNameResizeObserverItemElement,
                              generateDiv(_classNameResizeObserverItemFinalElement)
                            ) + generateDiv(
                              _classNameResizeObserverItemElement,
                              generateDiv({ c: _classNameResizeObserverItemFinalElement, style: "width: 200%; height: 200%" })
                            )
                          )
                        )
                      );
                      var observerElement = targetElement[0][strChildNodes][0][strChildNodes][0];
                      var shrinkElement = FRAMEWORK(observerElement[strChildNodes][1]);
                      var expandElement = FRAMEWORK(observerElement[strChildNodes][0]);
                      var expandElementChild = FRAMEWORK(expandElement[0][strChildNodes][0]);
                      var widthCache = observerElement[LEXICON.oW];
                      var heightCache = observerElement[LEXICON.oH];
                      var isDirty;
                      var rAFId;
                      var currWidth;
                      var currHeight;
                      var factor = 2;
                      var nativeScrollbarSize = globals.nativeScrollbarSize;
                      var reset = function() {
                        expandElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                        shrinkElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                      };
                      var onResized = function() {
                        rAFId = 0;
                        if (!isDirty)
                          return;
                        widthCache = currWidth;
                        heightCache = currHeight;
                        callback();
                      };
                      var onScroll = function(event) {
                        currWidth = observerElement[LEXICON.oW];
                        currHeight = observerElement[LEXICON.oH];
                        isDirty = currWidth != widthCache || currHeight != heightCache;
                        if (event && isDirty && !rAFId) {
                          COMPATIBILITY.cAF()(rAFId);
                          rAFId = COMPATIBILITY.rAF()(onResized);
                        } else if (!event)
                          onResized();
                        reset();
                        if (event) {
                          COMPATIBILITY.prvD(event);
                          COMPATIBILITY.stpP(event);
                        }
                        return false;
                      };
                      var expandChildCSS = {};
                      var observerElementCSS = {};
                      setTopRightBottomLeft(observerElementCSS, _strEmpty, [
                        -((nativeScrollbarSize.y + 1) * factor),
                        nativeScrollbarSize.x * -factor,
                        nativeScrollbarSize.y * -factor,
                        -((nativeScrollbarSize.x + 1) * factor)
                      ]);
                      FRAMEWORK(observerElement).css(observerElementCSS);
                      expandElement.on(_strScroll, onScroll);
                      shrinkElement.on(_strScroll, onScroll);
                      targetElement.on(strAnimationStartEvent, function() {
                        onScroll(false);
                      });
                      expandChildCSS[_strWidth] = constScroll;
                      expandChildCSS[_strHeight] = constScroll;
                      expandElementChild.css(expandChildCSS);
                      reset();
                    } else {
                      var attachEvent = _documentElementNative.attachEvent;
                      var isIE = _msieVersion !== undefined2;
                      if (attachEvent) {
                        targetElement.prepend(generateDiv(_classNameResizeObserverElement));
                        findFirst(targetElement, _strDot + _classNameResizeObserverElement)[0].attachEvent("onresize", callback);
                      } else {
                        var obj = _documentElementNative.createElement(TYPES.o);
                        obj.setAttribute(LEXICON.ti, "-1");
                        obj.setAttribute(LEXICON.c, _classNameResizeObserverElement);
                        obj.onload = function() {
                          var wnd = this.contentDocument.defaultView;
                          wnd.addEventListener("resize", callback);
                          wnd.document.documentElement.style.display = "none";
                        };
                        obj.type = "text/html";
                        if (isIE)
                          targetElement.prepend(obj);
                        obj.data = "about:blank";
                        if (!isIE)
                          targetElement.prepend(obj);
                        targetElement.on(strAnimationStartEvent, callback);
                      }
                    }
                  }
                  if (targetElement[0] === _sizeObserverElementNative) {
                    var directionChanged = function() {
                      var dir = _hostElement.css("direction");
                      var css2 = {};
                      var scrollLeftValue = 0;
                      var result = false;
                      if (dir !== _cssDirectionDetectedCache) {
                        if (dir === "ltr") {
                          css2[_strLeft] = 0;
                          css2[_strRight] = _strAuto;
                          scrollLeftValue = constScroll;
                        } else {
                          css2[_strLeft] = _strAuto;
                          css2[_strRight] = 0;
                          scrollLeftValue = _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll;
                        }
                        _sizeObserverElement.children().eq(0).css(css2);
                        _sizeObserverElement[_strScrollLeft](scrollLeftValue)[_strScrollTop](constScroll);
                        _cssDirectionDetectedCache = dir;
                        result = true;
                      }
                      return result;
                    };
                    directionChanged();
                    addDestroyEventListener(targetElement, _strScroll, function(event) {
                      if (directionChanged())
                        update();
                      COMPATIBILITY.prvD(event);
                      COMPATIBILITY.stpP(event);
                      return false;
                    });
                  }
                } else {
                  if (_supportResizeObserver) {
                    var element = targetElement.contents()[0];
                    var resizeObserverObj = element[_strResizeObserverProperty];
                    if (resizeObserverObj) {
                      resizeObserverObj.disconnect();
                      delete element[_strResizeObserverProperty];
                    }
                  } else {
                    remove(targetElement.children(_strDot + _classNameResizeObserverElement).eq(0));
                  }
                }
              }
            }
            function createMutationObservers() {
              if (_supportMutationObserver) {
                var mutationObserverContentLag = 11;
                var mutationObserver = COMPATIBILITY.mO();
                var contentLastUpdate = COMPATIBILITY.now();
                var mutationTarget;
                var mutationAttrName;
                var mutationIsClass;
                var oldMutationVal;
                var newClassVal;
                var hostClassNameRegex;
                var contentTimeout;
                var now;
                var sizeAuto;
                var action;
                _mutationObserverHostCallback = function(mutations) {
                  var doUpdate = false;
                  var doUpdateForce = false;
                  var mutation;
                  var mutatedAttrs = [];
                  if (_initialized && !_sleeping) {
                    each(mutations, function() {
                      mutation = this;
                      mutationTarget = mutation.target;
                      mutationAttrName = mutation.attributeName;
                      mutationIsClass = mutationAttrName === LEXICON.c;
                      oldMutationVal = mutation.oldValue;
                      newClassVal = mutationTarget.className;
                      if (_domExists && mutationIsClass && !doUpdateForce) {
                        if (oldMutationVal.indexOf(_classNameHostElementForeign) > -1 && newClassVal.indexOf(_classNameHostElementForeign) < 0) {
                          hostClassNameRegex = createHostClassNameRegExp(true);
                          _hostElementNative.className = newClassVal.split(_strSpace).concat(oldMutationVal.split(_strSpace).filter(function(name) {
                            return name.match(hostClassNameRegex);
                          })).join(_strSpace);
                          doUpdate = doUpdateForce = true;
                        }
                      }
                      if (!doUpdate) {
                        doUpdate = mutationIsClass ? hostClassNamesChanged(oldMutationVal, newClassVal) : mutationAttrName === LEXICON.s ? oldMutationVal !== mutationTarget[LEXICON.s].cssText : true;
                      }
                      mutatedAttrs.push(mutationAttrName);
                    });
                    updateViewportAttrsFromTarget(mutatedAttrs);
                    if (doUpdate)
                      _base.update(doUpdateForce || _strAuto);
                  }
                  return doUpdate;
                };
                _mutationObserverContentCallback = function(mutations) {
                  var doUpdate = false;
                  var mutation;
                  if (_initialized && !_sleeping) {
                    each(mutations, function() {
                      mutation = this;
                      doUpdate = isUnknownMutation(mutation);
                      return !doUpdate;
                    });
                    if (doUpdate) {
                      now = COMPATIBILITY.now();
                      sizeAuto = _heightAutoCache || _widthAutoCache;
                      action = function() {
                        if (!_destroyed) {
                          contentLastUpdate = now;
                          if (_isTextarea)
                            textareaUpdate();
                          if (sizeAuto)
                            update();
                          else
                            _base.update(_strAuto);
                        }
                      };
                      clearTimeout(contentTimeout);
                      if (mutationObserverContentLag <= 0 || now - contentLastUpdate > mutationObserverContentLag || !sizeAuto)
                        action();
                      else
                        contentTimeout = setTimeout(action, mutationObserverContentLag);
                    }
                  }
                  return doUpdate;
                };
                _mutationObserverHost = new mutationObserver(_mutationObserverHostCallback);
                _mutationObserverContent = new mutationObserver(_mutationObserverContentCallback);
              }
            }
            function connectMutationObservers() {
              if (_supportMutationObserver && !_mutationObserversConnected) {
                _mutationObserverHost.observe(_hostElementNative, {
                  attributes: true,
                  attributeOldValue: true,
                  attributeFilter: _mutationObserverAttrsHost
                });
                _mutationObserverContent.observe(_isTextarea ? _targetElementNative : _contentElementNative, {
                  attributes: true,
                  attributeOldValue: true,
                  subtree: !_isTextarea,
                  childList: !_isTextarea,
                  characterData: !_isTextarea,
                  attributeFilter: _isTextarea ? _mutationObserverAttrsTextarea : _mutationObserverAttrsHost
                });
                _mutationObserversConnected = true;
              }
            }
            function disconnectMutationObservers() {
              if (_supportMutationObserver && _mutationObserversConnected) {
                _mutationObserverHost.disconnect();
                _mutationObserverContent.disconnect();
                _mutationObserversConnected = false;
              }
            }
            function hostOnResized() {
              if (!_sleeping) {
                var changed;
                var hostSize = {
                  w: _sizeObserverElementNative[LEXICON.sW],
                  h: _sizeObserverElementNative[LEXICON.sH]
                };
                changed = checkCache(hostSize, _hostElementSizeChangeDetectedCache);
                _hostElementSizeChangeDetectedCache = hostSize;
                if (changed)
                  update({ _hostSizeChanged: true });
              }
            }
            function hostOnMouseEnter() {
              if (_scrollbarsAutoHideLeave)
                refreshScrollbarsAutoHide(true);
            }
            function hostOnMouseLeave() {
              if (_scrollbarsAutoHideLeave && !_bodyElement.hasClass(_classNameDragging))
                refreshScrollbarsAutoHide(false);
            }
            function hostOnMouseMove() {
              if (_scrollbarsAutoHideMove) {
                refreshScrollbarsAutoHide(true);
                clearTimeout(_scrollbarsAutoHideMoveTimeoutId);
                _scrollbarsAutoHideMoveTimeoutId = setTimeout(function() {
                  if (_scrollbarsAutoHideMove && !_destroyed)
                    refreshScrollbarsAutoHide(false);
                }, 100);
              }
            }
            function documentOnSelectStart(event) {
              COMPATIBILITY.prvD(event);
              return false;
            }
            function updateOnLoadCallback(event) {
              if (!_destroyed) {
                var target = event.target;
                var elm = FRAMEWORK(event.target);
                var index = FRAMEWORK.inArray(target, _updateOnLoadElms);
                if (index > -1) {
                  _updateOnLoadElms.splice(index, 1);
                }
                eachUpdateOnLoad(function(i, updateOnLoadSelector) {
                  if (elm.is(updateOnLoadSelector)) {
                    update({ _contentSizeChanged: true });
                  }
                });
              }
            }
            function setupHostMouseTouchEvents(destroy) {
              if (!destroy)
                setupHostMouseTouchEvents(true);
              setupResponsiveEventListener(
                _hostElement,
                _strMouseTouchMoveEvent.split(_strSpace)[0],
                hostOnMouseMove,
                !_scrollbarsAutoHideMove || destroy,
                true
              );
              setupResponsiveEventListener(
                _hostElement,
                [_strMouseEnter, _strMouseLeave],
                [hostOnMouseEnter, hostOnMouseLeave],
                !_scrollbarsAutoHideLeave || destroy,
                true
              );
              if (!_initialized && !destroy)
                _hostElement.one("mouseover", hostOnMouseEnter);
            }
            function bodyMinSizeChanged() {
              var bodyMinSize = {};
              if (_isBody && _contentArrangeElement) {
                bodyMinSize.w = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strWidth));
                bodyMinSize.h = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strHeight));
                bodyMinSize.c = checkCache(bodyMinSize, _bodyMinSizeCache);
                bodyMinSize.f = true;
              }
              _bodyMinSizeCache = bodyMinSize;
              return !!bodyMinSize.c;
            }
            function hostClassNamesChanged(oldClassNames, newClassNames) {
              var currClasses = typeof newClassNames == TYPES.s ? newClassNames.split(_strSpace) : [];
              var oldClasses = typeof oldClassNames == TYPES.s ? oldClassNames.split(_strSpace) : [];
              var diff = getArrayDifferences(oldClasses, currClasses);
              var idx = inArray(_classNameThemeNone, diff);
              var i;
              var regex;
              if (idx > -1)
                diff.splice(idx, 1);
              if (diff[LEXICON.l] > 0) {
                regex = createHostClassNameRegExp(true, true);
                for (i = 0; i < diff.length; i++) {
                  if (!diff[i].match(regex)) {
                    return true;
                  }
                }
              }
              return false;
            }
            function isUnknownMutation(mutation) {
              var attributeName = mutation.attributeName;
              var mutationTarget = mutation.target;
              var mutationType = mutation.type;
              var strClosest = "closest";
              if (mutationTarget === _contentElementNative)
                return attributeName === null;
              if (mutationType === "attributes" && (attributeName === LEXICON.c || attributeName === LEXICON.s) && !_isTextarea) {
                if (attributeName === LEXICON.c && FRAMEWORK(mutationTarget).hasClass(_classNameHostElement))
                  return hostClassNamesChanged(mutation.oldValue, mutationTarget.className);
                if (typeof mutationTarget[strClosest] != TYPES.f)
                  return true;
                if (mutationTarget[strClosest](_strDot + _classNameResizeObserverElement) !== null || mutationTarget[strClosest](_strDot + _classNameScrollbar) !== null || mutationTarget[strClosest](_strDot + _classNameScrollbarCorner) !== null)
                  return false;
              }
              return true;
            }
            function updateAutoContentSizeChanged() {
              if (_sleeping)
                return false;
              var contentMeasureElement = getContentMeasureElement();
              var textareaValueLength = _isTextarea && _widthAutoCache && !_textareaAutoWrappingCache ? _targetElement.val().length : 0;
              var setCSS = !_mutationObserversConnected && _widthAutoCache && !_isTextarea;
              var css2 = {};
              var float;
              var bodyMinSizeC;
              var changed;
              var contentElementScrollSize;
              if (setCSS) {
                float = _contentElement.css(_strFloat);
                css2[_strFloat] = _isRTL ? _strRight : _strLeft;
                css2[_strWidth] = _strAuto;
                _contentElement.css(css2);
              }
              contentElementScrollSize = {
                w: contentMeasureElement[LEXICON.sW] + textareaValueLength,
                h: contentMeasureElement[LEXICON.sH] + textareaValueLength
              };
              if (setCSS) {
                css2[_strFloat] = float;
                css2[_strWidth] = _strHundredPercent;
                _contentElement.css(css2);
              }
              bodyMinSizeC = bodyMinSizeChanged();
              changed = checkCache(contentElementScrollSize, _contentElementScrollSizeChangeDetectedCache);
              _contentElementScrollSizeChangeDetectedCache = contentElementScrollSize;
              return changed || bodyMinSizeC;
            }
            function meaningfulAttrsChanged() {
              if (_sleeping || _mutationObserversConnected)
                return;
              var elem;
              var curr;
              var cache;
              var changedAttrs = [];
              var checks = [
                {
                  _elem: _hostElement,
                  _attrs: _mutationObserverAttrsHost.concat(":visible")
                },
                {
                  _elem: _isTextarea ? _targetElement : undefined2,
                  _attrs: _mutationObserverAttrsTextarea
                }
              ];
              each(checks, function(index, check) {
                elem = check._elem;
                if (elem) {
                  each(check._attrs, function(index2, attr) {
                    curr = attr.charAt(0) === ":" ? elem.is(attr) : elem.attr(attr);
                    cache = _updateAutoCache[attr];
                    if (checkCache(curr, cache)) {
                      changedAttrs.push(attr);
                    }
                    _updateAutoCache[attr] = curr;
                  });
                }
              });
              updateViewportAttrsFromTarget(changedAttrs);
              return changedAttrs[LEXICON.l] > 0;
            }
            function isSizeAffectingCSSProperty(propertyName) {
              if (!_initialized)
                return true;
              var flexGrow = "flex-grow";
              var flexShrink = "flex-shrink";
              var flexBasis = "flex-basis";
              var affectingPropsX = [
                _strWidth,
                _strMinMinus + _strWidth,
                _strMaxMinus + _strWidth,
                _strMarginMinus + _strLeft,
                _strMarginMinus + _strRight,
                _strLeft,
                _strRight,
                "font-weight",
                "word-spacing",
                flexGrow,
                flexShrink,
                flexBasis
              ];
              var affectingPropsXContentBox = [
                _strPaddingMinus + _strLeft,
                _strPaddingMinus + _strRight,
                _strBorderMinus + _strLeft + _strWidth,
                _strBorderMinus + _strRight + _strWidth
              ];
              var affectingPropsY = [
                _strHeight,
                _strMinMinus + _strHeight,
                _strMaxMinus + _strHeight,
                _strMarginMinus + _strTop,
                _strMarginMinus + _strBottom,
                _strTop,
                _strBottom,
                "line-height",
                flexGrow,
                flexShrink,
                flexBasis
              ];
              var affectingPropsYContentBox = [
                _strPaddingMinus + _strTop,
                _strPaddingMinus + _strBottom,
                _strBorderMinus + _strTop + _strWidth,
                _strBorderMinus + _strBottom + _strWidth
              ];
              var _strS = "s";
              var _strVS = "v-s";
              var checkX = _overflowBehaviorCache.x === _strS || _overflowBehaviorCache.x === _strVS;
              var checkY = _overflowBehaviorCache.y === _strS || _overflowBehaviorCache.y === _strVS;
              var sizeIsAffected = false;
              var checkPropertyName = function(arr, name) {
                for (var i = 0; i < arr[LEXICON.l]; i++) {
                  if (arr[i] === name)
                    return true;
                }
                return false;
              };
              if (checkY) {
                sizeIsAffected = checkPropertyName(affectingPropsY, propertyName);
                if (!sizeIsAffected && !_isBorderBox)
                  sizeIsAffected = checkPropertyName(affectingPropsYContentBox, propertyName);
              }
              if (checkX && !sizeIsAffected) {
                sizeIsAffected = checkPropertyName(affectingPropsX, propertyName);
                if (!sizeIsAffected && !_isBorderBox)
                  sizeIsAffected = checkPropertyName(affectingPropsXContentBox, propertyName);
              }
              return sizeIsAffected;
            }
            function updateViewportAttrsFromTarget(attrs) {
              attrs = attrs || _viewportAttrsFromTarget;
              each(attrs, function(index, attr) {
                if (COMPATIBILITY.inA(attr, _viewportAttrsFromTarget) > -1) {
                  var targetAttr = _targetElement.attr(attr);
                  if (type(targetAttr) == TYPES.s) {
                    _viewportElement.attr(attr, targetAttr);
                  } else {
                    _viewportElement.removeAttr(attr);
                  }
                }
              });
            }
            function textareaUpdate() {
              if (!_sleeping) {
                var wrapAttrOff = !_textareaAutoWrappingCache;
                var minWidth = _viewportSize.w;
                var minHeight = _viewportSize.h;
                var css2 = {};
                var doMeasure = _widthAutoCache || wrapAttrOff;
                var origWidth;
                var width;
                var origHeight;
                var height;
                css2[_strMinMinus + _strWidth] = _strEmpty;
                css2[_strMinMinus + _strHeight] = _strEmpty;
                css2[_strWidth] = _strAuto;
                _targetElement.css(css2);
                origWidth = _targetElementNative[LEXICON.oW];
                width = doMeasure ? MATH.max(origWidth, _targetElementNative[LEXICON.sW] - 1) : 1;
                css2[_strWidth] = _widthAutoCache ? _strAuto : _strHundredPercent;
                css2[_strMinMinus + _strWidth] = _strHundredPercent;
                css2[_strHeight] = _strAuto;
                _targetElement.css(css2);
                origHeight = _targetElementNative[LEXICON.oH];
                height = MATH.max(origHeight, _targetElementNative[LEXICON.sH] - 1);
                css2[_strWidth] = width;
                css2[_strHeight] = height;
                _textareaCoverElement.css(css2);
                css2[_strMinMinus + _strWidth] = minWidth;
                css2[_strMinMinus + _strHeight] = minHeight;
                _targetElement.css(css2);
                return {
                  _originalWidth: origWidth,
                  _originalHeight: origHeight,
                  _dynamicWidth: width,
                  _dynamicHeight: height
                };
              }
            }
            function update(updateHints) {
              clearTimeout(_swallowedUpdateTimeout);
              updateHints = updateHints || {};
              _swallowedUpdateHints._hostSizeChanged |= updateHints._hostSizeChanged;
              _swallowedUpdateHints._contentSizeChanged |= updateHints._contentSizeChanged;
              _swallowedUpdateHints._force |= updateHints._force;
              var now = COMPATIBILITY.now();
              var hostSizeChanged = !!_swallowedUpdateHints._hostSizeChanged;
              var contentSizeChanged = !!_swallowedUpdateHints._contentSizeChanged;
              var force = !!_swallowedUpdateHints._force;
              var changedOptions = updateHints._changedOptions;
              var swallow = _swallowUpdateLag > 0 && _initialized && !_destroyed && !force && !changedOptions && now - _lastUpdateTime < _swallowUpdateLag && (!_heightAutoCache && !_widthAutoCache);
              var displayIsHidden;
              if (swallow)
                _swallowedUpdateTimeout = setTimeout(update, _swallowUpdateLag);
              if (_destroyed || swallow || _sleeping && !changedOptions || _initialized && !force && (displayIsHidden = _hostElement.is(":hidden")) || _hostElement.css("display") === "inline")
                return;
              _lastUpdateTime = now;
              _swallowedUpdateHints = {};
              if (_nativeScrollbarStyling && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                _nativeScrollbarSize.x = 0;
                _nativeScrollbarSize.y = 0;
              } else {
                _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
              }
              _nativeScrollbarMinSize = {
                x: (_nativeScrollbarSize.x + (_nativeScrollbarIsOverlaid.x ? 0 : 3)) * 3,
                y: (_nativeScrollbarSize.y + (_nativeScrollbarIsOverlaid.y ? 0 : 3)) * 3
              };
              changedOptions = changedOptions || {};
              var checkCacheAutoForce = function() {
                return checkCache.apply(this, [].slice.call(arguments).concat([force]));
              };
              var currScroll = {
                x: _viewportElement[_strScrollLeft](),
                y: _viewportElement[_strScrollTop]()
              };
              var currentPreparedOptionsScrollbars = _currentPreparedOptions.scrollbars;
              var currentPreparedOptionsTextarea = _currentPreparedOptions.textarea;
              var scrollbarsVisibility = currentPreparedOptionsScrollbars.visibility;
              var scrollbarsVisibilityChanged = checkCacheAutoForce(scrollbarsVisibility, _scrollbarsVisibilityCache);
              var scrollbarsAutoHide = currentPreparedOptionsScrollbars.autoHide;
              var scrollbarsAutoHideChanged = checkCacheAutoForce(scrollbarsAutoHide, _scrollbarsAutoHideCache);
              var scrollbarsClickScrolling = currentPreparedOptionsScrollbars.clickScrolling;
              var scrollbarsClickScrollingChanged = checkCacheAutoForce(scrollbarsClickScrolling, _scrollbarsClickScrollingCache);
              var scrollbarsDragScrolling = currentPreparedOptionsScrollbars.dragScrolling;
              var scrollbarsDragScrollingChanged = checkCacheAutoForce(scrollbarsDragScrolling, _scrollbarsDragScrollingCache);
              var className = _currentPreparedOptions.className;
              var classNameChanged = checkCacheAutoForce(className, _classNameCache);
              var resize = _currentPreparedOptions.resize;
              var resizeChanged = checkCacheAutoForce(resize, _resizeCache) && !_isBody;
              var paddingAbsolute = _currentPreparedOptions.paddingAbsolute;
              var paddingAbsoluteChanged = checkCacheAutoForce(paddingAbsolute, _paddingAbsoluteCache);
              var clipAlways = _currentPreparedOptions.clipAlways;
              var clipAlwaysChanged = checkCacheAutoForce(clipAlways, _clipAlwaysCache);
              var sizeAutoCapable = _currentPreparedOptions.sizeAutoCapable && !_isBody;
              var sizeAutoCapableChanged = checkCacheAutoForce(sizeAutoCapable, _sizeAutoCapableCache);
              var ignoreOverlayScrollbarHiding = _currentPreparedOptions.nativeScrollbarsOverlaid.showNativeScrollbars;
              var ignoreOverlayScrollbarHidingChanged = checkCacheAutoForce(ignoreOverlayScrollbarHiding, _ignoreOverlayScrollbarHidingCache);
              var autoUpdate = _currentPreparedOptions.autoUpdate;
              var autoUpdateChanged = checkCacheAutoForce(autoUpdate, _autoUpdateCache);
              var overflowBehavior = _currentPreparedOptions.overflowBehavior;
              var overflowBehaviorChanged = checkCacheAutoForce(overflowBehavior, _overflowBehaviorCache, force);
              var textareaDynWidth = currentPreparedOptionsTextarea.dynWidth;
              var textareaDynWidthChanged = checkCacheAutoForce(_textareaDynWidthCache, textareaDynWidth);
              var textareaDynHeight = currentPreparedOptionsTextarea.dynHeight;
              var textareaDynHeightChanged = checkCacheAutoForce(_textareaDynHeightCache, textareaDynHeight);
              _scrollbarsAutoHideNever = scrollbarsAutoHide === "n";
              _scrollbarsAutoHideScroll = scrollbarsAutoHide === "s";
              _scrollbarsAutoHideMove = scrollbarsAutoHide === "m";
              _scrollbarsAutoHideLeave = scrollbarsAutoHide === "l";
              _scrollbarsAutoHideDelay = currentPreparedOptionsScrollbars.autoHideDelay;
              _oldClassName = _classNameCache;
              _resizeNone = resize === "n";
              _resizeBoth = resize === "b";
              _resizeHorizontal = resize === "h";
              _resizeVertical = resize === "v";
              _normalizeRTLCache = _currentPreparedOptions.normalizeRTL;
              ignoreOverlayScrollbarHiding = ignoreOverlayScrollbarHiding && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y);
              _scrollbarsVisibilityCache = scrollbarsVisibility;
              _scrollbarsAutoHideCache = scrollbarsAutoHide;
              _scrollbarsClickScrollingCache = scrollbarsClickScrolling;
              _scrollbarsDragScrollingCache = scrollbarsDragScrolling;
              _classNameCache = className;
              _resizeCache = resize;
              _paddingAbsoluteCache = paddingAbsolute;
              _clipAlwaysCache = clipAlways;
              _sizeAutoCapableCache = sizeAutoCapable;
              _ignoreOverlayScrollbarHidingCache = ignoreOverlayScrollbarHiding;
              _autoUpdateCache = autoUpdate;
              _overflowBehaviorCache = extendDeep({}, overflowBehavior);
              _textareaDynWidthCache = textareaDynWidth;
              _textareaDynHeightCache = textareaDynHeight;
              _hasOverflowCache = _hasOverflowCache || { x: false, y: false };
              if (classNameChanged) {
                removeClass(_hostElement, _oldClassName + _strSpace + _classNameThemeNone);
                addClass(_hostElement, className !== undefined2 && className !== null && className.length > 0 ? className : _classNameThemeNone);
              }
              if (autoUpdateChanged) {
                if (autoUpdate === true || autoUpdate === null && _autoUpdateRecommended) {
                  disconnectMutationObservers();
                  autoUpdateLoop.add(_base);
                } else {
                  autoUpdateLoop.remove(_base);
                  connectMutationObservers();
                }
              }
              if (sizeAutoCapableChanged) {
                if (sizeAutoCapable) {
                  if (_contentGlueElement) {
                    _contentGlueElement.show();
                  } else {
                    _contentGlueElement = FRAMEWORK(generateDiv(_classNameContentGlueElement));
                    _paddingElement.before(_contentGlueElement);
                  }
                  if (_sizeAutoObserverAdded) {
                    _sizeAutoObserverElement.show();
                  } else {
                    _sizeAutoObserverElement = FRAMEWORK(generateDiv(_classNameSizeAutoObserverElement));
                    _sizeAutoObserverElementNative = _sizeAutoObserverElement[0];
                    _contentGlueElement.before(_sizeAutoObserverElement);
                    var oldSize = { w: -1, h: -1 };
                    setupResizeObserver(_sizeAutoObserverElement, function() {
                      var newSize = {
                        w: _sizeAutoObserverElementNative[LEXICON.oW],
                        h: _sizeAutoObserverElementNative[LEXICON.oH]
                      };
                      if (checkCache(newSize, oldSize)) {
                        if (_initialized && (_heightAutoCache && newSize.h > 0) || _widthAutoCache && newSize.w > 0) {
                          update();
                        } else if (_initialized && (!_heightAutoCache && newSize.h === 0) || !_widthAutoCache && newSize.w === 0) {
                          update();
                        }
                      }
                      oldSize = newSize;
                    });
                    _sizeAutoObserverAdded = true;
                    if (_cssCalc !== null)
                      _sizeAutoObserverElement.css(_strHeight, _cssCalc + "(100% + 1px)");
                  }
                } else {
                  if (_sizeAutoObserverAdded)
                    _sizeAutoObserverElement.hide();
                  if (_contentGlueElement)
                    _contentGlueElement.hide();
                }
              }
              if (force) {
                _sizeObserverElement.find("*").trigger(_strScroll);
                if (_sizeAutoObserverAdded)
                  _sizeAutoObserverElement.find("*").trigger(_strScroll);
              }
              displayIsHidden = displayIsHidden === undefined2 ? _hostElement.is(":hidden") : displayIsHidden;
              var textareaAutoWrapping = _isTextarea ? _targetElement.attr("wrap") !== "off" : false;
              var textareaAutoWrappingChanged = checkCacheAutoForce(textareaAutoWrapping, _textareaAutoWrappingCache);
              var cssDirection = _hostElement.css("direction");
              var cssDirectionChanged = checkCacheAutoForce(cssDirection, _cssDirectionCache);
              var boxSizing = _hostElement.css("box-sizing");
              var boxSizingChanged = checkCacheAutoForce(boxSizing, _cssBoxSizingCache);
              var padding = getTopRightBottomLeftHost(_strPaddingMinus);
              var sizeAutoObserverElementBCRect;
              try {
                sizeAutoObserverElementBCRect = _sizeAutoObserverAdded ? _sizeAutoObserverElementNative[LEXICON.bCR]() : null;
              } catch (ex) {
                return;
              }
              _isRTL = cssDirection === "rtl";
              _isBorderBox = boxSizing === "border-box";
              var isRTLLeft = _isRTL ? _strLeft : _strRight;
              var isRTLRight = _isRTL ? _strRight : _strLeft;
              var widthAutoResizeDetection = false;
              var widthAutoObserverDetection = _sizeAutoObserverAdded && _hostElement.css(_strFloat) !== "none" ? MATH.round(sizeAutoObserverElementBCRect.right - sizeAutoObserverElementBCRect.left) === 0 && (!paddingAbsolute ? _hostElementNative[LEXICON.cW] - _paddingX > 0 : true) : false;
              if (sizeAutoCapable && !widthAutoObserverDetection) {
                var tmpCurrHostWidth = _hostElementNative[LEXICON.oW];
                var tmpCurrContentGlueWidth = _contentGlueElement.css(_strWidth);
                _contentGlueElement.css(_strWidth, _strAuto);
                var tmpNewHostWidth = _hostElementNative[LEXICON.oW];
                _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
                widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
                if (!widthAutoResizeDetection) {
                  _contentGlueElement.css(_strWidth, tmpCurrHostWidth + 1);
                  tmpNewHostWidth = _hostElementNative[LEXICON.oW];
                  _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
                  widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
                }
              }
              var widthAuto = (widthAutoObserverDetection || widthAutoResizeDetection) && sizeAutoCapable && !displayIsHidden;
              var widthAutoChanged = checkCacheAutoForce(widthAuto, _widthAutoCache);
              var wasWidthAuto = !widthAuto && _widthAutoCache;
              var heightAuto = _sizeAutoObserverAdded && sizeAutoCapable && !displayIsHidden ? MATH.round(sizeAutoObserverElementBCRect.bottom - sizeAutoObserverElementBCRect.top) === 0 : false;
              var heightAutoChanged = checkCacheAutoForce(heightAuto, _heightAutoCache);
              var wasHeightAuto = !heightAuto && _heightAutoCache;
              var updateBorderX = widthAuto && _isBorderBox || !_isBorderBox;
              var updateBorderY = heightAuto && _isBorderBox || !_isBorderBox;
              var border = getTopRightBottomLeftHost(_strBorderMinus, "-" + _strWidth, !updateBorderX, !updateBorderY);
              var margin = getTopRightBottomLeftHost(_strMarginMinus);
              var contentElementCSS = {};
              var contentGlueElementCSS = {};
              var getHostSize = function() {
                return {
                  w: _hostElementNative[LEXICON.cW],
                  h: _hostElementNative[LEXICON.cH]
                };
              };
              var getViewportSize = function() {
                return {
                  w: _paddingElementNative[LEXICON.oW] + MATH.max(0, _contentElementNative[LEXICON.cW] - _contentElementNative[LEXICON.sW]),
                  h: _paddingElementNative[LEXICON.oH] + MATH.max(0, _contentElementNative[LEXICON.cH] - _contentElementNative[LEXICON.sH])
                };
              };
              var paddingAbsoluteX = _paddingX = padding.l + padding.r;
              var paddingAbsoluteY = _paddingY = padding.t + padding.b;
              paddingAbsoluteX *= paddingAbsolute ? 1 : 0;
              paddingAbsoluteY *= paddingAbsolute ? 1 : 0;
              padding.c = checkCacheAutoForce(padding, _cssPaddingCache);
              _borderX = border.l + border.r;
              _borderY = border.t + border.b;
              border.c = checkCacheAutoForce(border, _cssBorderCache);
              _marginX = margin.l + margin.r;
              _marginY = margin.t + margin.b;
              margin.c = checkCacheAutoForce(margin, _cssMarginCache);
              _textareaAutoWrappingCache = textareaAutoWrapping;
              _cssDirectionCache = cssDirection;
              _cssBoxSizingCache = boxSizing;
              _widthAutoCache = widthAuto;
              _heightAutoCache = heightAuto;
              _cssPaddingCache = padding;
              _cssBorderCache = border;
              _cssMarginCache = margin;
              if (cssDirectionChanged && _sizeAutoObserverAdded)
                _sizeAutoObserverElement.css(_strFloat, isRTLRight);
              if (padding.c || cssDirectionChanged || paddingAbsoluteChanged || widthAutoChanged || heightAutoChanged || boxSizingChanged || sizeAutoCapableChanged) {
                var paddingElementCSS = {};
                var textareaCSS = {};
                var paddingValues = [padding.t, padding.r, padding.b, padding.l];
                setTopRightBottomLeft(contentGlueElementCSS, _strMarginMinus, [-padding.t, -padding.r, -padding.b, -padding.l]);
                if (paddingAbsolute) {
                  setTopRightBottomLeft(paddingElementCSS, _strEmpty, paddingValues);
                  setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus);
                } else {
                  setTopRightBottomLeft(paddingElementCSS, _strEmpty);
                  setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus, paddingValues);
                }
                _paddingElement.css(paddingElementCSS);
                _targetElement.css(textareaCSS);
              }
              _viewportSize = getViewportSize();
              var textareaSize = _isTextarea ? textareaUpdate() : false;
              var textareaSizeChanged = _isTextarea && checkCacheAutoForce(textareaSize, _textareaSizeCache);
              var textareaDynOrigSize = _isTextarea && textareaSize ? {
                w: textareaDynWidth ? textareaSize._dynamicWidth : textareaSize._originalWidth,
                h: textareaDynHeight ? textareaSize._dynamicHeight : textareaSize._originalHeight
              } : {};
              _textareaSizeCache = textareaSize;
              if (heightAuto && (heightAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c)) {
                contentElementCSS[_strHeight] = _strAuto;
              } else if (heightAutoChanged || paddingAbsoluteChanged) {
                contentElementCSS[_strHeight] = _strHundredPercent;
              }
              if (widthAuto && (widthAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c || cssDirectionChanged)) {
                contentElementCSS[_strWidth] = _strAuto;
                contentGlueElementCSS[_strMaxMinus + _strWidth] = _strHundredPercent;
              } else if (widthAutoChanged || paddingAbsoluteChanged) {
                contentElementCSS[_strWidth] = _strHundredPercent;
                contentElementCSS[_strFloat] = _strEmpty;
                contentGlueElementCSS[_strMaxMinus + _strWidth] = _strEmpty;
              }
              if (widthAuto) {
                contentGlueElementCSS[_strWidth] = _strAuto;
                contentElementCSS[_strWidth] = VENDORS._cssPropertyValue(_strWidth, "max-content intrinsic") || _strAuto;
                contentElementCSS[_strFloat] = isRTLRight;
              } else {
                contentGlueElementCSS[_strWidth] = _strEmpty;
              }
              if (heightAuto) {
                contentGlueElementCSS[_strHeight] = textareaDynOrigSize.h || _contentElementNative[LEXICON.cH];
              } else {
                contentGlueElementCSS[_strHeight] = _strEmpty;
              }
              if (sizeAutoCapable)
                _contentGlueElement.css(contentGlueElementCSS);
              _contentElement.css(contentElementCSS);
              contentElementCSS = {};
              contentGlueElementCSS = {};
              if (hostSizeChanged || contentSizeChanged || textareaSizeChanged || cssDirectionChanged || boxSizingChanged || paddingAbsoluteChanged || widthAutoChanged || widthAuto || heightAutoChanged || heightAuto || ignoreOverlayScrollbarHidingChanged || overflowBehaviorChanged || clipAlwaysChanged || resizeChanged || scrollbarsVisibilityChanged || scrollbarsAutoHideChanged || scrollbarsDragScrollingChanged || scrollbarsClickScrollingChanged || textareaDynWidthChanged || textareaDynHeightChanged || textareaAutoWrappingChanged) {
                var strOverflow = "overflow";
                var strOverflowX = strOverflow + "-x";
                var strOverflowY = strOverflow + "-y";
                var strHidden = "hidden";
                var strVisible = "visible";
                if (!_nativeScrollbarStyling) {
                  var viewportElementResetCSS = {};
                  var resetXTmp = _hasOverflowCache.y && _hideOverflowCache.ys && !ignoreOverlayScrollbarHiding ? _nativeScrollbarIsOverlaid.y ? _viewportElement.css(isRTLLeft) : -_nativeScrollbarSize.y : 0;
                  var resetBottomTmp = _hasOverflowCache.x && _hideOverflowCache.xs && !ignoreOverlayScrollbarHiding ? _nativeScrollbarIsOverlaid.x ? _viewportElement.css(_strBottom) : -_nativeScrollbarSize.x : 0;
                  setTopRightBottomLeft(viewportElementResetCSS, _strEmpty);
                  _viewportElement.css(viewportElementResetCSS);
                }
                var contentMeasureElement = getContentMeasureElement();
                var contentSize = {
                  w: textareaDynOrigSize.w || contentMeasureElement[LEXICON.cW],
                  h: textareaDynOrigSize.h || contentMeasureElement[LEXICON.cH]
                };
                var scrollSize = {
                  w: contentMeasureElement[LEXICON.sW],
                  h: contentMeasureElement[LEXICON.sH]
                };
                if (!_nativeScrollbarStyling) {
                  viewportElementResetCSS[_strBottom] = wasHeightAuto ? _strEmpty : resetBottomTmp;
                  viewportElementResetCSS[isRTLLeft] = wasWidthAuto ? _strEmpty : resetXTmp;
                  _viewportElement.css(viewportElementResetCSS);
                }
                _viewportSize = getViewportSize();
                var hostSize = getHostSize();
                var hostAbsoluteRectSize = {
                  w: hostSize.w - _marginX - _borderX - (_isBorderBox ? 0 : _paddingX),
                  h: hostSize.h - _marginY - _borderY - (_isBorderBox ? 0 : _paddingY)
                };
                var contentGlueSize = {
                  w: MATH.max((widthAuto ? contentSize.w : scrollSize.w) + paddingAbsoluteX, hostAbsoluteRectSize.w),
                  h: MATH.max((heightAuto ? contentSize.h : scrollSize.h) + paddingAbsoluteY, hostAbsoluteRectSize.h)
                };
                contentGlueSize.c = checkCacheAutoForce(contentGlueSize, _contentGlueSizeCache);
                _contentGlueSizeCache = contentGlueSize;
                if (sizeAutoCapable) {
                  if (contentGlueSize.c || (heightAuto || widthAuto)) {
                    contentGlueElementCSS[_strWidth] = contentGlueSize.w;
                    contentGlueElementCSS[_strHeight] = contentGlueSize.h;
                    if (!_isTextarea) {
                      contentSize = {
                        w: contentMeasureElement[LEXICON.cW],
                        h: contentMeasureElement[LEXICON.cH]
                      };
                    }
                  }
                  var textareaCoverCSS = {};
                  var setContentGlueElementCSSfunction = function(horizontal) {
                    var scrollbarVars = getScrollbarVars(horizontal);
                    var wh = scrollbarVars._w_h;
                    var strWH = scrollbarVars._width_height;
                    var autoSize = horizontal ? widthAuto : heightAuto;
                    var borderSize = horizontal ? _borderX : _borderY;
                    var paddingSize = horizontal ? _paddingX : _paddingY;
                    var marginSize = horizontal ? _marginX : _marginY;
                    var viewportSize = _viewportSize[wh] - borderSize - marginSize - (_isBorderBox ? 0 : paddingSize);
                    if (!autoSize || !autoSize && border.c)
                      contentGlueElementCSS[strWH] = hostAbsoluteRectSize[wh] - 1;
                    if (autoSize && contentSize[wh] < viewportSize && (horizontal && _isTextarea ? !textareaAutoWrapping : true)) {
                      if (_isTextarea)
                        textareaCoverCSS[strWH] = parseToZeroOrNumber(_textareaCoverElement.css(strWH)) - 1;
                      contentGlueElementCSS[strWH] -= 1;
                    }
                    if (contentSize[wh] > 0)
                      contentGlueElementCSS[strWH] = MATH.max(1, contentGlueElementCSS[strWH]);
                  };
                  setContentGlueElementCSSfunction(true);
                  setContentGlueElementCSSfunction(false);
                  if (_isTextarea)
                    _textareaCoverElement.css(textareaCoverCSS);
                  _contentGlueElement.css(contentGlueElementCSS);
                }
                if (widthAuto)
                  contentElementCSS[_strWidth] = _strHundredPercent;
                if (widthAuto && !_isBorderBox && !_mutationObserversConnected)
                  contentElementCSS[_strFloat] = "none";
                _contentElement.css(contentElementCSS);
                contentElementCSS = {};
                var contentScrollSize = {
                  w: contentMeasureElement[LEXICON.sW],
                  h: contentMeasureElement[LEXICON.sH]
                };
                contentScrollSize.c = contentSizeChanged = checkCacheAutoForce(contentScrollSize, _contentScrollSizeCache);
                _contentScrollSizeCache = contentScrollSize;
                _viewportSize = getViewportSize();
                hostSize = getHostSize();
                hostSizeChanged = checkCacheAutoForce(hostSize, _hostSizeCache);
                _hostSizeCache = hostSize;
                var hideOverflowForceTextarea = _isTextarea && (_viewportSize.w === 0 || _viewportSize.h === 0);
                var previousOverflowAmount = _overflowAmountCache;
                var overflowBehaviorIsVS = {};
                var overflowBehaviorIsVH = {};
                var overflowBehaviorIsS = {};
                var overflowAmount = {};
                var hasOverflow = {};
                var hideOverflow = {};
                var canScroll = {};
                var viewportRect = _paddingElementNative[LEXICON.bCR]();
                var setOverflowVariables = function(horizontal) {
                  var scrollbarVars = getScrollbarVars(horizontal);
                  var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                  var xyI = scrollbarVarsInverted._x_y;
                  var xy = scrollbarVars._x_y;
                  var wh = scrollbarVars._w_h;
                  var widthHeight = scrollbarVars._width_height;
                  var scrollMax = _strScroll + scrollbarVars._Left_Top + "Max";
                  var fractionalOverflowAmount = viewportRect[widthHeight] ? MATH.abs(viewportRect[widthHeight] - _viewportSize[wh]) : 0;
                  var checkFractionalOverflowAmount = previousOverflowAmount && previousOverflowAmount[xy] > 0 && _viewportElementNative[scrollMax] === 0;
                  overflowBehaviorIsVS[xy] = overflowBehavior[xy] === "v-s";
                  overflowBehaviorIsVH[xy] = overflowBehavior[xy] === "v-h";
                  overflowBehaviorIsS[xy] = overflowBehavior[xy] === "s";
                  overflowAmount[xy] = MATH.max(0, MATH.round((contentScrollSize[wh] - _viewportSize[wh]) * 100) / 100);
                  overflowAmount[xy] *= hideOverflowForceTextarea || checkFractionalOverflowAmount && fractionalOverflowAmount > 0 && fractionalOverflowAmount < 1 ? 0 : 1;
                  hasOverflow[xy] = overflowAmount[xy] > 0;
                  hideOverflow[xy] = overflowBehaviorIsVS[xy] || overflowBehaviorIsVH[xy] ? hasOverflow[xyI] && !overflowBehaviorIsVS[xyI] && !overflowBehaviorIsVH[xyI] : hasOverflow[xy];
                  hideOverflow[xy + "s"] = hideOverflow[xy] ? overflowBehaviorIsS[xy] || overflowBehaviorIsVS[xy] : false;
                  canScroll[xy] = hasOverflow[xy] && hideOverflow[xy + "s"];
                };
                setOverflowVariables(true);
                setOverflowVariables(false);
                overflowAmount.c = checkCacheAutoForce(overflowAmount, _overflowAmountCache);
                _overflowAmountCache = overflowAmount;
                hasOverflow.c = checkCacheAutoForce(hasOverflow, _hasOverflowCache);
                _hasOverflowCache = hasOverflow;
                hideOverflow.c = checkCacheAutoForce(hideOverflow, _hideOverflowCache);
                _hideOverflowCache = hideOverflow;
                if (_nativeScrollbarIsOverlaid.x || _nativeScrollbarIsOverlaid.y) {
                  var borderDesign = "px solid transparent";
                  var contentArrangeElementCSS = {};
                  var arrangeContent = {};
                  var arrangeChanged = force;
                  var setContentElementCSS;
                  if (hasOverflow.x || hasOverflow.y) {
                    arrangeContent.w = _nativeScrollbarIsOverlaid.y && hasOverflow.y ? contentScrollSize.w + _overlayScrollbarDummySize.y : _strEmpty;
                    arrangeContent.h = _nativeScrollbarIsOverlaid.x && hasOverflow.x ? contentScrollSize.h + _overlayScrollbarDummySize.x : _strEmpty;
                    arrangeChanged = checkCacheAutoForce(arrangeContent, _arrangeContentSizeCache);
                    _arrangeContentSizeCache = arrangeContent;
                  }
                  if (hasOverflow.c || hideOverflow.c || contentScrollSize.c || cssDirectionChanged || widthAutoChanged || heightAutoChanged || widthAuto || heightAuto || ignoreOverlayScrollbarHidingChanged) {
                    contentElementCSS[_strMarginMinus + isRTLRight] = contentElementCSS[_strBorderMinus + isRTLRight] = _strEmpty;
                    setContentElementCSS = function(horizontal) {
                      var scrollbarVars = getScrollbarVars(horizontal);
                      var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                      var xy = scrollbarVars._x_y;
                      var strDirection = horizontal ? _strBottom : isRTLLeft;
                      var invertedAutoSize = horizontal ? heightAuto : widthAuto;
                      if (_nativeScrollbarIsOverlaid[xy] && hasOverflow[xy] && hideOverflow[xy + "s"]) {
                        contentElementCSS[_strMarginMinus + strDirection] = invertedAutoSize ? ignoreOverlayScrollbarHiding ? _strEmpty : _overlayScrollbarDummySize[xy] : _strEmpty;
                        contentElementCSS[_strBorderMinus + strDirection] = (horizontal ? !invertedAutoSize : true) && !ignoreOverlayScrollbarHiding ? _overlayScrollbarDummySize[xy] + borderDesign : _strEmpty;
                      } else {
                        arrangeContent[scrollbarVarsInverted._w_h] = contentElementCSS[_strMarginMinus + strDirection] = contentElementCSS[_strBorderMinus + strDirection] = _strEmpty;
                        arrangeChanged = true;
                      }
                    };
                    if (_nativeScrollbarStyling) {
                      addRemoveClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible, !ignoreOverlayScrollbarHiding);
                    } else {
                      setContentElementCSS(true);
                      setContentElementCSS(false);
                    }
                  }
                  if (ignoreOverlayScrollbarHiding) {
                    arrangeContent.w = arrangeContent.h = _strEmpty;
                    arrangeChanged = true;
                  }
                  if (arrangeChanged && !_nativeScrollbarStyling) {
                    contentArrangeElementCSS[_strWidth] = hideOverflow.y ? arrangeContent.w : _strEmpty;
                    contentArrangeElementCSS[_strHeight] = hideOverflow.x ? arrangeContent.h : _strEmpty;
                    if (!_contentArrangeElement) {
                      _contentArrangeElement = FRAMEWORK(generateDiv(_classNameContentArrangeElement));
                      _viewportElement.prepend(_contentArrangeElement);
                    }
                    _contentArrangeElement.css(contentArrangeElementCSS);
                  }
                  _contentElement.css(contentElementCSS);
                }
                var viewportElementCSS = {};
                var paddingElementCSS = {};
                var setViewportCSS;
                if (hostSizeChanged || hasOverflow.c || hideOverflow.c || contentScrollSize.c || overflowBehaviorChanged || boxSizingChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged || clipAlwaysChanged || heightAutoChanged) {
                  viewportElementCSS[isRTLRight] = _strEmpty;
                  setViewportCSS = function(horizontal) {
                    var scrollbarVars = getScrollbarVars(horizontal);
                    var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                    var xy = scrollbarVars._x_y;
                    var XY = scrollbarVars._X_Y;
                    var strDirection = horizontal ? _strBottom : isRTLLeft;
                    var reset = function() {
                      viewportElementCSS[strDirection] = _strEmpty;
                      _contentBorderSize[scrollbarVarsInverted._w_h] = 0;
                    };
                    if (hasOverflow[xy] && hideOverflow[xy + "s"]) {
                      viewportElementCSS[strOverflow + XY] = _strScroll;
                      if (ignoreOverlayScrollbarHiding || _nativeScrollbarStyling) {
                        reset();
                      } else {
                        viewportElementCSS[strDirection] = -(_nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[xy] : _nativeScrollbarSize[xy]);
                        _contentBorderSize[scrollbarVarsInverted._w_h] = _nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[scrollbarVarsInverted._x_y] : 0;
                      }
                    } else {
                      viewportElementCSS[strOverflow + XY] = _strEmpty;
                      reset();
                    }
                  };
                  setViewportCSS(true);
                  setViewportCSS(false);
                  if (!_nativeScrollbarStyling && (_viewportSize.h < _nativeScrollbarMinSize.x || _viewportSize.w < _nativeScrollbarMinSize.y) && (hasOverflow.x && hideOverflow.x && !_nativeScrollbarIsOverlaid.x || hasOverflow.y && hideOverflow.y && !_nativeScrollbarIsOverlaid.y)) {
                    viewportElementCSS[_strPaddingMinus + _strTop] = _nativeScrollbarMinSize.x;
                    viewportElementCSS[_strMarginMinus + _strTop] = -_nativeScrollbarMinSize.x;
                    viewportElementCSS[_strPaddingMinus + isRTLRight] = _nativeScrollbarMinSize.y;
                    viewportElementCSS[_strMarginMinus + isRTLRight] = -_nativeScrollbarMinSize.y;
                  } else {
                    viewportElementCSS[_strPaddingMinus + _strTop] = viewportElementCSS[_strMarginMinus + _strTop] = viewportElementCSS[_strPaddingMinus + isRTLRight] = viewportElementCSS[_strMarginMinus + isRTLRight] = _strEmpty;
                  }
                  viewportElementCSS[_strPaddingMinus + isRTLLeft] = viewportElementCSS[_strMarginMinus + isRTLLeft] = _strEmpty;
                  if (hasOverflow.x && hideOverflow.x || hasOverflow.y && hideOverflow.y || hideOverflowForceTextarea) {
                    if (_isTextarea && hideOverflowForceTextarea) {
                      paddingElementCSS[strOverflowX] = paddingElementCSS[strOverflowY] = strHidden;
                    }
                  } else {
                    if (!clipAlways || (overflowBehaviorIsVH.x || overflowBehaviorIsVS.x || overflowBehaviorIsVH.y || overflowBehaviorIsVS.y)) {
                      if (_isTextarea) {
                        paddingElementCSS[strOverflowX] = paddingElementCSS[strOverflowY] = _strEmpty;
                      }
                      viewportElementCSS[strOverflowX] = viewportElementCSS[strOverflowY] = strVisible;
                    }
                  }
                  _paddingElement.css(paddingElementCSS);
                  _viewportElement.css(viewportElementCSS);
                  viewportElementCSS = {};
                  if ((hasOverflow.c || boxSizingChanged || widthAutoChanged || heightAutoChanged) && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                    var elementStyle = _contentElementNative[LEXICON.s];
                    var dump;
                    elementStyle.webkitTransform = "scale(1)";
                    elementStyle.display = "run-in";
                    dump = _contentElementNative[LEXICON.oH];
                    elementStyle.display = _strEmpty;
                    elementStyle.webkitTransform = _strEmpty;
                  }
                }
                contentElementCSS = {};
                if (cssDirectionChanged || widthAutoChanged || heightAutoChanged) {
                  if (_isRTL && widthAuto) {
                    var floatTmp = _contentElement.css(_strFloat);
                    var posLeftWithoutFloat = MATH.round(_contentElement.css(_strFloat, _strEmpty).css(_strLeft, _strEmpty).position().left);
                    _contentElement.css(_strFloat, floatTmp);
                    var posLeftWithFloat = MATH.round(_contentElement.position().left);
                    if (posLeftWithoutFloat !== posLeftWithFloat)
                      contentElementCSS[_strLeft] = posLeftWithoutFloat;
                  } else {
                    contentElementCSS[_strLeft] = _strEmpty;
                  }
                }
                _contentElement.css(contentElementCSS);
                if (_isTextarea && contentSizeChanged) {
                  var textareaInfo = getTextareaInfo();
                  if (textareaInfo) {
                    var textareaRowsChanged = _textareaInfoCache === undefined2 ? true : textareaInfo._rows !== _textareaInfoCache._rows;
                    var cursorRow = textareaInfo._cursorRow;
                    var cursorCol = textareaInfo._cursorColumn;
                    var widestRow = textareaInfo._widestRow;
                    var lastRow = textareaInfo._rows;
                    var lastCol = textareaInfo._columns;
                    var cursorPos = textareaInfo._cursorPosition;
                    var cursorMax = textareaInfo._cursorMax;
                    var cursorIsLastPosition = cursorPos >= cursorMax && _textareaHasFocus;
                    var textareaScrollAmount = {
                      x: !textareaAutoWrapping && (cursorCol === lastCol && cursorRow === widestRow) ? _overflowAmountCache.x : -1,
                      y: (textareaAutoWrapping ? cursorIsLastPosition || textareaRowsChanged && (previousOverflowAmount ? currScroll.y === previousOverflowAmount.y : false) : (cursorIsLastPosition || textareaRowsChanged) && cursorRow === lastRow) ? _overflowAmountCache.y : -1
                    };
                    currScroll.x = textareaScrollAmount.x > -1 ? _isRTL && _normalizeRTLCache && _rtlScrollBehavior.i ? 0 : textareaScrollAmount.x : currScroll.x;
                    currScroll.y = textareaScrollAmount.y > -1 ? textareaScrollAmount.y : currScroll.y;
                  }
                  _textareaInfoCache = textareaInfo;
                }
                if (_isRTL && _rtlScrollBehavior.i && _nativeScrollbarIsOverlaid.y && hasOverflow.x && _normalizeRTLCache)
                  currScroll.x += _contentBorderSize.w || 0;
                if (widthAuto)
                  _hostElement[_strScrollLeft](0);
                if (heightAuto)
                  _hostElement[_strScrollTop](0);
                _viewportElement[_strScrollLeft](currScroll.x)[_strScrollTop](currScroll.y);
                var scrollbarsVisibilityVisible = scrollbarsVisibility === "v";
                var scrollbarsVisibilityHidden = scrollbarsVisibility === "h";
                var scrollbarsVisibilityAuto = scrollbarsVisibility === "a";
                var refreshScrollbarsVisibility = function(showX, showY) {
                  showY = showY === undefined2 ? showX : showY;
                  refreshScrollbarAppearance(true, showX, canScroll.x);
                  refreshScrollbarAppearance(false, showY, canScroll.y);
                };
                addRemoveClass(_hostElement, _classNameHostOverflow, hideOverflow.x || hideOverflow.y);
                addRemoveClass(_hostElement, _classNameHostOverflowX, hideOverflow.x);
                addRemoveClass(_hostElement, _classNameHostOverflowY, hideOverflow.y);
                if (cssDirectionChanged && !_isBody) {
                  addRemoveClass(_hostElement, _classNameHostRTL, _isRTL);
                }
                if (_isBody)
                  addClass(_hostElement, _classNameHostResizeDisabled);
                if (resizeChanged) {
                  addRemoveClass(_hostElement, _classNameHostResizeDisabled, _resizeNone);
                  addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResize, !_resizeNone);
                  addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeB, _resizeBoth);
                  addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeH, _resizeHorizontal);
                  addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeV, _resizeVertical);
                }
                if (scrollbarsVisibilityChanged || overflowBehaviorChanged || hideOverflow.c || hasOverflow.c || ignoreOverlayScrollbarHidingChanged) {
                  if (ignoreOverlayScrollbarHiding) {
                    if (ignoreOverlayScrollbarHidingChanged) {
                      removeClass(_hostElement, _classNameHostScrolling);
                      if (ignoreOverlayScrollbarHiding) {
                        refreshScrollbarsVisibility(false);
                      }
                    }
                  } else if (scrollbarsVisibilityAuto) {
                    refreshScrollbarsVisibility(canScroll.x, canScroll.y);
                  } else if (scrollbarsVisibilityVisible) {
                    refreshScrollbarsVisibility(true);
                  } else if (scrollbarsVisibilityHidden) {
                    refreshScrollbarsVisibility(false);
                  }
                }
                if (scrollbarsAutoHideChanged || ignoreOverlayScrollbarHidingChanged) {
                  setupHostMouseTouchEvents(!_scrollbarsAutoHideLeave && !_scrollbarsAutoHideMove);
                  refreshScrollbarsAutoHide(_scrollbarsAutoHideNever, !_scrollbarsAutoHideNever);
                }
                if (hostSizeChanged || overflowAmount.c || heightAutoChanged || widthAutoChanged || resizeChanged || boxSizingChanged || paddingAbsoluteChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged) {
                  refreshScrollbarHandleLength(true);
                  refreshScrollbarHandleOffset(true);
                  refreshScrollbarHandleLength(false);
                  refreshScrollbarHandleOffset(false);
                }
                if (scrollbarsClickScrollingChanged)
                  refreshScrollbarsInteractive(true, scrollbarsClickScrolling);
                if (scrollbarsDragScrollingChanged)
                  refreshScrollbarsInteractive(false, scrollbarsDragScrolling);
                dispatchCallback("onDirectionChanged", {
                  isRTL: _isRTL,
                  dir: cssDirection
                }, cssDirectionChanged);
                dispatchCallback("onHostSizeChanged", {
                  width: _hostSizeCache.w,
                  height: _hostSizeCache.h
                }, hostSizeChanged);
                dispatchCallback("onContentSizeChanged", {
                  width: _contentScrollSizeCache.w,
                  height: _contentScrollSizeCache.h
                }, contentSizeChanged);
                dispatchCallback("onOverflowChanged", {
                  x: hasOverflow.x,
                  y: hasOverflow.y,
                  xScrollable: hideOverflow.xs,
                  yScrollable: hideOverflow.ys,
                  clipped: hideOverflow.x || hideOverflow.y
                }, hasOverflow.c || hideOverflow.c);
                dispatchCallback("onOverflowAmountChanged", {
                  x: overflowAmount.x,
                  y: overflowAmount.y
                }, overflowAmount.c);
              }
              if (_isBody && _bodyMinSizeCache && (_hasOverflowCache.c || _bodyMinSizeCache.c)) {
                if (!_bodyMinSizeCache.f)
                  bodyMinSizeChanged();
                if (_nativeScrollbarIsOverlaid.y && _hasOverflowCache.x)
                  _contentElement.css(_strMinMinus + _strWidth, _bodyMinSizeCache.w + _overlayScrollbarDummySize.y);
                if (_nativeScrollbarIsOverlaid.x && _hasOverflowCache.y)
                  _contentElement.css(_strMinMinus + _strHeight, _bodyMinSizeCache.h + _overlayScrollbarDummySize.x);
                _bodyMinSizeCache.c = false;
              }
              if (_initialized && changedOptions.updateOnLoad) {
                updateElementsOnLoad();
              }
              dispatchCallback("onUpdated", { forced: force });
            }
            function updateElementsOnLoad() {
              if (!_isTextarea) {
                eachUpdateOnLoad(function(i, updateOnLoadSelector) {
                  _contentElement.find(updateOnLoadSelector).each(function(i2, el) {
                    if (COMPATIBILITY.inA(el, _updateOnLoadElms) < 0) {
                      _updateOnLoadElms.push(el);
                      FRAMEWORK(el).off(_updateOnLoadEventName, updateOnLoadCallback).on(_updateOnLoadEventName, updateOnLoadCallback);
                    }
                  });
                });
              }
            }
            function setOptions(newOptions) {
              var validatedOpts = _pluginsOptions._validate(newOptions, _pluginsOptions._template, true, _currentOptions);
              _currentOptions = extendDeep({}, _currentOptions, validatedOpts._default);
              _currentPreparedOptions = extendDeep({}, _currentPreparedOptions, validatedOpts._prepared);
              return validatedOpts._prepared;
            }
            function setupStructureDOM(destroy) {
              var strParent = "parent";
              var classNameResizeObserverHost = "os-resize-observer-host";
              var classNameTextareaElementFull = _classNameTextareaElement + _strSpace + _classNameTextInherit;
              var textareaClass = _isTextarea ? _strSpace + _classNameTextInherit : _strEmpty;
              var adoptAttrs = _currentPreparedOptions.textarea.inheritedAttrs;
              var adoptAttrsMap = {};
              var applyAdoptedAttrs = function() {
                var applyAdoptedAttrsElm = destroy ? _targetElement : _hostElement;
                each(adoptAttrsMap, function(key, value) {
                  if (type(value) == TYPES.s) {
                    if (key == LEXICON.c)
                      applyAdoptedAttrsElm.addClass(value);
                    else
                      applyAdoptedAttrsElm.attr(key, value);
                  }
                });
              };
              var hostElementClassNames = [
                _classNameHostElement,
                _classNameHostElementForeign,
                _classNameHostTextareaElement,
                _classNameHostResizeDisabled,
                _classNameHostRTL,
                _classNameHostScrollbarHorizontalHidden,
                _classNameHostScrollbarVerticalHidden,
                _classNameHostTransition,
                _classNameHostScrolling,
                _classNameHostOverflow,
                _classNameHostOverflowX,
                _classNameHostOverflowY,
                _classNameThemeNone,
                _classNameTextareaElement,
                _classNameTextInherit,
                _classNameCache
              ].join(_strSpace);
              var hostElementCSS = {};
              _hostElement = _hostElement || (_isTextarea ? _domExists ? _targetElement[strParent]()[strParent]()[strParent]()[strParent]() : FRAMEWORK(generateDiv(_classNameHostTextareaElement)) : _targetElement);
              _contentElement = _contentElement || selectOrGenerateDivByClass(_classNameContentElement + textareaClass);
              _viewportElement = _viewportElement || selectOrGenerateDivByClass(_classNameViewportElement + textareaClass);
              _paddingElement = _paddingElement || selectOrGenerateDivByClass(_classNamePaddingElement + textareaClass);
              _sizeObserverElement = _sizeObserverElement || selectOrGenerateDivByClass(classNameResizeObserverHost);
              _textareaCoverElement = _textareaCoverElement || (_isTextarea ? selectOrGenerateDivByClass(_classNameTextareaCoverElement) : undefined2);
              if (_domExists)
                addClass(_hostElement, _classNameHostElementForeign);
              if (destroy)
                removeClass(_hostElement, hostElementClassNames);
              adoptAttrs = type(adoptAttrs) == TYPES.s ? adoptAttrs.split(_strSpace) : adoptAttrs;
              if (COMPATIBILITY.isA(adoptAttrs) && _isTextarea) {
                each(adoptAttrs, function(i, v) {
                  if (type(v) == TYPES.s) {
                    adoptAttrsMap[v] = destroy ? _hostElement.attr(v) : _targetElement.attr(v);
                  }
                });
              }
              if (!destroy) {
                if (_isTextarea) {
                  if (!_currentPreparedOptions.sizeAutoCapable) {
                    hostElementCSS[_strWidth] = _targetElement.css(_strWidth);
                    hostElementCSS[_strHeight] = _targetElement.css(_strHeight);
                  }
                  if (!_domExists)
                    _targetElement.addClass(_classNameTextInherit).wrap(_hostElement);
                  _hostElement = _targetElement[strParent]().css(hostElementCSS);
                }
                if (!_domExists) {
                  addClass(_targetElement, _isTextarea ? classNameTextareaElementFull : _classNameHostElement);
                  _hostElement.wrapInner(_contentElement).wrapInner(_viewportElement).wrapInner(_paddingElement).prepend(_sizeObserverElement);
                  _contentElement = findFirst(_hostElement, _strDot + _classNameContentElement);
                  _viewportElement = findFirst(_hostElement, _strDot + _classNameViewportElement);
                  _paddingElement = findFirst(_hostElement, _strDot + _classNamePaddingElement);
                  if (_isTextarea) {
                    _contentElement.prepend(_textareaCoverElement);
                    applyAdoptedAttrs();
                  }
                }
                if (_nativeScrollbarStyling)
                  addClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible);
                if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)
                  addClass(_viewportElement, _classNameViewportNativeScrollbarsOverlaid);
                if (_isBody)
                  addClass(_htmlElement, _classNameHTMLElement);
                _sizeObserverElementNative = _sizeObserverElement[0];
                _hostElementNative = _hostElement[0];
                _paddingElementNative = _paddingElement[0];
                _viewportElementNative = _viewportElement[0];
                _contentElementNative = _contentElement[0];
                updateViewportAttrsFromTarget();
              } else {
                if (_domExists && _initialized) {
                  _sizeObserverElement.children().remove();
                  each([_paddingElement, _viewportElement, _contentElement, _textareaCoverElement], function(i, elm) {
                    if (elm) {
                      removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                    }
                  });
                  addClass(_hostElement, _isTextarea ? _classNameHostTextareaElement : _classNameHostElement);
                } else {
                  remove(_sizeObserverElement);
                  _contentElement.contents().unwrap().unwrap().unwrap();
                  if (_isTextarea) {
                    _targetElement.unwrap();
                    remove(_hostElement);
                    remove(_textareaCoverElement);
                    applyAdoptedAttrs();
                  }
                }
                if (_isTextarea)
                  _targetElement.removeAttr(LEXICON.s);
                if (_isBody)
                  removeClass(_htmlElement, _classNameHTMLElement);
              }
            }
            function setupStructureEvents() {
              var textareaKeyDownRestrictedKeyCodes = [
                112,
                113,
                114,
                115,
                116,
                117,
                118,
                119,
                120,
                121,
                123,
                33,
                34,
                37,
                38,
                39,
                40,
                16,
                17,
                18,
                19,
                20,
                144
              ];
              var textareaKeyDownKeyCodesList = [];
              var textareaUpdateIntervalID;
              var scrollStopTimeoutId;
              var scrollStopDelay = 175;
              var strFocus = "focus";
              function updateTextarea(doClearInterval) {
                textareaUpdate();
                _base.update(_strAuto);
                if (doClearInterval && _autoUpdateRecommended)
                  clearInterval(textareaUpdateIntervalID);
              }
              function textareaOnScroll(event) {
                _targetElement[_strScrollLeft](_rtlScrollBehavior.i && _normalizeRTLCache ? 9999999 : 0);
                _targetElement[_strScrollTop](0);
                COMPATIBILITY.prvD(event);
                COMPATIBILITY.stpP(event);
                return false;
              }
              function textareaOnDrop(event) {
                setTimeout(function() {
                  if (!_destroyed)
                    updateTextarea();
                }, 50);
              }
              function textareaOnFocus() {
                _textareaHasFocus = true;
                addClass(_hostElement, strFocus);
              }
              function textareaOnFocusout() {
                _textareaHasFocus = false;
                textareaKeyDownKeyCodesList = [];
                removeClass(_hostElement, strFocus);
                updateTextarea(true);
              }
              function textareaOnKeyDown(event) {
                var keyCode = event.keyCode;
                if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                  if (!textareaKeyDownKeyCodesList[LEXICON.l]) {
                    updateTextarea();
                    textareaUpdateIntervalID = setInterval(updateTextarea, 1e3 / 60);
                  }
                  if (inArray(keyCode, textareaKeyDownKeyCodesList) < 0)
                    textareaKeyDownKeyCodesList.push(keyCode);
                }
              }
              function textareaOnKeyUp(event) {
                var keyCode = event.keyCode;
                var index = inArray(keyCode, textareaKeyDownKeyCodesList);
                if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                  if (index > -1)
                    textareaKeyDownKeyCodesList.splice(index, 1);
                  if (!textareaKeyDownKeyCodesList[LEXICON.l])
                    updateTextarea(true);
                }
              }
              function contentOnTransitionEnd(event) {
                if (_autoUpdateCache === true)
                  return;
                event = event.originalEvent || event;
                if (isSizeAffectingCSSProperty(event.propertyName))
                  _base.update(_strAuto);
              }
              function viewportOnScroll(event) {
                if (!_sleeping) {
                  if (scrollStopTimeoutId !== undefined2)
                    clearTimeout(scrollStopTimeoutId);
                  else {
                    if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                      refreshScrollbarsAutoHide(true);
                    if (!nativeOverlayScrollbarsAreActive())
                      addClass(_hostElement, _classNameHostScrolling);
                    dispatchCallback("onScrollStart", event);
                  }
                  if (!_scrollbarsHandlesDefineScrollPos) {
                    refreshScrollbarHandleOffset(true);
                    refreshScrollbarHandleOffset(false);
                  }
                  dispatchCallback("onScroll", event);
                  scrollStopTimeoutId = setTimeout(function() {
                    if (!_destroyed) {
                      clearTimeout(scrollStopTimeoutId);
                      scrollStopTimeoutId = undefined2;
                      if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                        refreshScrollbarsAutoHide(false);
                      if (!nativeOverlayScrollbarsAreActive())
                        removeClass(_hostElement, _classNameHostScrolling);
                      dispatchCallback("onScrollStop", event);
                    }
                  }, scrollStopDelay);
                }
              }
              if (_isTextarea) {
                if (_msieVersion > 9 || !_autoUpdateRecommended) {
                  addDestroyEventListener(_targetElement, "input", updateTextarea);
                } else {
                  addDestroyEventListener(
                    _targetElement,
                    [_strKeyDownEvent, _strKeyUpEvent],
                    [textareaOnKeyDown, textareaOnKeyUp]
                  );
                }
                addDestroyEventListener(
                  _targetElement,
                  [_strScroll, "drop", strFocus, strFocus + "out"],
                  [textareaOnScroll, textareaOnDrop, textareaOnFocus, textareaOnFocusout]
                );
              } else {
                addDestroyEventListener(_contentElement, _strTransitionEndEvent, contentOnTransitionEnd);
              }
              addDestroyEventListener(_viewportElement, _strScroll, viewportOnScroll, true);
            }
            function setupScrollbarsDOM(destroy) {
              var selectOrGenerateScrollbarDOM = function(isHorizontal) {
                var scrollbarClassName = isHorizontal ? _classNameScrollbarHorizontal : _classNameScrollbarVertical;
                var scrollbar = selectOrGenerateDivByClass(_classNameScrollbar + _strSpace + scrollbarClassName, true);
                var track = selectOrGenerateDivByClass(_classNameScrollbarTrack, scrollbar);
                var handle = selectOrGenerateDivByClass(_classNameScrollbarHandle, scrollbar);
                if (!_domExists && !destroy) {
                  scrollbar.append(track);
                  track.append(handle);
                }
                return {
                  _scrollbar: scrollbar,
                  _track: track,
                  _handle: handle
                };
              };
              function resetScrollbarDOM(isHorizontal) {
                var scrollbarVars = getScrollbarVars(isHorizontal);
                var scrollbar = scrollbarVars._scrollbar;
                var track = scrollbarVars._track;
                var handle = scrollbarVars._handle;
                if (_domExists && _initialized) {
                  each([scrollbar, track, handle], function(i, elm) {
                    removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                  });
                } else {
                  remove(scrollbar || selectOrGenerateScrollbarDOM(isHorizontal)._scrollbar);
                }
              }
              var horizontalElements;
              var verticalElements;
              if (!destroy) {
                horizontalElements = selectOrGenerateScrollbarDOM(true);
                verticalElements = selectOrGenerateScrollbarDOM();
                _scrollbarHorizontalElement = horizontalElements._scrollbar;
                _scrollbarHorizontalTrackElement = horizontalElements._track;
                _scrollbarHorizontalHandleElement = horizontalElements._handle;
                _scrollbarVerticalElement = verticalElements._scrollbar;
                _scrollbarVerticalTrackElement = verticalElements._track;
                _scrollbarVerticalHandleElement = verticalElements._handle;
                if (!_domExists) {
                  _paddingElement.after(_scrollbarVerticalElement);
                  _paddingElement.after(_scrollbarHorizontalElement);
                }
              } else {
                resetScrollbarDOM(true);
                resetScrollbarDOM();
              }
            }
            function setupScrollbarEvents(isHorizontal) {
              var scrollbarVars = getScrollbarVars(isHorizontal);
              var scrollbarVarsInfo = scrollbarVars._info;
              var insideIFrame = _windowElementNative.top !== _windowElementNative;
              var xy = scrollbarVars._x_y;
              var XY = scrollbarVars._X_Y;
              var scroll = _strScroll + scrollbarVars._Left_Top;
              var strActive = "active";
              var strSnapHandle = "snapHandle";
              var strClickEvent = "click";
              var scrollDurationFactor = 1;
              var increaseDecreaseScrollAmountKeyCodes = [16, 17];
              var trackTimeout;
              var mouseDownScroll;
              var mouseDownOffset;
              var mouseDownInvertedScale;
              function getPointerPosition(event) {
                return _msieVersion && insideIFrame ? event["screen" + XY] : COMPATIBILITY.page(event)[xy];
              }
              function getPreparedScrollbarsOption(name) {
                return _currentPreparedOptions.scrollbars[name];
              }
              function increaseTrackScrollAmount() {
                scrollDurationFactor = 0.5;
              }
              function decreaseTrackScrollAmount() {
                scrollDurationFactor = 1;
              }
              function stopClickEventPropagation(event) {
                COMPATIBILITY.stpP(event);
              }
              function documentKeyDown(event) {
                if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)
                  increaseTrackScrollAmount();
              }
              function documentKeyUp(event) {
                if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)
                  decreaseTrackScrollAmount();
              }
              function onMouseTouchDownContinue(event) {
                var originalEvent = event.originalEvent || event;
                var isTouchEvent = originalEvent.touches !== undefined2;
                return _sleeping || _destroyed || nativeOverlayScrollbarsAreActive() || !_scrollbarsDragScrollingCache || isTouchEvent && !getPreparedScrollbarsOption("touchSupport") ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
              }
              function documentDragMove(event) {
                if (onMouseTouchDownContinue(event)) {
                  var trackLength = scrollbarVarsInfo._trackLength;
                  var handleLength = scrollbarVarsInfo._handleLength;
                  var scrollRange = scrollbarVarsInfo._maxScroll;
                  var scrollRaw = (getPointerPosition(event) - mouseDownOffset) * mouseDownInvertedScale;
                  var scrollDeltaPercent = scrollRaw / (trackLength - handleLength);
                  var scrollDelta = scrollRange * scrollDeltaPercent;
                  scrollDelta = isFinite(scrollDelta) ? scrollDelta : 0;
                  if (_isRTL && isHorizontal && !_rtlScrollBehavior.i)
                    scrollDelta *= -1;
                  _viewportElement[scroll](MATH.round(mouseDownScroll + scrollDelta));
                  if (_scrollbarsHandlesDefineScrollPos)
                    refreshScrollbarHandleOffset(isHorizontal, mouseDownScroll + scrollDelta);
                  if (!_supportPassiveEvents)
                    COMPATIBILITY.prvD(event);
                } else
                  documentMouseTouchUp(event);
              }
              function documentMouseTouchUp(event) {
                event = event || event.originalEvent;
                setupResponsiveEventListener(
                  _documentElement,
                  [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                  [documentDragMove, documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart],
                  true
                );
                COMPATIBILITY.rAF()(function() {
                  setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, true, { _capture: true });
                });
                if (_scrollbarsHandlesDefineScrollPos)
                  refreshScrollbarHandleOffset(isHorizontal, true);
                _scrollbarsHandlesDefineScrollPos = false;
                removeClass(_bodyElement, _classNameDragging);
                removeClass(scrollbarVars._handle, strActive);
                removeClass(scrollbarVars._track, strActive);
                removeClass(scrollbarVars._scrollbar, strActive);
                mouseDownScroll = undefined2;
                mouseDownOffset = undefined2;
                mouseDownInvertedScale = 1;
                decreaseTrackScrollAmount();
                if (trackTimeout !== undefined2) {
                  _base.scrollStop();
                  clearTimeout(trackTimeout);
                  trackTimeout = undefined2;
                }
                if (event) {
                  var rect = _hostElementNative[LEXICON.bCR]();
                  var mouseInsideHost = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom;
                  if (!mouseInsideHost)
                    hostOnMouseLeave();
                  if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                    refreshScrollbarsAutoHide(false);
                }
              }
              function onHandleMouseTouchDown(event) {
                if (onMouseTouchDownContinue(event))
                  onHandleMouseTouchDownAction(event);
              }
              function onHandleMouseTouchDownAction(event) {
                mouseDownScroll = _viewportElement[scroll]();
                mouseDownScroll = isNaN(mouseDownScroll) ? 0 : mouseDownScroll;
                if (_isRTL && isHorizontal && !_rtlScrollBehavior.n || !_isRTL)
                  mouseDownScroll = mouseDownScroll < 0 ? 0 : mouseDownScroll;
                mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                mouseDownOffset = getPointerPosition(event);
                _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                addClass(_bodyElement, _classNameDragging);
                addClass(scrollbarVars._handle, strActive);
                addClass(scrollbarVars._scrollbar, strActive);
                setupResponsiveEventListener(
                  _documentElement,
                  [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strSelectStartEvent],
                  [documentDragMove, documentMouseTouchUp, documentOnSelectStart]
                );
                COMPATIBILITY.rAF()(function() {
                  setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, false, { _capture: true });
                });
                if (_msieVersion || !_documentMixed)
                  COMPATIBILITY.prvD(event);
                COMPATIBILITY.stpP(event);
              }
              function onTrackMouseTouchDown(event) {
                if (onMouseTouchDownContinue(event)) {
                  var handleToViewportRatio = scrollbarVars._info._handleLength / Math.round(MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]) * scrollbarVars._info._trackLength);
                  var scrollDistance = MATH.round(_viewportSize[scrollbarVars._w_h] * handleToViewportRatio);
                  var scrollBaseDuration = 270 * handleToViewportRatio;
                  var scrollFirstIterationDelay = 400 * handleToViewportRatio;
                  var trackOffset = scrollbarVars._track.offset()[scrollbarVars._left_top];
                  var ctrlKey = event.ctrlKey;
                  var instantScroll = event.shiftKey;
                  var instantScrollTransition = instantScroll && ctrlKey;
                  var isFirstIteration = true;
                  var easing = "linear";
                  var decreaseScroll;
                  var finishedCondition;
                  var scrollActionFinsished = function(transition) {
                    if (_scrollbarsHandlesDefineScrollPos)
                      refreshScrollbarHandleOffset(isHorizontal, transition);
                  };
                  var scrollActionInstantFinished = function() {
                    scrollActionFinsished();
                    onHandleMouseTouchDownAction(event);
                  };
                  var scrollAction = function() {
                    if (!_destroyed) {
                      var mouseOffset = (mouseDownOffset - trackOffset) * mouseDownInvertedScale;
                      var handleOffset = scrollbarVarsInfo._handleOffset;
                      var trackLength = scrollbarVarsInfo._trackLength;
                      var handleLength = scrollbarVarsInfo._handleLength;
                      var scrollRange = scrollbarVarsInfo._maxScroll;
                      var currScroll = scrollbarVarsInfo._currentScroll;
                      var scrollDuration = scrollBaseDuration * scrollDurationFactor;
                      var timeoutDelay = isFirstIteration ? MATH.max(scrollFirstIterationDelay, scrollDuration) : scrollDuration;
                      var instantScrollPosition = scrollRange * ((mouseOffset - handleLength / 2) / (trackLength - handleLength));
                      var rtlIsNormal = _isRTL && isHorizontal && (!_rtlScrollBehavior.i && !_rtlScrollBehavior.n || _normalizeRTLCache);
                      var decreaseScrollCondition = rtlIsNormal ? handleOffset < mouseOffset : handleOffset > mouseOffset;
                      var scrollObj = {};
                      var animationObj = {
                        easing,
                        step: function(now) {
                          if (_scrollbarsHandlesDefineScrollPos) {
                            _viewportElement[scroll](now);
                            refreshScrollbarHandleOffset(isHorizontal, now);
                          }
                        }
                      };
                      instantScrollPosition = isFinite(instantScrollPosition) ? instantScrollPosition : 0;
                      instantScrollPosition = _isRTL && isHorizontal && !_rtlScrollBehavior.i ? scrollRange - instantScrollPosition : instantScrollPosition;
                      if (instantScroll) {
                        _viewportElement[scroll](instantScrollPosition);
                        if (instantScrollTransition) {
                          instantScrollPosition = _viewportElement[scroll]();
                          _viewportElement[scroll](currScroll);
                          instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.i ? scrollRange - instantScrollPosition : instantScrollPosition;
                          instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.n ? -instantScrollPosition : instantScrollPosition;
                          scrollObj[xy] = instantScrollPosition;
                          _base.scroll(scrollObj, extendDeep(animationObj, {
                            duration: 130,
                            complete: scrollActionInstantFinished
                          }));
                        } else
                          scrollActionInstantFinished();
                      } else {
                        decreaseScroll = isFirstIteration ? decreaseScrollCondition : decreaseScroll;
                        finishedCondition = rtlIsNormal ? decreaseScroll ? handleOffset + handleLength >= mouseOffset : handleOffset <= mouseOffset : decreaseScroll ? handleOffset <= mouseOffset : handleOffset + handleLength >= mouseOffset;
                        if (finishedCondition) {
                          clearTimeout(trackTimeout);
                          _base.scrollStop();
                          trackTimeout = undefined2;
                          scrollActionFinsished(true);
                        } else {
                          trackTimeout = setTimeout(scrollAction, timeoutDelay);
                          scrollObj[xy] = (decreaseScroll ? "-=" : "+=") + scrollDistance;
                          _base.scroll(scrollObj, extendDeep(animationObj, {
                            duration: scrollDuration
                          }));
                        }
                        isFirstIteration = false;
                      }
                    }
                  };
                  if (ctrlKey)
                    increaseTrackScrollAmount();
                  mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                  mouseDownOffset = COMPATIBILITY.page(event)[xy];
                  _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                  addClass(_bodyElement, _classNameDragging);
                  addClass(scrollbarVars._track, strActive);
                  addClass(scrollbarVars._scrollbar, strActive);
                  setupResponsiveEventListener(
                    _documentElement,
                    [_strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                    [documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart]
                  );
                  scrollAction();
                  COMPATIBILITY.prvD(event);
                  COMPATIBILITY.stpP(event);
                }
              }
              function onTrackMouseTouchEnter(event) {
                _scrollbarsHandleHovered = true;
                if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                  refreshScrollbarsAutoHide(true);
              }
              function onTrackMouseTouchLeave(event) {
                _scrollbarsHandleHovered = false;
                if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                  refreshScrollbarsAutoHide(false);
              }
              function onScrollbarMouseTouchDown(event) {
                COMPATIBILITY.stpP(event);
              }
              addDestroyEventListener(
                scrollbarVars._handle,
                _strMouseTouchDownEvent,
                onHandleMouseTouchDown
              );
              addDestroyEventListener(
                scrollbarVars._track,
                [_strMouseTouchDownEvent, _strMouseEnter, _strMouseLeave],
                [onTrackMouseTouchDown, onTrackMouseTouchEnter, onTrackMouseTouchLeave]
              );
              addDestroyEventListener(
                scrollbarVars._scrollbar,
                _strMouseTouchDownEvent,
                onScrollbarMouseTouchDown
              );
              if (_supportTransition) {
                addDestroyEventListener(scrollbarVars._scrollbar, _strTransitionEndEvent, function(event) {
                  if (event.target !== scrollbarVars._scrollbar[0])
                    return;
                  refreshScrollbarHandleLength(isHorizontal);
                  refreshScrollbarHandleOffset(isHorizontal);
                });
              }
            }
            function refreshScrollbarAppearance(isHorizontal, shallBeVisible, canScroll) {
              var scrollbarHiddenClassName = isHorizontal ? _classNameHostScrollbarHorizontalHidden : _classNameHostScrollbarVerticalHidden;
              var scrollbarElement = isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement;
              addRemoveClass(_hostElement, scrollbarHiddenClassName, !shallBeVisible);
              addRemoveClass(scrollbarElement, _classNameScrollbarUnusable, !canScroll);
            }
            function refreshScrollbarsAutoHide(shallBeVisible, delayfree) {
              clearTimeout(_scrollbarsAutoHideTimeoutId);
              if (shallBeVisible) {
                removeClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                removeClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
              } else {
                var anyActive;
                var strActive = "active";
                var hide = function() {
                  if (!_scrollbarsHandleHovered && !_destroyed) {
                    anyActive = _scrollbarHorizontalHandleElement.hasClass(strActive) || _scrollbarVerticalHandleElement.hasClass(strActive);
                    if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                      addClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                    if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                      addClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
                  }
                };
                if (_scrollbarsAutoHideDelay > 0 && delayfree !== true)
                  _scrollbarsAutoHideTimeoutId = setTimeout(hide, _scrollbarsAutoHideDelay);
                else
                  hide();
              }
            }
            function refreshScrollbarHandleLength(isHorizontal) {
              var handleCSS = {};
              var scrollbarVars = getScrollbarVars(isHorizontal);
              var scrollbarVarsInfo = scrollbarVars._info;
              var digit = 1e6;
              var handleRatio = MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]);
              handleCSS[scrollbarVars._width_height] = MATH.floor(handleRatio * 100 * digit) / digit + "%";
              if (!nativeOverlayScrollbarsAreActive())
                scrollbarVars._handle.css(handleCSS);
              scrollbarVarsInfo._handleLength = scrollbarVars._handle[0]["offset" + scrollbarVars._Width_Height];
              scrollbarVarsInfo._handleLengthRatio = handleRatio;
            }
            function refreshScrollbarHandleOffset(isHorizontal, scrollOrTransition) {
              var transition = type(scrollOrTransition) == TYPES.b;
              var transitionDuration = 250;
              var isRTLisHorizontal = _isRTL && isHorizontal;
              var scrollbarVars = getScrollbarVars(isHorizontal);
              var scrollbarVarsInfo = scrollbarVars._info;
              var strTranslateBrace = "translate(";
              var strTransform = VENDORS._cssProperty("transform");
              var strTransition = VENDORS._cssProperty("transition");
              var nativeScroll = isHorizontal ? _viewportElement[_strScrollLeft]() : _viewportElement[_strScrollTop]();
              var currentScroll = scrollOrTransition === undefined2 || transition ? nativeScroll : scrollOrTransition;
              var handleLength = scrollbarVarsInfo._handleLength;
              var trackLength = scrollbarVars._track[0]["offset" + scrollbarVars._Width_Height];
              var handleTrackDiff = trackLength - handleLength;
              var handleCSS = {};
              var transformOffset;
              var translateValue;
              var maxScroll = (_viewportElementNative[_strScroll + scrollbarVars._Width_Height] - _viewportElementNative["client" + scrollbarVars._Width_Height]) * (_rtlScrollBehavior.n && isRTLisHorizontal ? -1 : 1);
              var getScrollRatio = function(base) {
                return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));
              };
              var getHandleOffset = function(scrollRatio2) {
                var offset = handleTrackDiff * scrollRatio2;
                offset = isNaN(offset) ? 0 : offset;
                offset = isRTLisHorizontal && !_rtlScrollBehavior.i ? trackLength - handleLength - offset : offset;
                offset = MATH.max(0, offset);
                return offset;
              };
              var scrollRatio = getScrollRatio(nativeScroll);
              var unsnappedScrollRatio = getScrollRatio(currentScroll);
              var handleOffset = getHandleOffset(unsnappedScrollRatio);
              var snappedHandleOffset = getHandleOffset(scrollRatio);
              scrollbarVarsInfo._maxScroll = maxScroll;
              scrollbarVarsInfo._currentScroll = nativeScroll;
              scrollbarVarsInfo._currentScrollRatio = scrollRatio;
              if (_supportTransform) {
                transformOffset = isRTLisHorizontal ? -(trackLength - handleLength - handleOffset) : handleOffset;
                translateValue = isHorizontal ? strTranslateBrace + transformOffset + "px, 0)" : strTranslateBrace + "0, " + transformOffset + "px)";
                handleCSS[strTransform] = translateValue;
                if (_supportTransition)
                  handleCSS[strTransition] = transition && MATH.abs(handleOffset - scrollbarVarsInfo._handleOffset) > 1 ? getCSSTransitionString(scrollbarVars._handle) + ", " + (strTransform + _strSpace + transitionDuration + "ms") : _strEmpty;
              } else
                handleCSS[scrollbarVars._left_top] = handleOffset;
              if (!nativeOverlayScrollbarsAreActive()) {
                scrollbarVars._handle.css(handleCSS);
                if (_supportTransform && _supportTransition && transition) {
                  scrollbarVars._handle.one(_strTransitionEndEvent, function() {
                    if (!_destroyed)
                      scrollbarVars._handle.css(strTransition, _strEmpty);
                  });
                }
              }
              scrollbarVarsInfo._handleOffset = handleOffset;
              scrollbarVarsInfo._snappedHandleOffset = snappedHandleOffset;
              scrollbarVarsInfo._trackLength = trackLength;
            }
            function refreshScrollbarsInteractive(isTrack, value) {
              var action = value ? "removeClass" : "addClass";
              var element1 = isTrack ? _scrollbarHorizontalTrackElement : _scrollbarHorizontalHandleElement;
              var element2 = isTrack ? _scrollbarVerticalTrackElement : _scrollbarVerticalHandleElement;
              var className = isTrack ? _classNameScrollbarTrackOff : _classNameScrollbarHandleOff;
              element1[action](className);
              element2[action](className);
            }
            function getScrollbarVars(isHorizontal) {
              return {
                _width_height: isHorizontal ? _strWidth : _strHeight,
                _Width_Height: isHorizontal ? "Width" : "Height",
                _left_top: isHorizontal ? _strLeft : _strTop,
                _Left_Top: isHorizontal ? "Left" : "Top",
                _x_y: isHorizontal ? _strX : _strY,
                _X_Y: isHorizontal ? "X" : "Y",
                _w_h: isHorizontal ? "w" : "h",
                _l_t: isHorizontal ? "l" : "t",
                _track: isHorizontal ? _scrollbarHorizontalTrackElement : _scrollbarVerticalTrackElement,
                _handle: isHorizontal ? _scrollbarHorizontalHandleElement : _scrollbarVerticalHandleElement,
                _scrollbar: isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement,
                _info: isHorizontal ? _scrollHorizontalInfo : _scrollVerticalInfo
              };
            }
            function setupScrollbarCornerDOM(destroy) {
              _scrollbarCornerElement = _scrollbarCornerElement || selectOrGenerateDivByClass(_classNameScrollbarCorner, true);
              if (!destroy) {
                if (!_domExists) {
                  _hostElement.append(_scrollbarCornerElement);
                }
              } else {
                if (_domExists && _initialized) {
                  removeClass(_scrollbarCornerElement.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                } else {
                  remove(_scrollbarCornerElement);
                }
              }
            }
            function setupScrollbarCornerEvents() {
              var insideIFrame = _windowElementNative.top !== _windowElementNative;
              var mouseDownPosition = {};
              var mouseDownSize = {};
              var mouseDownInvertedScale = {};
              var reconnectMutationObserver;
              function documentDragMove(event) {
                if (onMouseTouchDownContinue(event)) {
                  var pageOffset = getCoordinates(event);
                  var hostElementCSS = {};
                  if (_resizeHorizontal || _resizeBoth)
                    hostElementCSS[_strWidth] = mouseDownSize.w + (pageOffset.x - mouseDownPosition.x) * mouseDownInvertedScale.x;
                  if (_resizeVertical || _resizeBoth)
                    hostElementCSS[_strHeight] = mouseDownSize.h + (pageOffset.y - mouseDownPosition.y) * mouseDownInvertedScale.y;
                  _hostElement.css(hostElementCSS);
                  COMPATIBILITY.stpP(event);
                } else {
                  documentMouseTouchUp(event);
                }
              }
              function documentMouseTouchUp(event) {
                var eventIsTrusted = event !== undefined2;
                setupResponsiveEventListener(
                  _documentElement,
                  [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                  [documentOnSelectStart, documentDragMove, documentMouseTouchUp],
                  true
                );
                removeClass(_bodyElement, _classNameDragging);
                if (_scrollbarCornerElement.releaseCapture)
                  _scrollbarCornerElement.releaseCapture();
                if (eventIsTrusted) {
                  if (reconnectMutationObserver)
                    connectMutationObservers();
                  _base.update(_strAuto);
                }
                reconnectMutationObserver = false;
              }
              function onMouseTouchDownContinue(event) {
                var originalEvent = event.originalEvent || event;
                var isTouchEvent = originalEvent.touches !== undefined2;
                return _sleeping || _destroyed ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
              }
              function getCoordinates(event) {
                return _msieVersion && insideIFrame ? { x: event.screenX, y: event.screenY } : COMPATIBILITY.page(event);
              }
              addDestroyEventListener(_scrollbarCornerElement, _strMouseTouchDownEvent, function(event) {
                if (onMouseTouchDownContinue(event) && !_resizeNone) {
                  if (_mutationObserversConnected) {
                    reconnectMutationObserver = true;
                    disconnectMutationObservers();
                  }
                  mouseDownPosition = getCoordinates(event);
                  mouseDownSize.w = _hostElementNative[LEXICON.oW] - (!_isBorderBox ? _paddingX : 0);
                  mouseDownSize.h = _hostElementNative[LEXICON.oH] - (!_isBorderBox ? _paddingY : 0);
                  mouseDownInvertedScale = getHostElementInvertedScale();
                  setupResponsiveEventListener(
                    _documentElement,
                    [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                    [documentOnSelectStart, documentDragMove, documentMouseTouchUp]
                  );
                  addClass(_bodyElement, _classNameDragging);
                  if (_scrollbarCornerElement.setCapture)
                    _scrollbarCornerElement.setCapture();
                  COMPATIBILITY.prvD(event);
                  COMPATIBILITY.stpP(event);
                }
              });
            }
            function dispatchCallback(name, args, dependent) {
              if (dependent === false)
                return;
              if (_initialized) {
                var callback = _currentPreparedOptions.callbacks[name];
                var extensionOnName = name;
                var ext;
                if (extensionOnName.substr(0, 2) === "on")
                  extensionOnName = extensionOnName.substr(2, 1).toLowerCase() + extensionOnName.substr(3);
                if (type(callback) == TYPES.f)
                  callback.call(_base, args);
                each(_extensions, function() {
                  ext = this;
                  if (type(ext.on) == TYPES.f)
                    ext.on(extensionOnName, args);
                });
              } else if (!_destroyed)
                _callbacksInitQeueue.push({ n: name, a: args });
            }
            function setTopRightBottomLeft(targetCSSObject, prefix, values) {
              prefix = prefix || _strEmpty;
              values = values || [_strEmpty, _strEmpty, _strEmpty, _strEmpty];
              targetCSSObject[prefix + _strTop] = values[0];
              targetCSSObject[prefix + _strRight] = values[1];
              targetCSSObject[prefix + _strBottom] = values[2];
              targetCSSObject[prefix + _strLeft] = values[3];
            }
            function getTopRightBottomLeftHost(prefix, suffix, zeroX, zeroY) {
              suffix = suffix || _strEmpty;
              prefix = prefix || _strEmpty;
              return {
                t: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strTop + suffix)),
                r: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strRight + suffix)),
                b: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strBottom + suffix)),
                l: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strLeft + suffix))
              };
            }
            function getCSSTransitionString(element) {
              var transitionStr = VENDORS._cssProperty("transition");
              var assembledValue = element.css(transitionStr);
              if (assembledValue)
                return assembledValue;
              var regExpString = "\\s*(([^,(]+(\\(.+?\\))?)+)[\\s,]*";
              var regExpMain = new RegExp(regExpString);
              var regExpValidate = new RegExp("^(" + regExpString + ")+$");
              var properties = "property duration timing-function delay".split(" ");
              var result = [];
              var strResult;
              var valueArray;
              var i = 0;
              var j;
              var splitCssStyleByComma = function(str) {
                strResult = [];
                if (!str.match(regExpValidate))
                  return str;
                while (str.match(regExpMain)) {
                  strResult.push(RegExp.$1);
                  str = str.replace(regExpMain, _strEmpty);
                }
                return strResult;
              };
              for (; i < properties[LEXICON.l]; i++) {
                valueArray = splitCssStyleByComma(element.css(transitionStr + "-" + properties[i]));
                for (j = 0; j < valueArray[LEXICON.l]; j++)
                  result[j] = (result[j] ? result[j] + _strSpace : _strEmpty) + valueArray[j];
              }
              return result.join(", ");
            }
            function createHostClassNameRegExp(withCurrClassNameOption, withOldClassNameOption) {
              var i;
              var split;
              var appendix;
              var appendClasses = function(classes, condition) {
                appendix = "";
                if (condition && typeof classes == TYPES.s) {
                  split = classes.split(_strSpace);
                  for (i = 0; i < split[LEXICON.l]; i++)
                    appendix += "|" + split[i] + "$";
                }
                return appendix;
              };
              return new RegExp(
                "(^" + _classNameHostElement + "([-_].+|)$)" + appendClasses(_classNameCache, withCurrClassNameOption) + appendClasses(_oldClassName, withOldClassNameOption),
                "g"
              );
            }
            function getHostElementInvertedScale() {
              var rect = _paddingElementNative[LEXICON.bCR]();
              return {
                x: _supportTransform ? 1 / (MATH.round(rect.width) / _paddingElementNative[LEXICON.oW]) || 1 : 1,
                y: _supportTransform ? 1 / (MATH.round(rect.height) / _paddingElementNative[LEXICON.oH]) || 1 : 1
              };
            }
            function isHTMLElement(o) {
              var strOwnerDocument = "ownerDocument";
              var strHTMLElement = "HTMLElement";
              var wnd = o && o[strOwnerDocument] ? o[strOwnerDocument].parentWindow || window2 : window2;
              return typeof wnd[strHTMLElement] == TYPES.o ? o instanceof wnd[strHTMLElement] : o && typeof o == TYPES.o && o !== null && o.nodeType === 1 && typeof o.nodeName == TYPES.s;
            }
            function getArrayDifferences(a1, a2) {
              var a = [];
              var diff = [];
              var i;
              var k;
              for (i = 0; i < a1.length; i++)
                a[a1[i]] = true;
              for (i = 0; i < a2.length; i++) {
                if (a[a2[i]])
                  delete a[a2[i]];
                else
                  a[a2[i]] = true;
              }
              for (k in a)
                diff.push(k);
              return diff;
            }
            function parseToZeroOrNumber(value, toFloat) {
              var num = toFloat ? parseFloat(value) : parseInt(value, 10);
              return isNaN(num) ? 0 : num;
            }
            function getTextareaInfo() {
              var textareaCursorPosition = _targetElementNative.selectionStart;
              if (textareaCursorPosition === undefined2)
                return;
              var textareaValue = _targetElement.val();
              var textareaLength = textareaValue[LEXICON.l];
              var textareaRowSplit = textareaValue.split("\n");
              var textareaLastRow = textareaRowSplit[LEXICON.l];
              var textareaCurrentCursorRowSplit = textareaValue.substr(0, textareaCursorPosition).split("\n");
              var widestRow = 0;
              var textareaLastCol = 0;
              var cursorRow = textareaCurrentCursorRowSplit[LEXICON.l];
              var cursorCol = textareaCurrentCursorRowSplit[textareaCurrentCursorRowSplit[LEXICON.l] - 1][LEXICON.l];
              var rowCols;
              var i;
              for (i = 0; i < textareaRowSplit[LEXICON.l]; i++) {
                rowCols = textareaRowSplit[i][LEXICON.l];
                if (rowCols > textareaLastCol) {
                  widestRow = i + 1;
                  textareaLastCol = rowCols;
                }
              }
              return {
                _cursorRow: cursorRow,
                _cursorColumn: cursorCol,
                _rows: textareaLastRow,
                _columns: textareaLastCol,
                _widestRow: widestRow,
                _cursorPosition: textareaCursorPosition,
                _cursorMax: textareaLength
              };
            }
            function nativeOverlayScrollbarsAreActive() {
              return _ignoreOverlayScrollbarHidingCache && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y);
            }
            function getContentMeasureElement() {
              return _isTextarea ? _textareaCoverElement[0] : _contentElementNative;
            }
            function generateDiv(classesOrAttrs, content) {
              return "<div " + (classesOrAttrs ? type(classesOrAttrs) == TYPES.s ? 'class="' + classesOrAttrs + '"' : function() {
                var key;
                var attrs = _strEmpty;
                if (FRAMEWORK.isPlainObject(classesOrAttrs)) {
                  for (key in classesOrAttrs)
                    attrs += (key === "c" ? "class" : key) + '="' + classesOrAttrs[key] + '" ';
                }
                return attrs;
              }() : _strEmpty) + ">" + (content || _strEmpty) + "</div>";
            }
            function selectOrGenerateDivByClass(className, selectParentOrOnlyChildren) {
              var onlyChildren = type(selectParentOrOnlyChildren) == TYPES.b;
              var selectParent = onlyChildren ? _hostElement : selectParentOrOnlyChildren || _hostElement;
              return _domExists && !selectParent[LEXICON.l] ? null : _domExists ? selectParent[onlyChildren ? "children" : "find"](_strDot + className.replace(/\s/g, _strDot)).eq(0) : FRAMEWORK(generateDiv(className));
            }
            function getObjectPropVal(obj, path) {
              var splits = path.split(_strDot);
              var i = 0;
              var val;
              for (; i < splits.length; i++) {
                if (!obj[LEXICON.hOP](splits[i]))
                  return;
                val = obj[splits[i]];
                if (i < splits.length && type(val) == TYPES.o)
                  obj = val;
              }
              return val;
            }
            function setObjectPropVal(obj, path, val) {
              var splits = path.split(_strDot);
              var splitsLength = splits.length;
              var i = 0;
              var extendObj = {};
              var extendObjRoot = extendObj;
              for (; i < splitsLength; i++)
                extendObj = extendObj[splits[i]] = i + 1 < splitsLength ? {} : val;
              FRAMEWORK.extend(obj, extendObjRoot, true);
            }
            function eachUpdateOnLoad(action) {
              var updateOnLoad = _currentPreparedOptions.updateOnLoad;
              updateOnLoad = type(updateOnLoad) == TYPES.s ? updateOnLoad.split(_strSpace) : updateOnLoad;
              if (COMPATIBILITY.isA(updateOnLoad) && !_destroyed) {
                each(updateOnLoad, action);
              }
            }
            function checkCache(current, cache, force) {
              if (force)
                return force;
              if (type(current) == TYPES.o && type(cache) == TYPES.o) {
                for (var prop in current) {
                  if (prop !== "c") {
                    if (current[LEXICON.hOP](prop) && cache[LEXICON.hOP](prop)) {
                      if (checkCache(current[prop], cache[prop]))
                        return true;
                    } else {
                      return true;
                    }
                  }
                }
              } else {
                return current !== cache;
              }
              return false;
            }
            function extendDeep() {
              return FRAMEWORK.extend.apply(this, [true].concat([].slice.call(arguments)));
            }
            function addClass(el, classes) {
              return _frameworkProto.addClass.call(el, classes);
            }
            function removeClass(el, classes) {
              return _frameworkProto.removeClass.call(el, classes);
            }
            function addRemoveClass(el, classes, doAdd) {
              return doAdd ? addClass(el, classes) : removeClass(el, classes);
            }
            function remove(el) {
              return _frameworkProto.remove.call(el);
            }
            function findFirst(el, selector) {
              return _frameworkProto.find.call(el, selector).eq(0);
            }
            _base.sleep = function() {
              _sleeping = true;
            };
            _base.update = function(force) {
              if (_destroyed)
                return;
              var attrsChanged;
              var contentSizeC;
              var isString = type(force) == TYPES.s;
              var doUpdateAuto;
              var mutHost;
              var mutContent;
              if (isString) {
                if (force === _strAuto) {
                  attrsChanged = meaningfulAttrsChanged();
                  contentSizeC = updateAutoContentSizeChanged();
                  doUpdateAuto = attrsChanged || contentSizeC;
                  if (doUpdateAuto) {
                    update({
                      _contentSizeChanged: contentSizeC,
                      _changedOptions: _initialized ? undefined2 : _currentPreparedOptions
                    });
                  }
                } else if (force === _strSync) {
                  if (_mutationObserversConnected) {
                    mutHost = _mutationObserverHostCallback(_mutationObserverHost.takeRecords());
                    mutContent = _mutationObserverContentCallback(_mutationObserverContent.takeRecords());
                  } else {
                    mutHost = _base.update(_strAuto);
                  }
                } else if (force === "zoom") {
                  update({
                    _hostSizeChanged: true,
                    _contentSizeChanged: true
                  });
                }
              } else {
                force = _sleeping || force;
                _sleeping = false;
                if (!_base.update(_strSync) || force)
                  update({ _force: force });
              }
              updateElementsOnLoad();
              return doUpdateAuto || mutHost || mutContent;
            };
            _base.options = function(newOptions, value) {
              var option = {};
              var changedOps;
              if (FRAMEWORK.isEmptyObject(newOptions) || !FRAMEWORK.isPlainObject(newOptions)) {
                if (type(newOptions) == TYPES.s) {
                  if (arguments.length > 1) {
                    setObjectPropVal(option, newOptions, value);
                    changedOps = setOptions(option);
                  } else
                    return getObjectPropVal(_currentOptions, newOptions);
                } else
                  return _currentOptions;
              } else {
                changedOps = setOptions(newOptions);
              }
              if (!FRAMEWORK.isEmptyObject(changedOps)) {
                update({ _changedOptions: changedOps });
              }
            };
            _base.destroy = function() {
              if (_destroyed)
                return;
              autoUpdateLoop.remove(_base);
              disconnectMutationObservers();
              setupResizeObserver(_sizeObserverElement);
              setupResizeObserver(_sizeAutoObserverElement);
              for (var extName in _extensions)
                _base.removeExt(extName);
              while (_destroyEvents[LEXICON.l] > 0)
                _destroyEvents.pop()();
              setupHostMouseTouchEvents(true);
              if (_contentGlueElement)
                remove(_contentGlueElement);
              if (_contentArrangeElement)
                remove(_contentArrangeElement);
              if (_sizeAutoObserverAdded)
                remove(_sizeAutoObserverElement);
              setupScrollbarsDOM(true);
              setupScrollbarCornerDOM(true);
              setupStructureDOM(true);
              for (var i = 0; i < _updateOnLoadElms[LEXICON.l]; i++)
                FRAMEWORK(_updateOnLoadElms[i]).off(_updateOnLoadEventName, updateOnLoadCallback);
              _updateOnLoadElms = undefined2;
              _destroyed = true;
              _sleeping = true;
              INSTANCES(pluginTargetElement, 0);
              dispatchCallback("onDestroyed");
            };
            _base.scroll = function(coordinates, duration, easing, complete) {
              if (arguments.length === 0 || coordinates === undefined2) {
                var infoX = _scrollHorizontalInfo;
                var infoY = _scrollVerticalInfo;
                var normalizeInvert = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.i;
                var normalizeNegate = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.n;
                var scrollX = infoX._currentScroll;
                var scrollXRatio = infoX._currentScrollRatio;
                var maxScrollX = infoX._maxScroll;
                scrollXRatio = normalizeInvert ? 1 - scrollXRatio : scrollXRatio;
                scrollX = normalizeInvert ? maxScrollX - scrollX : scrollX;
                scrollX *= normalizeNegate ? -1 : 1;
                maxScrollX *= normalizeNegate ? -1 : 1;
                return {
                  position: {
                    x: scrollX,
                    y: infoY._currentScroll
                  },
                  ratio: {
                    x: scrollXRatio,
                    y: infoY._currentScrollRatio
                  },
                  max: {
                    x: maxScrollX,
                    y: infoY._maxScroll
                  },
                  handleOffset: {
                    x: infoX._handleOffset,
                    y: infoY._handleOffset
                  },
                  handleLength: {
                    x: infoX._handleLength,
                    y: infoY._handleLength
                  },
                  handleLengthRatio: {
                    x: infoX._handleLengthRatio,
                    y: infoY._handleLengthRatio
                  },
                  trackLength: {
                    x: infoX._trackLength,
                    y: infoY._trackLength
                  },
                  snappedHandleOffset: {
                    x: infoX._snappedHandleOffset,
                    y: infoY._snappedHandleOffset
                  },
                  isRTL: _isRTL,
                  isRTLNormalized: _normalizeRTLCache
                };
              }
              _base.update(_strSync);
              var normalizeRTL = _normalizeRTLCache;
              var coordinatesXAxisProps = [_strX, _strLeft, "l"];
              var coordinatesYAxisProps = [_strY, _strTop, "t"];
              var coordinatesOperators = ["+=", "-=", "*=", "/="];
              var durationIsObject = type(duration) == TYPES.o;
              var completeCallback = durationIsObject ? duration.complete : complete;
              var i;
              var finalScroll = {};
              var specialEasing = {};
              var doScrollLeft;
              var doScrollTop;
              var animationOptions;
              var strEnd = "end";
              var strBegin = "begin";
              var strCenter = "center";
              var strNearest = "nearest";
              var strAlways = "always";
              var strNever = "never";
              var strIfNeeded = "ifneeded";
              var strLength = LEXICON.l;
              var settingsAxis;
              var settingsScroll;
              var settingsBlock;
              var settingsMargin;
              var finalElement;
              var elementObjSettingsAxisValues = [_strX, _strY, "xy", "yx"];
              var elementObjSettingsBlockValues = [strBegin, strEnd, strCenter, strNearest];
              var elementObjSettingsScrollValues = [strAlways, strNever, strIfNeeded];
              var coordinatesIsElementObj = coordinates[LEXICON.hOP]("el");
              var possibleElement = coordinatesIsElementObj ? coordinates.el : coordinates;
              var possibleElementIsJQuery = possibleElement instanceof FRAMEWORK || JQUERY ? possibleElement instanceof JQUERY : false;
              var possibleElementIsHTMLElement = possibleElementIsJQuery ? false : isHTMLElement(possibleElement);
              var updateScrollbarInfos = function() {
                if (doScrollLeft)
                  refreshScrollbarHandleOffset(true);
                if (doScrollTop)
                  refreshScrollbarHandleOffset(false);
              };
              var proxyCompleteCallback = type(completeCallback) != TYPES.f ? undefined2 : function() {
                updateScrollbarInfos();
                completeCallback();
              };
              function checkSettingsStringValue(currValue, allowedValues) {
                for (i = 0; i < allowedValues[strLength]; i++) {
                  if (currValue === allowedValues[i])
                    return true;
                }
                return false;
              }
              function getRawScroll(isX, coordinates2) {
                var coordinateProps = isX ? coordinatesXAxisProps : coordinatesYAxisProps;
                coordinates2 = type(coordinates2) == TYPES.s || type(coordinates2) == TYPES.n ? [coordinates2, coordinates2] : coordinates2;
                if (COMPATIBILITY.isA(coordinates2))
                  return isX ? coordinates2[0] : coordinates2[1];
                else if (type(coordinates2) == TYPES.o) {
                  for (i = 0; i < coordinateProps[strLength]; i++)
                    if (coordinateProps[i] in coordinates2)
                      return coordinates2[coordinateProps[i]];
                }
              }
              function getFinalScroll(isX, rawScroll) {
                var isString = type(rawScroll) == TYPES.s;
                var operator;
                var amount;
                var scrollInfo = isX ? _scrollHorizontalInfo : _scrollVerticalInfo;
                var currScroll = scrollInfo._currentScroll;
                var maxScroll = scrollInfo._maxScroll;
                var mult = " * ";
                var finalValue;
                var isRTLisX = _isRTL && isX;
                var normalizeShortcuts = isRTLisX && _rtlScrollBehavior.n && !normalizeRTL;
                var strReplace = "replace";
                var evalFunc = eval;
                var possibleOperator;
                if (isString) {
                  if (rawScroll[strLength] > 2) {
                    possibleOperator = rawScroll.substr(0, 2);
                    if (inArray(possibleOperator, coordinatesOperators) > -1)
                      operator = possibleOperator;
                  }
                  rawScroll = operator ? rawScroll.substr(2) : rawScroll;
                  rawScroll = rawScroll[strReplace](/min/g, 0)[strReplace](/</g, 0)[strReplace](/max/g, (normalizeShortcuts ? "-" : _strEmpty) + _strHundredPercent)[strReplace](/>/g, (normalizeShortcuts ? "-" : _strEmpty) + _strHundredPercent)[strReplace](/px/g, _strEmpty)[strReplace](/%/g, mult + maxScroll * (isRTLisX && _rtlScrollBehavior.n ? -1 : 1) / 100)[strReplace](/vw/g, mult + _viewportSize.w)[strReplace](/vh/g, mult + _viewportSize.h);
                  amount = parseToZeroOrNumber(isNaN(rawScroll) ? parseToZeroOrNumber(evalFunc(rawScroll), true).toFixed() : rawScroll);
                } else {
                  amount = rawScroll;
                }
                if (amount !== undefined2 && !isNaN(amount) && type(amount) == TYPES.n) {
                  var normalizeIsRTLisX = normalizeRTL && isRTLisX;
                  var operatorCurrScroll = currScroll * (normalizeIsRTLisX && _rtlScrollBehavior.n ? -1 : 1);
                  var invert = normalizeIsRTLisX && _rtlScrollBehavior.i;
                  var negate = normalizeIsRTLisX && _rtlScrollBehavior.n;
                  operatorCurrScroll = invert ? maxScroll - operatorCurrScroll : operatorCurrScroll;
                  switch (operator) {
                    case "+=":
                      finalValue = operatorCurrScroll + amount;
                      break;
                    case "-=":
                      finalValue = operatorCurrScroll - amount;
                      break;
                    case "*=":
                      finalValue = operatorCurrScroll * amount;
                      break;
                    case "/=":
                      finalValue = operatorCurrScroll / amount;
                      break;
                    default:
                      finalValue = amount;
                      break;
                  }
                  finalValue = invert ? maxScroll - finalValue : finalValue;
                  finalValue *= negate ? -1 : 1;
                  finalValue = isRTLisX && _rtlScrollBehavior.n ? MATH.min(0, MATH.max(maxScroll, finalValue)) : MATH.max(0, MATH.min(maxScroll, finalValue));
                }
                return finalValue === currScroll ? undefined2 : finalValue;
              }
              function getPerAxisValue(value, valueInternalType, defaultValue, allowedValues) {
                var resultDefault = [defaultValue, defaultValue];
                var valueType = type(value);
                var valueArrLength;
                var valueArrItem;
                if (valueType == valueInternalType) {
                  value = [value, value];
                } else if (valueType == TYPES.a) {
                  valueArrLength = value[strLength];
                  if (valueArrLength > 2 || valueArrLength < 1)
                    value = resultDefault;
                  else {
                    if (valueArrLength === 1)
                      value[1] = defaultValue;
                    for (i = 0; i < valueArrLength; i++) {
                      valueArrItem = value[i];
                      if (type(valueArrItem) != valueInternalType || !checkSettingsStringValue(valueArrItem, allowedValues)) {
                        value = resultDefault;
                        break;
                      }
                    }
                  }
                } else if (valueType == TYPES.o)
                  value = [value[_strX] || defaultValue, value[_strY] || defaultValue];
                else
                  value = resultDefault;
                return { x: value[0], y: value[1] };
              }
              function generateMargin(marginTopRightBottomLeftArray) {
                var result = [];
                var currValue;
                var currValueType;
                var valueDirections = [_strTop, _strRight, _strBottom, _strLeft];
                for (i = 0; i < marginTopRightBottomLeftArray[strLength]; i++) {
                  if (i === valueDirections[strLength])
                    break;
                  currValue = marginTopRightBottomLeftArray[i];
                  currValueType = type(currValue);
                  if (currValueType == TYPES.b)
                    result.push(currValue ? parseToZeroOrNumber(finalElement.css(_strMarginMinus + valueDirections[i])) : 0);
                  else
                    result.push(currValueType == TYPES.n ? currValue : 0);
                }
                return result;
              }
              if (possibleElementIsJQuery || possibleElementIsHTMLElement) {
                var margin = coordinatesIsElementObj ? coordinates.margin : 0;
                var axis = coordinatesIsElementObj ? coordinates.axis : 0;
                var scroll = coordinatesIsElementObj ? coordinates.scroll : 0;
                var block = coordinatesIsElementObj ? coordinates.block : 0;
                var marginDefault = [0, 0, 0, 0];
                var marginType = type(margin);
                var marginLength;
                finalElement = possibleElementIsJQuery ? possibleElement : FRAMEWORK(possibleElement);
                if (finalElement[strLength] > 0) {
                  if (marginType == TYPES.n || marginType == TYPES.b)
                    margin = generateMargin([margin, margin, margin, margin]);
                  else if (marginType == TYPES.a) {
                    marginLength = margin[strLength];
                    if (marginLength === 2)
                      margin = generateMargin([margin[0], margin[1], margin[0], margin[1]]);
                    else if (marginLength >= 4)
                      margin = generateMargin(margin);
                    else
                      margin = marginDefault;
                  } else if (marginType == TYPES.o)
                    margin = generateMargin([margin[_strTop], margin[_strRight], margin[_strBottom], margin[_strLeft]]);
                  else
                    margin = marginDefault;
                  settingsAxis = checkSettingsStringValue(axis, elementObjSettingsAxisValues) ? axis : "xy";
                  settingsScroll = getPerAxisValue(scroll, TYPES.s, strAlways, elementObjSettingsScrollValues);
                  settingsBlock = getPerAxisValue(block, TYPES.s, strBegin, elementObjSettingsBlockValues);
                  settingsMargin = margin;
                  var viewportScroll = {
                    l: _scrollHorizontalInfo._currentScroll,
                    t: _scrollVerticalInfo._currentScroll
                  };
                  var viewportOffset = _paddingElement.offset();
                  var elementOffset = finalElement.offset();
                  var doNotScroll = {
                    x: settingsScroll.x == strNever || settingsAxis == _strY,
                    y: settingsScroll.y == strNever || settingsAxis == _strX
                  };
                  elementOffset[_strTop] -= settingsMargin[0];
                  elementOffset[_strLeft] -= settingsMargin[3];
                  var elementScrollCoordinates = {
                    x: MATH.round(elementOffset[_strLeft] - viewportOffset[_strLeft] + viewportScroll.l),
                    y: MATH.round(elementOffset[_strTop] - viewportOffset[_strTop] + viewportScroll.t)
                  };
                  if (_isRTL) {
                    if (!_rtlScrollBehavior.n && !_rtlScrollBehavior.i)
                      elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + viewportScroll.l);
                    if (_rtlScrollBehavior.n && normalizeRTL)
                      elementScrollCoordinates.x *= -1;
                    if (_rtlScrollBehavior.i && normalizeRTL)
                      elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + (_scrollHorizontalInfo._maxScroll - viewportScroll.l));
                  }
                  if (settingsBlock.x != strBegin || settingsBlock.y != strBegin || settingsScroll.x == strIfNeeded || settingsScroll.y == strIfNeeded || _isRTL) {
                    var measuringElm = finalElement[0];
                    var rawElementSize = _supportTransform ? measuringElm[LEXICON.bCR]() : {
                      width: measuringElm[LEXICON.oW],
                      height: measuringElm[LEXICON.oH]
                    };
                    var elementSize = {
                      w: rawElementSize[_strWidth] + settingsMargin[3] + settingsMargin[1],
                      h: rawElementSize[_strHeight] + settingsMargin[0] + settingsMargin[2]
                    };
                    var finalizeBlock = function(isX) {
                      var vars = getScrollbarVars(isX);
                      var wh = vars._w_h;
                      var lt = vars._left_top;
                      var xy = vars._x_y;
                      var blockIsEnd = settingsBlock[xy] == (isX ? _isRTL ? strBegin : strEnd : strEnd);
                      var blockIsCenter = settingsBlock[xy] == strCenter;
                      var blockIsNearest = settingsBlock[xy] == strNearest;
                      var scrollNever = settingsScroll[xy] == strNever;
                      var scrollIfNeeded = settingsScroll[xy] == strIfNeeded;
                      var vpSize = _viewportSize[wh];
                      var vpOffset = viewportOffset[lt];
                      var elSize = elementSize[wh];
                      var elOffset = elementOffset[lt];
                      var divide = blockIsCenter ? 2 : 1;
                      var elementCenterOffset = elOffset + elSize / 2;
                      var viewportCenterOffset = vpOffset + vpSize / 2;
                      var isInView = elSize <= vpSize && elOffset >= vpOffset && elOffset + elSize <= vpOffset + vpSize;
                      if (scrollNever)
                        doNotScroll[xy] = true;
                      else if (!doNotScroll[xy]) {
                        if (blockIsNearest || scrollIfNeeded) {
                          doNotScroll[xy] = scrollIfNeeded ? isInView : false;
                          blockIsEnd = elSize < vpSize ? elementCenterOffset > viewportCenterOffset : elementCenterOffset < viewportCenterOffset;
                        }
                        elementScrollCoordinates[xy] -= blockIsEnd || blockIsCenter ? (vpSize / divide - elSize / divide) * (isX && _isRTL && normalizeRTL ? -1 : 1) : 0;
                      }
                    };
                    finalizeBlock(true);
                    finalizeBlock(false);
                  }
                  if (doNotScroll.y)
                    delete elementScrollCoordinates.y;
                  if (doNotScroll.x)
                    delete elementScrollCoordinates.x;
                  coordinates = elementScrollCoordinates;
                }
              }
              finalScroll[_strScrollLeft] = getFinalScroll(true, getRawScroll(true, coordinates));
              finalScroll[_strScrollTop] = getFinalScroll(false, getRawScroll(false, coordinates));
              doScrollLeft = finalScroll[_strScrollLeft] !== undefined2;
              doScrollTop = finalScroll[_strScrollTop] !== undefined2;
              if ((doScrollLeft || doScrollTop) && (duration > 0 || durationIsObject)) {
                if (durationIsObject) {
                  duration.complete = proxyCompleteCallback;
                  _viewportElement.animate(finalScroll, duration);
                } else {
                  animationOptions = {
                    duration,
                    complete: proxyCompleteCallback
                  };
                  if (COMPATIBILITY.isA(easing) || FRAMEWORK.isPlainObject(easing)) {
                    specialEasing[_strScrollLeft] = easing[0] || easing.x;
                    specialEasing[_strScrollTop] = easing[1] || easing.y;
                    animationOptions.specialEasing = specialEasing;
                  } else {
                    animationOptions.easing = easing;
                  }
                  _viewportElement.animate(finalScroll, animationOptions);
                }
              } else {
                if (doScrollLeft)
                  _viewportElement[_strScrollLeft](finalScroll[_strScrollLeft]);
                if (doScrollTop)
                  _viewportElement[_strScrollTop](finalScroll[_strScrollTop]);
                updateScrollbarInfos();
              }
            };
            _base.scrollStop = function(param1, param2, param3) {
              _viewportElement.stop(param1, param2, param3);
              return _base;
            };
            _base.getElements = function(elementName) {
              var obj = {
                target: _targetElementNative,
                host: _hostElementNative,
                padding: _paddingElementNative,
                viewport: _viewportElementNative,
                content: _contentElementNative,
                scrollbarHorizontal: {
                  scrollbar: _scrollbarHorizontalElement[0],
                  track: _scrollbarHorizontalTrackElement[0],
                  handle: _scrollbarHorizontalHandleElement[0]
                },
                scrollbarVertical: {
                  scrollbar: _scrollbarVerticalElement[0],
                  track: _scrollbarVerticalTrackElement[0],
                  handle: _scrollbarVerticalHandleElement[0]
                },
                scrollbarCorner: _scrollbarCornerElement[0]
              };
              return type(elementName) == TYPES.s ? getObjectPropVal(obj, elementName) : obj;
            };
            _base.getState = function(stateProperty) {
              function prepare(obj2) {
                if (!FRAMEWORK.isPlainObject(obj2))
                  return obj2;
                var extended = extendDeep({}, obj2);
                var changePropertyName = function(from, to) {
                  if (extended[LEXICON.hOP](from)) {
                    extended[to] = extended[from];
                    delete extended[from];
                  }
                };
                changePropertyName("w", _strWidth);
                changePropertyName("h", _strHeight);
                delete extended.c;
                return extended;
              }
              ;
              var obj = {
                destroyed: !!prepare(_destroyed),
                sleeping: !!prepare(_sleeping),
                autoUpdate: prepare(!_mutationObserversConnected),
                widthAuto: prepare(_widthAutoCache),
                heightAuto: prepare(_heightAutoCache),
                padding: prepare(_cssPaddingCache),
                overflowAmount: prepare(_overflowAmountCache),
                hideOverflow: prepare(_hideOverflowCache),
                hasOverflow: prepare(_hasOverflowCache),
                contentScrollSize: prepare(_contentScrollSizeCache),
                viewportSize: prepare(_viewportSize),
                hostSize: prepare(_hostSizeCache),
                documentMixed: prepare(_documentMixed)
              };
              return type(stateProperty) == TYPES.s ? getObjectPropVal(obj, stateProperty) : obj;
            };
            _base.ext = function(extName) {
              var result;
              var privateMethods = _extensionsPrivateMethods.split(" ");
              var i = 0;
              if (type(extName) == TYPES.s) {
                if (_extensions[LEXICON.hOP](extName)) {
                  result = extendDeep({}, _extensions[extName]);
                  for (; i < privateMethods.length; i++)
                    delete result[privateMethods[i]];
                }
              } else {
                result = {};
                for (i in _extensions)
                  result[i] = extendDeep({}, _base.ext(i));
              }
              return result;
            };
            _base.addExt = function(extName, extensionOptions) {
              var registeredExtensionObj = _plugin.extension(extName);
              var instance;
              var instanceAdded;
              var instanceContract;
              var contractResult;
              var contractFulfilled = true;
              if (registeredExtensionObj) {
                if (!_extensions[LEXICON.hOP](extName)) {
                  instance = registeredExtensionObj.extensionFactory.call(
                    _base,
                    extendDeep({}, registeredExtensionObj.defaultOptions),
                    FRAMEWORK,
                    COMPATIBILITY
                  );
                  if (instance) {
                    instanceContract = instance.contract;
                    if (type(instanceContract) == TYPES.f) {
                      contractResult = instanceContract(window2);
                      contractFulfilled = type(contractResult) == TYPES.b ? contractResult : contractFulfilled;
                    }
                    if (contractFulfilled) {
                      _extensions[extName] = instance;
                      instanceAdded = instance.added;
                      if (type(instanceAdded) == TYPES.f)
                        instanceAdded(extensionOptions);
                      return _base.ext(extName);
                    }
                  }
                } else
                  return _base.ext(extName);
              } else
                console.warn('A extension with the name "' + extName + `" isn't registered.`);
            };
            _base.removeExt = function(extName) {
              var instance = _extensions[extName];
              var instanceRemoved;
              if (instance) {
                delete _extensions[extName];
                instanceRemoved = instance.removed;
                if (type(instanceRemoved) == TYPES.f)
                  instanceRemoved();
                return true;
              }
              return false;
            };
            function construct(targetElement, options2, extensions2) {
              _defaultOptions = globals.defaultOptions;
              _nativeScrollbarStyling = globals.nativeScrollbarStyling;
              _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
              _nativeScrollbarIsOverlaid = extendDeep({}, globals.nativeScrollbarIsOverlaid);
              _overlayScrollbarDummySize = extendDeep({}, globals.overlayScrollbarDummySize);
              _rtlScrollBehavior = extendDeep({}, globals.rtlScrollBehavior);
              setOptions(extendDeep({}, _defaultOptions, options2));
              _cssCalc = globals.cssCalc;
              _msieVersion = globals.msie;
              _autoUpdateRecommended = globals.autoUpdateRecommended;
              _supportTransition = globals.supportTransition;
              _supportTransform = globals.supportTransform;
              _supportPassiveEvents = globals.supportPassiveEvents;
              _supportResizeObserver = globals.supportResizeObserver;
              _supportMutationObserver = globals.supportMutationObserver;
              _restrictedMeasuring = globals.restrictedMeasuring;
              _documentElement = FRAMEWORK(targetElement.ownerDocument);
              _documentElementNative = _documentElement[0];
              _windowElement = FRAMEWORK(_documentElementNative.defaultView || _documentElementNative.parentWindow);
              _windowElementNative = _windowElement[0];
              _htmlElement = findFirst(_documentElement, "html");
              _bodyElement = findFirst(_htmlElement, "body");
              _targetElement = FRAMEWORK(targetElement);
              _targetElementNative = _targetElement[0];
              _isTextarea = _targetElement.is("textarea");
              _isBody = _targetElement.is("body");
              _documentMixed = _documentElementNative !== document3;
              _domExists = _isTextarea ? _targetElement.hasClass(_classNameTextareaElement) && _targetElement.parent().hasClass(_classNameContentElement) : _targetElement.hasClass(_classNameHostElement) && _targetElement.children(_strDot + _classNamePaddingElement)[LEXICON.l];
              var initBodyScroll;
              var bodyMouseTouchDownListener;
              if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y && !_currentPreparedOptions.nativeScrollbarsOverlaid.initialize) {
                _initialized = true;
                dispatchCallback("onInitializationWithdrawn");
                if (_domExists) {
                  setupStructureDOM(true);
                  setupScrollbarsDOM(true);
                  setupScrollbarCornerDOM(true);
                }
                _initialized = false;
                _destroyed = true;
                _sleeping = true;
                return _base;
              }
              if (_isBody) {
                initBodyScroll = {};
                initBodyScroll.l = MATH.max(_targetElement[_strScrollLeft](), _htmlElement[_strScrollLeft](), _windowElement[_strScrollLeft]());
                initBodyScroll.t = MATH.max(_targetElement[_strScrollTop](), _htmlElement[_strScrollTop](), _windowElement[_strScrollTop]());
                bodyMouseTouchDownListener = function() {
                  _viewportElement.removeAttr(LEXICON.ti);
                  setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, true, true);
                };
              }
              setupStructureDOM();
              setupScrollbarsDOM();
              setupScrollbarCornerDOM();
              setupStructureEvents();
              setupScrollbarEvents(true);
              setupScrollbarEvents(false);
              setupScrollbarCornerEvents();
              createMutationObservers();
              setupResizeObserver(_sizeObserverElement, hostOnResized);
              if (_isBody) {
                _viewportElement[_strScrollLeft](initBodyScroll.l)[_strScrollTop](initBodyScroll.t);
                if (document3.activeElement == targetElement && _viewportElementNative.focus) {
                  _viewportElement.attr(LEXICON.ti, "-1");
                  _viewportElementNative.focus();
                  setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, false, true);
                }
              }
              _base.update(_strAuto);
              _initialized = true;
              dispatchCallback("onInitialized");
              each(_callbacksInitQeueue, function(index, value) {
                dispatchCallback(value.n, value.a);
              });
              _callbacksInitQeueue = [];
              if (type(extensions2) == TYPES.s)
                extensions2 = [extensions2];
              if (COMPATIBILITY.isA(extensions2))
                each(extensions2, function(index, value) {
                  _base.addExt(value);
                });
              else if (FRAMEWORK.isPlainObject(extensions2))
                each(extensions2, function(key, value) {
                  _base.addExt(key, value);
                });
              setTimeout(function() {
                if (_supportTransition && !_destroyed)
                  addClass(_hostElement, _classNameHostTransition);
              }, 333);
              return _base;
            }
            if (_plugin.valid(construct(pluginTargetElement, options, extensions))) {
              INSTANCES(pluginTargetElement, _base);
            }
            return _base;
          }
          _plugin = window2[PLUGINNAME] = function(pluginTargetElements, options, extensions) {
            if (arguments[LEXICON.l] === 0)
              return this;
            var arr = [];
            var optsIsPlainObj = FRAMEWORK.isPlainObject(options);
            var inst;
            var result;
            if (!pluginTargetElements)
              return optsIsPlainObj || !options ? result : arr;
            pluginTargetElements = pluginTargetElements[LEXICON.l] != undefined2 ? pluginTargetElements : [pluginTargetElements[0] || pluginTargetElements];
            initOverlayScrollbarsStatics();
            if (pluginTargetElements[LEXICON.l] > 0) {
              if (optsIsPlainObj) {
                FRAMEWORK.each(pluginTargetElements, function(i, v) {
                  inst = v;
                  if (inst !== undefined2)
                    arr.push(OverlayScrollbarsInstance(inst, options, extensions, _pluginsGlobals, _pluginsAutoUpdateLoop));
                });
              } else {
                FRAMEWORK.each(pluginTargetElements, function(i, v) {
                  inst = INSTANCES(v);
                  if (options === "!" && _plugin.valid(inst) || COMPATIBILITY.type(options) == TYPES.f && options(v, inst))
                    arr.push(inst);
                  else if (options === undefined2)
                    arr.push(inst);
                });
              }
              result = arr[LEXICON.l] === 1 ? arr[0] : arr;
            }
            return result;
          };
          _plugin.globals = function() {
            initOverlayScrollbarsStatics();
            var globals = FRAMEWORK.extend(true, {}, _pluginsGlobals);
            delete globals["msie"];
            return globals;
          };
          _plugin.defaultOptions = function(newDefaultOptions) {
            initOverlayScrollbarsStatics();
            var currDefaultOptions = _pluginsGlobals.defaultOptions;
            if (newDefaultOptions === undefined2)
              return FRAMEWORK.extend(true, {}, currDefaultOptions);
            _pluginsGlobals.defaultOptions = FRAMEWORK.extend(true, {}, currDefaultOptions, _pluginsOptions._validate(newDefaultOptions, _pluginsOptions._template, true, currDefaultOptions)._default);
          };
          _plugin.valid = function(osInstance) {
            return osInstance instanceof _plugin && !osInstance.getState().destroyed;
          };
          _plugin.extension = function(extensionName, extension, defaultOptions) {
            var extNameTypeString = COMPATIBILITY.type(extensionName) == TYPES.s;
            var argLen = arguments[LEXICON.l];
            var i = 0;
            if (argLen < 1 || !extNameTypeString) {
              return FRAMEWORK.extend(true, { length: _pluginsExtensions[LEXICON.l] }, _pluginsExtensions);
            } else if (extNameTypeString) {
              if (COMPATIBILITY.type(extension) == TYPES.f) {
                _pluginsExtensions.push({
                  name: extensionName,
                  extensionFactory: extension,
                  defaultOptions
                });
              } else {
                for (; i < _pluginsExtensions[LEXICON.l]; i++) {
                  if (_pluginsExtensions[i].name === extensionName) {
                    if (argLen > 1)
                      _pluginsExtensions.splice(i, 1);
                    else
                      return FRAMEWORK.extend(true, {}, _pluginsExtensions[i]);
                  }
                }
              }
            }
          };
          return _plugin;
        }();
        if (JQUERY && JQUERY.fn) {
          JQUERY.fn.overlayScrollbars = function(options, extensions) {
            var _elements = this;
            if (JQUERY.isPlainObject(options)) {
              JQUERY.each(_elements, function() {
                PLUGIN(this, options, extensions);
              });
              return _elements;
            } else
              return PLUGIN(_elements, options);
          };
        }
        return PLUGIN;
      }
    );
  }
});

// src/ScrollArea/OverlayScrollbars.tsx
var OverlayScrollbars_exports = {};
__export(OverlayScrollbars_exports, {
  OverlayScrollbarsComponent: () => OverlayScrollbarsComponent,
  default: () => OverlayScrollbars_default
});
function mergeHostClassNames(osInstance, className) {
  if (import_overlayscrollbars.default.valid(osInstance)) {
    const { host } = osInstance.getElements();
    const regex = new RegExp(
      `(^os-host([-_].+|)$)|${osInstance.options().className.replace(/\s/g, "$|")}$`,
      "g"
    );
    const osClassNames = host.className.split(" ").filter((name) => name.match(regex)).join(" ");
    host.className = `${osClassNames} ${className || ""}`;
  }
}
var import_react6, import_overlayscrollbars, OverlayScrollbarsComponent, OverlayScrollbars_default;
var init_OverlayScrollbars = __esm({
  "src/ScrollArea/OverlayScrollbars.tsx"() {
    import_react6 = __toESM(require("react"));
    import_overlayscrollbars = __toESM(require_OverlayScrollbars());
    OverlayScrollbarsComponent = ({
      options = {},
      extensions,
      className,
      children,
      ...rest
    }) => {
      const osTargetRef = (0, import_react6.useRef)();
      const osInstance = (0, import_react6.useRef)();
      (0, import_react6.useEffect)(() => {
        osInstance.current = (0, import_overlayscrollbars.default)(osTargetRef.current, options, extensions);
        mergeHostClassNames(osInstance.current, className);
        return () => {
          if (import_overlayscrollbars.default.valid(osInstance.current)) {
            osInstance.current.destroy();
            osInstance.current = null;
          }
        };
      }, []);
      (0, import_react6.useEffect)(() => {
        if (import_overlayscrollbars.default.valid(osInstance.current)) {
          osInstance.current.options(options);
        }
      }, [options]);
      (0, import_react6.useEffect)(() => {
        if (import_overlayscrollbars.default.valid(osInstance.current)) {
          mergeHostClassNames(osInstance.current, className);
        }
      }, [className]);
      return /* @__PURE__ */ import_react6.default.createElement("div", {
        className: "os-host",
        ...rest,
        ref: osTargetRef
      }, /* @__PURE__ */ import_react6.default.createElement("div", {
        className: "os-resize-observer-host"
      }), /* @__PURE__ */ import_react6.default.createElement("div", {
        className: "os-padding"
      }, /* @__PURE__ */ import_react6.default.createElement("div", {
        className: "os-viewport"
      }, /* @__PURE__ */ import_react6.default.createElement("div", {
        className: "os-content"
      }, children))), /* @__PURE__ */ import_react6.default.createElement("div", {
        className: "os-scrollbar os-scrollbar-horizontal "
      }, /* @__PURE__ */ import_react6.default.createElement("div", {
        className: "os-scrollbar-track"
      }, /* @__PURE__ */ import_react6.default.createElement("div", {
        className: "os-scrollbar-handle"
      }))), /* @__PURE__ */ import_react6.default.createElement("div", {
        className: "os-scrollbar os-scrollbar-vertical"
      }, /* @__PURE__ */ import_react6.default.createElement("div", {
        className: "os-scrollbar-track"
      }, /* @__PURE__ */ import_react6.default.createElement("div", {
        className: "os-scrollbar-handle"
      }))), /* @__PURE__ */ import_react6.default.createElement("div", {
        className: "os-scrollbar-corner"
      }));
    };
    OverlayScrollbars_default = OverlayScrollbarsComponent;
  }
});

// src/ScrollArea/ScrollArea.tsx
var import_react7, import_theming5, GlobalScrollAreaStyles2, OverlayScrollbars2, Scroller, ScrollArea;
var init_ScrollArea = __esm({
  "src/ScrollArea/ScrollArea.tsx"() {
    import_react7 = __toESM(require("react"));
    import_theming5 = require("@storybook/theming");
    GlobalScrollAreaStyles2 = (0, import_react7.lazy)(() => Promise.resolve().then(() => (init_GlobalScrollAreaStyles(), GlobalScrollAreaStyles_exports)));
    OverlayScrollbars2 = (0, import_react7.lazy)(() => Promise.resolve().then(() => (init_OverlayScrollbars(), OverlayScrollbars_exports)));
    Scroller = ({ horizontal, vertical, ...props }) => /* @__PURE__ */ import_react7.default.createElement(import_react7.Suspense, {
      fallback: /* @__PURE__ */ import_react7.default.createElement("div", {
        ...props
      })
    }, /* @__PURE__ */ import_react7.default.createElement(GlobalScrollAreaStyles2, null), /* @__PURE__ */ import_react7.default.createElement(OverlayScrollbars2, {
      options: { scrollbars: { autoHide: "leave" } },
      ...props
    }));
    ScrollArea = (0, import_theming5.styled)(Scroller)(
      ({ vertical }) => !vertical ? { overflowY: "hidden" } : { overflowY: "auto", height: "100%" },
      ({ horizontal }) => !horizontal ? { overflowX: "hidden" } : { overflowX: "auto", width: "100%" }
    );
    ScrollArea.defaultProps = {
      horizontal: false,
      vertical: false
    };
  }
});

// src/syntaxhighlighter/syntaxhighlighter.tsx
function createCopyToClipboardFunction() {
  if (navigator == null ? void 0 : navigator.clipboard) {
    return (text) => navigator.clipboard.writeText(text);
  }
  return async (text) => {
    const tmp = document2.createElement("TEXTAREA");
    const focus = document2.activeElement;
    tmp.value = text;
    document2.body.appendChild(tmp);
    tmp.select();
    document2.execCommand("copy");
    document2.body.removeChild(tmp);
    focus.focus();
  };
}
var import_react8, import_client_logger, import_theming6, import_global, import_memoizerific, navigator, document2, globalWindow, themedSyntax, copyToClipboard, Wrapper, UnstyledScroller, Scroller2, Pre, Code, processLineNumber, defaultRenderer2, wrapRenderer, SyntaxHighlighter2;
var init_syntaxhighlighter = __esm({
  "src/syntaxhighlighter/syntaxhighlighter.tsx"() {
    import_react8 = __toESM(require("react"));
    import_client_logger = require("@storybook/client-logger");
    import_theming6 = require("@storybook/theming");
    import_global = __toESM(require_window());
    import_memoizerific = __toESM(require("memoizerific"));
    init_jsx();
    init_bash();
    init_css();
    init_js_extras();
    init_json();
    init_graphql();
    init_markup();
    init_markdown();
    init_yaml();
    init_tsx();
    init_typescript();
    init_prism_light();
    init_esm2();
    init_ActionBar();
    init_ScrollArea();
    ({ navigator, document: document2, window: globalWindow } = import_global.default);
    prism_light_default.registerLanguage("jsextra", js_extras_default);
    prism_light_default.registerLanguage("jsx", jsx_default);
    prism_light_default.registerLanguage("json", json_default);
    prism_light_default.registerLanguage("yml", yaml_default);
    prism_light_default.registerLanguage("md", markdown_default);
    prism_light_default.registerLanguage("bash", bash_default);
    prism_light_default.registerLanguage("css", css_default);
    prism_light_default.registerLanguage("html", markup_default);
    prism_light_default.registerLanguage("tsx", tsx_default);
    prism_light_default.registerLanguage("typescript", typescript_default);
    prism_light_default.registerLanguage("graphql", graphql_default);
    themedSyntax = (0, import_memoizerific.default)(2)(
      (theme) => Object.entries(theme.code || {}).reduce((acc, [key, val]) => ({ ...acc, [`* .${key}`]: val }), {})
    );
    copyToClipboard = createCopyToClipboardFunction();
    Wrapper = import_theming6.styled.div(
      ({ theme }) => ({
        position: "relative",
        overflow: "hidden",
        color: theme.color.defaultText
      }),
      ({ theme, bordered }) => bordered ? {
        border: `1px solid ${theme.appBorderColor}`,
        borderRadius: theme.borderRadius,
        background: theme.background.content
      } : {},
      ({ showLineNumbers }) => showLineNumbers ? {
        ".react-syntax-highlighter-line-number::before": {
          content: "attr(data-line-number)"
        }
      } : {}
    );
    UnstyledScroller = ({
      children,
      className
    }) => /* @__PURE__ */ import_react8.default.createElement(ScrollArea, {
      horizontal: true,
      vertical: true,
      className
    }, children);
    Scroller2 = (0, import_theming6.styled)(UnstyledScroller)(
      {
        position: "relative"
      },
      ({ theme }) => themedSyntax(theme)
    );
    Pre = import_theming6.styled.pre(({ theme, padded }) => ({
      display: "flex",
      justifyContent: "flex-start",
      margin: 0,
      padding: padded ? theme.layoutMargin : 0
    }));
    Code = import_theming6.styled.div(({ theme }) => ({
      flex: 1,
      paddingLeft: 2,
      paddingRight: theme.layoutMargin,
      opacity: 1
    }));
    processLineNumber = (row) => {
      const children = [...row.children];
      const lineNumberNode = children[0];
      const lineNumber = lineNumberNode.children[0].value;
      const processedLineNumberNode = {
        ...lineNumberNode,
        children: [],
        properties: {
          ...lineNumberNode.properties,
          "data-line-number": lineNumber,
          style: { ...lineNumberNode.properties.style, userSelect: "auto" }
        }
      };
      children[0] = processedLineNumberNode;
      return { ...row, children };
    };
    defaultRenderer2 = ({ rows, stylesheet, useInlineStyles }) => {
      return rows.map((node, i) => {
        return createElement({
          node: processLineNumber(node),
          stylesheet,
          useInlineStyles,
          key: `code-segement${i}`
        });
      });
    };
    wrapRenderer = (renderer, showLineNumbers) => {
      if (!showLineNumbers) {
        return renderer;
      }
      if (renderer) {
        return ({ rows, ...rest }) => renderer({ rows: rows.map((row) => processLineNumber(row)), ...rest });
      }
      return defaultRenderer2;
    };
    SyntaxHighlighter2 = ({
      children,
      language = "jsx",
      copyable = false,
      bordered = false,
      padded = false,
      format: format2 = true,
      formatter = null,
      className = null,
      showLineNumbers = false,
      ...rest
    }) => {
      if (typeof children !== "string" || !children.trim()) {
        return null;
      }
      const highlightableCode = formatter ? formatter(format2, children) : children.trim();
      const [copied, setCopied] = (0, import_react8.useState)(false);
      const onClick = (0, import_react8.useCallback)(
        (e) => {
          e.preventDefault();
          copyToClipboard(highlightableCode).then(() => {
            setCopied(true);
            globalWindow.setTimeout(() => setCopied(false), 1500);
          }).catch(import_client_logger.logger.error);
        },
        [highlightableCode]
      );
      const renderer = wrapRenderer(rest.renderer, showLineNumbers);
      return /* @__PURE__ */ import_react8.default.createElement(Wrapper, {
        bordered,
        padded,
        showLineNumbers,
        className
      }, /* @__PURE__ */ import_react8.default.createElement(Scroller2, null, /* @__PURE__ */ import_react8.default.createElement(prism_light_default, {
        padded: padded || bordered,
        language,
        showLineNumbers,
        showInlineLineNumbers: showLineNumbers,
        useInlineStyles: false,
        PreTag: Pre,
        CodeTag: Code,
        lineNumberContainerStyle: {},
        ...rest,
        renderer
      }, highlightableCode)), copyable ? /* @__PURE__ */ import_react8.default.createElement(ActionBar, {
        actionItems: [{ title: copied ? "Copied" : "Copy", onClick }]
      }) : null);
    };
  }
});

// src/html.tsx
var html_exports = {};
__export(html_exports, {
  components: () => components2,
  nameSpaceClassNames: () => nameSpaceClassNames,
  resetComponents: () => resetComponents
});
module.exports = __toCommonJS(html_exports);
init_esm();
var import_util_deprecate = __toESM(require("util-deprecate"));

// src/typography/DocumentFormatting.tsx
var nameSpaceClassNames = ({ ...props }, key) => {
  const classes = [props.class, props.className];
  delete props.class;
  props.className = ["sbdocs", `sbdocs-${key}`, ...classes].filter(Boolean).join(" ");
  return props;
};

// src/index.ts
var import_react11 = require("react");

// src/typography/components.tsx
var import_react10 = __toESM(require("react"));

// src/typography/elements/A.tsx
var import_theming = require("@storybook/theming");

// ../../node_modules/polished/dist/polished.esm.js
init_extends();

// ../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// ../../node_modules/polished/dist/polished.esm.js
init_inheritsLoose();

// ../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}

// ../../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
init_setPrototypeOf();

// ../../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

// ../../node_modules/@babel/runtime/helpers/esm/construct.js
init_setPrototypeOf();

// ../../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}

// ../../node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}

// ../../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper2);
    }
    function Wrapper2() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper2.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper2,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper2, Class2);
  };
  return _wrapNativeSuper(Class);
}

// ../../node_modules/polished/dist/polished.esm.js
var ERRORS = {
  "1": "Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\n\n",
  "2": "Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\n\n",
  "3": "Passed an incorrect argument to a color function, please pass a string representation of a color.\n\n",
  "4": "Couldn't generate valid rgb string from %s, it returned %s.\n\n",
  "5": "Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\n\n",
  "6": "Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\n\n",
  "7": "Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\n\n",
  "8": "Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\n\n",
  "9": "Please provide a number of steps to the modularScale helper.\n\n",
  "10": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
  "11": 'Invalid value passed as base to modularScale, expected number or em string but got "%s"\n\n',
  "12": 'Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.\n\n',
  "13": 'Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.\n\n',
  "14": 'Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.\n\n',
  "15": 'Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.\n\n',
  "16": "You must provide a template to this method.\n\n",
  "17": "You passed an unsupported selector state to this method.\n\n",
  "18": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
  "19": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
  "20": "expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
  "21": "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  "22": "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  "23": "fontFace expects a name of a font-family.\n\n",
  "24": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
  "25": "fontFace expects localFonts to be an array.\n\n",
  "26": "fontFace expects fileFormats to be an array.\n\n",
  "27": "radialGradient requries at least 2 color-stops to properly render.\n\n",
  "28": "Please supply a filename to retinaImage() as the first argument.\n\n",
  "29": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
  "30": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  "31": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\n\n",
  "32": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\n\n",
  "33": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\n\n",
  "34": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
  "35": 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n',
  "36": "Property must be a string value.\n\n",
  "37": "Syntax Error at %s.\n\n",
  "38": "Formula contains a function that needs parentheses at %s.\n\n",
  "39": "Formula is missing closing parenthesis at %s.\n\n",
  "40": "Formula has too many closing parentheses at %s.\n\n",
  "41": "All values in a formula must have the same unit or be unitless.\n\n",
  "42": "Please provide a number of steps to the modularScale helper.\n\n",
  "43": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
  "44": "Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\n\n",
  "45": "Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\n\n",
  "46": "Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\n\n",
  "47": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
  "48": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
  "49": "Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
  "50": "Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\n\n",
  "51": "Expects the first argument object to have the properties prop, fromSize, and toSize.\n\n",
  "52": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
  "53": "fontFace expects localFonts to be an array.\n\n",
  "54": "fontFace expects fileFormats to be an array.\n\n",
  "55": "fontFace expects a name of a font-family.\n\n",
  "56": "linearGradient requries at least 2 color-stops to properly render.\n\n",
  "57": "radialGradient requries at least 2 color-stops to properly render.\n\n",
  "58": "Please supply a filename to retinaImage() as the first argument.\n\n",
  "59": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
  "60": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  "61": "Property must be a string value.\n\n",
  "62": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
  "63": 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n',
  "64": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\n\n",
  "65": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\n\n",
  "66": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\n\n",
  "67": "You must provide a template to this method.\n\n",
  "68": "You passed an unsupported selector state to this method.\n\n",
  "69": 'Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.\n\n',
  "70": 'Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.\n\n',
  "71": 'Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.\n\n',
  "72": 'Passed invalid base value %s to %s(), please pass a value like "12px" or 12.\n\n',
  "73": "Please provide a valid CSS variable.\n\n",
  "74": "CSS variable not found and no default was provided.\n\n",
  "75": "important requires a valid style object, got a %s instead.\n\n",
  "76": "fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.\n\n",
  "77": 'remToPx expects a value in "rem" but you provided it in "%s".\n\n',
  "78": 'base must be set in "px" or "%" but you set it in "%s".\n'
};
function format() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var a = args[0];
  var b = [];
  var c;
  for (c = 1; c < args.length; c += 1) {
    b.push(args[c]);
  }
  b.forEach(function(d) {
    a = a.replace(/%[a-z]/, d);
  });
  return a;
}
var PolishedError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(PolishedError2, _Error);
  function PolishedError2(code) {
    var _this;
    if (process.env.NODE_ENV === "production") {
      _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code + " for more information.") || this;
    } else {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      _this = _Error.call(this, format.apply(void 0, [ERRORS[code]].concat(args))) || this;
    }
    return _assertThisInitialized(_this);
  }
  return PolishedError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function colorToInt(color) {
  return Math.round(color * 255);
}
function convertToInt(red, green, blue) {
  return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
}
function hslToRgb(hue, saturation, lightness, convert) {
  if (convert === void 0) {
    convert = convertToInt;
  }
  if (saturation === 0) {
    return convert(lightness, lightness, lightness);
  }
  var huePrime = (hue % 360 + 360) % 360 / 60;
  var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
  var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  var red = 0;
  var green = 0;
  var blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  var lightnessModification = lightness - chroma / 2;
  var finalRed = red + lightnessModification;
  var finalGreen = green + lightnessModification;
  var finalBlue = blue + lightnessModification;
  return convert(finalRed, finalGreen, finalBlue);
}
var namedColorMap = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "639",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
function nameToHex(color) {
  if (typeof color !== "string")
    return color;
  var normalizedColorName = color.toLowerCase();
  return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color;
}
var hexRegex = /^#[a-fA-F0-9]{6}$/;
var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
var rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
var rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
var hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
function parseToRgb(color) {
  if (typeof color !== "string") {
    throw new PolishedError(3);
  }
  var normalizedColor = nameToHex(color);
  if (normalizedColor.match(hexRegex)) {
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
    };
  }
  if (normalizedColor.match(hexRgbaRegex)) {
    var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
      alpha
    };
  }
  if (normalizedColor.match(reducedHexRegex)) {
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
    };
  }
  if (normalizedColor.match(reducedRgbaHexRegex)) {
    var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
      alpha: _alpha
    };
  }
  var rgbMatched = rgbRegex.exec(normalizedColor);
  if (rgbMatched) {
    return {
      red: parseInt("" + rgbMatched[1], 10),
      green: parseInt("" + rgbMatched[2], 10),
      blue: parseInt("" + rgbMatched[3], 10)
    };
  }
  var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
  if (rgbaMatched) {
    return {
      red: parseInt("" + rgbaMatched[1], 10),
      green: parseInt("" + rgbaMatched[2], 10),
      blue: parseInt("" + rgbaMatched[3], 10),
      alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
    };
  }
  var hslMatched = hslRegex.exec(normalizedColor);
  if (hslMatched) {
    var hue = parseInt("" + hslMatched[1], 10);
    var saturation = parseInt("" + hslMatched[2], 10) / 100;
    var lightness = parseInt("" + hslMatched[3], 10) / 100;
    var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
    var hslRgbMatched = rgbRegex.exec(rgbColorString);
    if (!hslRgbMatched) {
      throw new PolishedError(4, normalizedColor, rgbColorString);
    }
    return {
      red: parseInt("" + hslRgbMatched[1], 10),
      green: parseInt("" + hslRgbMatched[2], 10),
      blue: parseInt("" + hslRgbMatched[3], 10)
    };
  }
  var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
  if (hslaMatched) {
    var _hue = parseInt("" + hslaMatched[1], 10);
    var _saturation = parseInt("" + hslaMatched[2], 10) / 100;
    var _lightness = parseInt("" + hslaMatched[3], 10) / 100;
    var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";
    var _hslRgbMatched = rgbRegex.exec(_rgbColorString);
    if (!_hslRgbMatched) {
      throw new PolishedError(4, normalizedColor, _rgbColorString);
    }
    return {
      red: parseInt("" + _hslRgbMatched[1], 10),
      green: parseInt("" + _hslRgbMatched[2], 10),
      blue: parseInt("" + _hslRgbMatched[3], 10),
      alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
    };
  }
  throw new PolishedError(5);
}
var reduceHexValue = function reduceHexValue2(value) {
  if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
    return "#" + value[1] + value[3] + value[5];
  }
  return value;
};
var reduceHexValue$1 = reduceHexValue;
function numberToHex(value) {
  var hex = value.toString(16);
  return hex.length === 1 ? "0" + hex : hex;
}
function rgb(value, green, blue) {
  if (typeof value === "number" && typeof green === "number" && typeof blue === "number") {
    return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
  } else if (typeof value === "object" && green === void 0 && blue === void 0) {
    return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
  }
  throw new PolishedError(6);
}
function rgba(firstValue, secondValue, thirdValue, fourthValue) {
  if (typeof firstValue === "string" && typeof secondValue === "number") {
    var rgbValue = parseToRgb(firstValue);
    return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
  } else if (typeof firstValue === "number" && typeof secondValue === "number" && typeof thirdValue === "number" && typeof fourthValue === "number") {
    return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
  } else if (typeof firstValue === "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0) {
    return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
  }
  throw new PolishedError(7);
}
function curried(f, length2, acc) {
  return function fn() {
    var combined = acc.concat(Array.prototype.slice.call(arguments));
    return combined.length >= length2 ? f.apply(this, combined) : curried(f, length2, combined);
  };
}
function curry(f) {
  return curried(f, f.length, []);
}
function guard(lowerBoundary, upperBoundary, value) {
  return Math.max(lowerBoundary, Math.min(upperBoundary, value));
}
function transparentize(amount, color) {
  if (color === "transparent")
    return color;
  var parsedColor = parseToRgb(color);
  var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
  var colorWithAlpha = _extends({}, parsedColor, {
    alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
  });
  return rgba(colorWithAlpha);
}
var curriedTransparentize = /* @__PURE__ */ curry(transparentize);
var curriedTransparentize$1 = curriedTransparentize;

// src/typography/lib/common.tsx
var headerCommon = ({ theme }) => ({
  margin: "20px 0 8px",
  padding: 0,
  cursor: "text",
  position: "relative",
  color: theme.color.defaultText,
  "&:first-of-type": {
    marginTop: 0,
    paddingTop: 0
  },
  "&:hover a.anchor": {
    textDecoration: "none"
  },
  "& tt, & code": {
    fontSize: "inherit"
  }
});
var codeCommon = ({ theme }) => ({
  lineHeight: 1,
  margin: "0 2px",
  padding: "3px 5px",
  whiteSpace: "nowrap",
  borderRadius: 3,
  fontSize: theme.typography.size.s2 - 1,
  border: theme.base === "light" ? `1px solid ${theme.color.mediumlight}` : `1px solid ${theme.color.darker}`,
  color: theme.base === "light" ? curriedTransparentize$1(0.1, theme.color.defaultText) : curriedTransparentize$1(0.3, theme.color.defaultText),
  backgroundColor: theme.base === "light" ? theme.color.lighter : theme.color.border
});
var withReset = ({ theme }) => ({
  fontFamily: theme.typography.fonts.base,
  fontSize: theme.typography.size.s3,
  margin: 0,
  WebkitFontSmoothing: "antialiased",
  MozOsxFontSmoothing: "grayscale",
  WebkitTapHighlightColor: "rgba(0, 0, 0, 0)",
  WebkitOverflowScrolling: "touch"
});
var withMargin = {
  margin: "16px 0"
};

// src/typography/elements/Link.tsx
var import_react = __toESM(require("react"));
var Link = ({
  href: input,
  children,
  ...props
}) => {
  const isStorybookPath = /^\//.test(input);
  const isAnchorUrl = /^#.*/.test(input);
  const href = isStorybookPath ? `?path=${input}` : input;
  const target = isAnchorUrl ? "_self" : "_top";
  return /* @__PURE__ */ import_react.default.createElement("a", {
    href,
    target,
    ...props
  }, children);
};

// src/typography/elements/A.tsx
var A = (0, import_theming.styled)(Link)(withReset, ({ theme }) => ({
  fontSize: "inherit",
  lineHeight: "24px",
  color: theme.color.secondary,
  textDecoration: "none",
  "&.absent": {
    color: "#cc0000"
  },
  "&.anchor": {
    display: "block",
    paddingLeft: 30,
    marginLeft: -30,
    cursor: "pointer",
    position: "absolute",
    top: 0,
    left: 0,
    bottom: 0
  }
}));

// src/typography/elements/Blockquote.tsx
var import_theming2 = require("@storybook/theming");
var Blockquote = import_theming2.styled.blockquote(withReset, withMargin, ({ theme }) => ({
  borderLeft: `4px solid ${theme.color.medium}`,
  padding: "0 15px",
  color: theme.color.dark,
  "& > :first-of-type": {
    marginTop: 0
  },
  "& > :last-child": {
    marginBottom: 0
  }
}));

// src/typography/elements/Code.tsx
var import_theming7 = require("@storybook/theming");
var import_react9 = __toESM(require("react"));
init_syntaxhighlighter();

// src/typography/lib/isReactChildString.tsx
var isReactChildString = (child) => typeof child === "string";

// src/typography/elements/Code.tsx
var isInlineCodeRegex = /[\n\r]/g;
var DefaultCodeBlock = import_theming7.styled.code(
  ({ theme }) => ({
    fontFamily: theme.typography.fonts.mono,
    WebkitFontSmoothing: "antialiased",
    MozOsxFontSmoothing: "grayscale",
    display: "inline-block",
    paddingLeft: 2,
    paddingRight: 2,
    verticalAlign: "baseline",
    color: "inherit"
  }),
  codeCommon
);
var StyledSyntaxHighlighter = (0, import_theming7.styled)(SyntaxHighlighter2)(({ theme }) => ({
  fontSize: `${theme.typography.size.s2 - 1}px`,
  lineHeight: "19px",
  margin: "25px 0 40px",
  borderRadius: theme.appBorderRadius,
  boxShadow: theme.base === "light" ? "rgba(0, 0, 0, 0.10) 0 1px 3px 0" : "rgba(0, 0, 0, 0.20) 0 2px 5px 0",
  "pre.prismjs": {
    padding: 20,
    background: "inherit"
  }
}));
var Code2 = ({
  className,
  children,
  ...props
}) => {
  const language = (className || "").match(/lang-(\S+)/);
  const childrenArray = import_react9.Children.toArray(children);
  const isInlineCode = !childrenArray.filter(isReactChildString).some((child) => child.match(isInlineCodeRegex));
  if (isInlineCode) {
    return /* @__PURE__ */ import_react9.default.createElement(DefaultCodeBlock, {
      ...props,
      className
    }, childrenArray);
  }
  return /* @__PURE__ */ import_react9.default.createElement(StyledSyntaxHighlighter, {
    bordered: true,
    copyable: true,
    language: (language == null ? void 0 : language[1]) ?? "plaintext",
    format: false,
    ...props
  }, children);
};

// src/typography/elements/Div.tsx
var import_theming8 = require("@storybook/theming");
var Div = import_theming8.styled.div(withReset);

// src/typography/elements/DL.tsx
var import_theming9 = require("@storybook/theming");
var DL = import_theming9.styled.dl(withReset, {
  ...withMargin,
  padding: 0,
  "& dt": {
    fontSize: "14px",
    fontWeight: "bold",
    fontStyle: "italic",
    padding: 0,
    margin: "16px 0 4px"
  },
  "& dt:first-of-type": {
    padding: 0
  },
  "& dt > :first-of-type": {
    marginTop: 0
  },
  "& dt > :last-child": {
    marginBottom: 0
  },
  "& dd": {
    margin: "0 0 16px",
    padding: "0 15px"
  },
  "& dd > :first-of-type": {
    marginTop: 0
  },
  "& dd > :last-child": {
    marginBottom: 0
  }
});

// src/typography/elements/H1.tsx
var import_theming10 = require("@storybook/theming");
var H1 = import_theming10.styled.h1(withReset, headerCommon, ({ theme }) => ({
  fontSize: `${theme.typography.size.l1}px`,
  fontWeight: theme.typography.weight.black
}));

// src/typography/elements/H2.tsx
var import_theming11 = require("@storybook/theming");
var H2 = import_theming11.styled.h2(withReset, headerCommon, ({ theme }) => ({
  fontSize: `${theme.typography.size.m2}px`,
  paddingBottom: 4,
  borderBottom: `1px solid ${theme.appBorderColor}`
}));

// src/typography/elements/H3.tsx
var import_theming12 = require("@storybook/theming");
var H3 = import_theming12.styled.h3(withReset, headerCommon, ({ theme }) => ({
  fontSize: `${theme.typography.size.m1}px`
}));

// src/typography/elements/H4.tsx
var import_theming13 = require("@storybook/theming");
var H4 = import_theming13.styled.h4(withReset, headerCommon, ({ theme }) => ({
  fontSize: `${theme.typography.size.s3}px`
}));

// src/typography/elements/H5.tsx
var import_theming14 = require("@storybook/theming");
var H5 = import_theming14.styled.h5(withReset, headerCommon, ({ theme }) => ({
  fontSize: `${theme.typography.size.s2}px`
}));

// src/typography/elements/H6.tsx
var import_theming15 = require("@storybook/theming");
var H6 = import_theming15.styled.h6(withReset, headerCommon, ({ theme }) => ({
  fontSize: `${theme.typography.size.s2}px`,
  color: theme.color.dark
}));

// src/typography/elements/HR.tsx
var import_theming16 = require("@storybook/theming");
var HR = import_theming16.styled.hr(({ theme }) => ({
  border: "0 none",
  borderTop: `1px solid ${theme.appBorderColor}`,
  height: 4,
  padding: 0
}));

// src/typography/elements/Img.tsx
var import_theming17 = require("@storybook/theming");
var Img = import_theming17.styled.img({
  maxWidth: "100%"
});

// src/typography/elements/LI.tsx
var import_theming18 = require("@storybook/theming");
var LI = import_theming18.styled.li(withReset, ({ theme }) => ({
  fontSize: theme.typography.size.s2,
  color: theme.color.defaultText,
  lineHeight: "24px",
  "& + li": {
    marginTop: ".25em"
  },
  "& ul, & ol": {
    marginTop: ".25em",
    marginBottom: 0
  },
  "& code": codeCommon({ theme })
}));

// src/typography/elements/OL.tsx
var import_theming19 = require("@storybook/theming");
var listCommon = {
  paddingLeft: 30,
  "& :first-of-type": {
    marginTop: 0
  },
  "& :last-child": {
    marginBottom: 0
  }
};
var OL = import_theming19.styled.ol(withReset, withMargin, { ...listCommon, listStyle: "decimal" });

// src/typography/elements/P.tsx
var import_theming20 = require("@storybook/theming");
var P = import_theming20.styled.p(withReset, withMargin, ({ theme }) => ({
  fontSize: theme.typography.size.s2,
  lineHeight: "24px",
  color: theme.color.defaultText,
  "& code": codeCommon({ theme })
}));

// src/typography/elements/Pre.tsx
var import_theming21 = require("@storybook/theming");
var Pre2 = import_theming21.styled.pre(withReset, withMargin, ({ theme }) => ({
  fontFamily: theme.typography.fonts.mono,
  WebkitFontSmoothing: "antialiased",
  MozOsxFontSmoothing: "grayscale",
  lineHeight: "18px",
  padding: "11px 1rem",
  whiteSpace: "pre-wrap",
  color: "inherit",
  borderRadius: 3,
  margin: "1rem 0",
  "&:not(.prismjs)": {
    background: "transparent",
    border: "none",
    borderRadius: 0,
    padding: 0,
    margin: 0
  },
  "& pre, &.prismjs": {
    padding: 15,
    margin: 0,
    whiteSpace: "pre-wrap",
    color: "inherit",
    fontSize: "13px",
    lineHeight: "19px",
    code: {
      color: "inherit",
      fontSize: "inherit"
    }
  },
  "& code": {
    whiteSpace: "pre"
  },
  "& code, & tt": {
    border: "none"
  }
}));

// src/typography/elements/Span.tsx
var import_theming22 = require("@storybook/theming");
var Span = import_theming22.styled.span(withReset, ({ theme }) => ({
  "&.frame": {
    display: "block",
    overflow: "hidden",
    "& > span": {
      border: `1px solid ${theme.color.medium}`,
      display: "block",
      float: "left",
      overflow: "hidden",
      margin: "13px 0 0",
      padding: 7,
      width: "auto"
    },
    "& span img": {
      display: "block",
      float: "left"
    },
    "& span span": {
      clear: "both",
      color: theme.color.darkest,
      display: "block",
      padding: "5px 0 0"
    }
  },
  "&.align-center": {
    display: "block",
    overflow: "hidden",
    clear: "both",
    "& > span": {
      display: "block",
      overflow: "hidden",
      margin: "13px auto 0",
      textAlign: "center"
    },
    "& span img": {
      margin: "0 auto",
      textAlign: "center"
    }
  },
  "&.align-right": {
    display: "block",
    overflow: "hidden",
    clear: "both",
    "& > span": {
      display: "block",
      overflow: "hidden",
      margin: "13px 0 0",
      textAlign: "right"
    },
    "& span img": {
      margin: 0,
      textAlign: "right"
    }
  },
  "&.float-left": {
    display: "block",
    marginRight: 13,
    overflow: "hidden",
    float: "left",
    "& span": {
      margin: "13px 0 0"
    }
  },
  "&.float-right": {
    display: "block",
    marginLeft: 13,
    overflow: "hidden",
    float: "right",
    "& > span": {
      display: "block",
      overflow: "hidden",
      margin: "13px auto 0",
      textAlign: "right"
    }
  }
}));

// src/typography/elements/Table.tsx
var import_theming23 = require("@storybook/theming");
var Table = import_theming23.styled.table(withReset, withMargin, ({ theme }) => ({
  fontSize: theme.typography.size.s2,
  lineHeight: "24px",
  padding: 0,
  borderCollapse: "collapse",
  "& tr": {
    borderTop: `1px solid ${theme.appBorderColor}`,
    backgroundColor: theme.appContentBg,
    margin: 0,
    padding: 0
  },
  "& tr:nth-of-type(2n)": {
    backgroundColor: theme.base === "dark" ? theme.color.darker : theme.color.lighter
  },
  "& tr th": {
    fontWeight: "bold",
    color: theme.color.defaultText,
    border: `1px solid ${theme.appBorderColor}`,
    margin: 0,
    padding: "6px 13px"
  },
  "& tr td": {
    border: `1px solid ${theme.appBorderColor}`,
    color: theme.color.defaultText,
    margin: 0,
    padding: "6px 13px"
  },
  "& tr th :first-of-type, & tr td :first-of-type": {
    marginTop: 0
  },
  "& tr th :last-child, & tr td :last-child": {
    marginBottom: 0
  }
}));

// src/typography/elements/TT.tsx
var import_theming24 = require("@storybook/theming");
var TT = import_theming24.styled.title(codeCommon);

// src/typography/elements/UL.tsx
var import_theming25 = require("@storybook/theming");
var listCommon2 = {
  paddingLeft: 30,
  "& :first-of-type": {
    marginTop: 0
  },
  "& :last-child": {
    marginBottom: 0
  }
};
var UL = import_theming25.styled.ul(withReset, withMargin, { ...listCommon2, listStyle: "disc" });

// src/typography/ResetWrapper.tsx
var import_theming26 = require("@storybook/theming");
var ResetWrapper = import_theming26.styled.div(withReset);

// src/typography/components.tsx
var components = {
  h1: (props) => /* @__PURE__ */ import_react10.default.createElement(H1, {
    ...nameSpaceClassNames(props, "h1")
  }),
  h2: (props) => /* @__PURE__ */ import_react10.default.createElement(H2, {
    ...nameSpaceClassNames(props, "h2")
  }),
  h3: (props) => /* @__PURE__ */ import_react10.default.createElement(H3, {
    ...nameSpaceClassNames(props, "h3")
  }),
  h4: (props) => /* @__PURE__ */ import_react10.default.createElement(H4, {
    ...nameSpaceClassNames(props, "h4")
  }),
  h5: (props) => /* @__PURE__ */ import_react10.default.createElement(H5, {
    ...nameSpaceClassNames(props, "h5")
  }),
  h6: (props) => /* @__PURE__ */ import_react10.default.createElement(H6, {
    ...nameSpaceClassNames(props, "h6")
  }),
  pre: (props) => /* @__PURE__ */ import_react10.default.createElement(Pre2, {
    ...nameSpaceClassNames(props, "pre")
  }),
  a: (props) => /* @__PURE__ */ import_react10.default.createElement(A, {
    ...nameSpaceClassNames(props, "a")
  }),
  hr: (props) => /* @__PURE__ */ import_react10.default.createElement(HR, {
    ...nameSpaceClassNames(props, "hr")
  }),
  dl: (props) => /* @__PURE__ */ import_react10.default.createElement(DL, {
    ...nameSpaceClassNames(props, "dl")
  }),
  blockquote: (props) => /* @__PURE__ */ import_react10.default.createElement(Blockquote, {
    ...nameSpaceClassNames(props, "blockquote")
  }),
  table: (props) => /* @__PURE__ */ import_react10.default.createElement(Table, {
    ...nameSpaceClassNames(props, "table")
  }),
  img: (props) => /* @__PURE__ */ import_react10.default.createElement(Img, {
    ...nameSpaceClassNames(props, "img")
  }),
  div: (props) => /* @__PURE__ */ import_react10.default.createElement(Div, {
    ...nameSpaceClassNames(props, "div")
  }),
  span: (props) => /* @__PURE__ */ import_react10.default.createElement(Span, {
    ...nameSpaceClassNames(props, "span")
  }),
  li: (props) => /* @__PURE__ */ import_react10.default.createElement(LI, {
    ...nameSpaceClassNames(props, "li")
  }),
  ul: (props) => /* @__PURE__ */ import_react10.default.createElement(UL, {
    ...nameSpaceClassNames(props, "ul")
  }),
  ol: (props) => /* @__PURE__ */ import_react10.default.createElement(OL, {
    ...nameSpaceClassNames(props, "ol")
  }),
  p: (props) => /* @__PURE__ */ import_react10.default.createElement(P, {
    ...nameSpaceClassNames(props, "p")
  }),
  code: (props) => /* @__PURE__ */ import_react10.default.createElement(Code2, {
    ...nameSpaceClassNames(props, "code")
  }),
  tt: (props) => /* @__PURE__ */ import_react10.default.createElement(TT, {
    ...nameSpaceClassNames(props, "tt")
  }),
  resetwrapper: (props) => /* @__PURE__ */ import_react10.default.createElement(ResetWrapper, {
    ...nameSpaceClassNames(props, "resetwrapper")
  })
};

// src/index.ts
var components2 = components;
var resetComponents = {};
Object.keys(components).forEach((key) => {
  resetComponents[key] = (0, import_react11.forwardRef)((props, ref) => (0, import_react11.createElement)(key, { ...props, ref }));
});

// src/html.tsx
var deprecatedHtmlEndpoint = (0, import_util_deprecate.default)(
  () => {
  },
  dedent`
    The entry point '@storybook/components/html' is deprecated. Please use '@storybook/components' directly instead.

    See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-storybook-components-html-entry-point
  `
);
deprecatedHtmlEndpoint();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  components,
  nameSpaceClassNames,
  resetComponents
});
