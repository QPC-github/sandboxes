var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default,
  extractSource: () => extractSource
});
module.exports = __toCommonJS(src_exports);

// src/abstract-syntax-tree/default-options.js
var defaultOptions = {
  prettierConfig: {
    printWidth: 100,
    tabWidth: 2,
    bracketSpacing: true,
    trailingComma: "es5",
    singleQuote: true
  },
  uglyCommentsRegex: [/^eslint-.*/, /^global.*/]
};
var default_options_default = defaultOptions;

// src/abstract-syntax-tree/parsers/parser-js.js
var import_parser_babel = __toESM(require("prettier/parser-babel"));
function parse(source) {
  try {
    return import_parser_babel.default.parsers.babel.parse(source);
  } catch (error1) {
    try {
      return JSON.stringify(source);
    } catch (error) {
      throw error1;
    }
  }
}
function format(source) {
  return import_parser_babel.default.parsers.babel.format(source);
}
var parser_js_default = {
  parse,
  format
};

// src/abstract-syntax-tree/parsers/parser-ts.js
var import_parser_typescript = __toESM(require("prettier/parser-typescript"));
function parse2(source) {
  try {
    return import_parser_typescript.default.parsers.typescript.parse(source);
  } catch (error1) {
    try {
      return JSON.stringify(source);
    } catch (error) {
      throw error1;
    }
  }
}
function format2(source) {
  return import_parser_typescript.default.parsers.typescript.format(source);
}
var parser_ts_default = {
  parse: parse2,
  format: format2
};

// src/abstract-syntax-tree/parsers/parser-flow.js
var import_parser_flow = __toESM(require("prettier/parser-flow"));
function parse3(source) {
  return import_parser_flow.default.parsers.flow.parse(source);
}
function format3(source) {
  return import_parser_flow.default.parsers.flow.format(source);
}
var parser_flow_default = {
  parse: parse3,
  format: format3
};

// src/abstract-syntax-tree/parsers/index.js
function getParser(type) {
  if (type === "javascript" || /\.jsx?/.test(type) || !type) {
    return parser_js_default;
  }
  if (type === "typescript" || /\.tsx?/.test(type)) {
    return parser_ts_default;
  }
  if (type === "flow") {
    return parser_flow_default;
  }
  throw new Error(`Parser of type "${type}" is not supported`);
}
var parsers_default = getParser;

// src/abstract-syntax-tree/generate-helpers.js
var import_csf3 = require("@storybook/csf");
var import_mapKeys = __toESM(require("lodash/mapKeys"));

// src/abstract-syntax-tree/parse-helpers.js
var import_csf = require("@storybook/csf");
var STORIES_OF = "storiesOf";
function pushParts(source, parts, from, to) {
  const start = source.slice(from, to);
  parts.push(start);
  const end = source.slice(to);
  parts.push(end);
}
function patchNode(node) {
  if (node.range && node.range.length === 2 && node.start === void 0 && node.end === void 0) {
    const [start, end] = node.range;
    node.start = start;
    node.end = end;
  }
  if (!node.range && node.start !== void 0 && node.end !== void 0) {
    node.range = [node.start, node.end];
  }
  return node;
}
function findTemplate(templateName, program) {
  let template = null;
  program.body.find((node) => {
    var _a;
    let declarations = null;
    if (node.type === "VariableDeclaration") {
      declarations = node.declarations;
    } else if (node.type === "ExportNamedDeclaration" && ((_a = node.declaration) == null ? void 0 : _a.type) === "VariableDeclaration") {
      declarations = node.declaration.declarations;
    }
    return declarations && declarations.find((decl) => {
      if (decl.type === "VariableDeclarator" && decl.id.type === "Identifier" && decl.id.name === templateName) {
        template = decl.init;
        return true;
      }
      return false;
    });
  });
  return template;
}
function expandBindExpression(node, parent) {
  if (node.type === "CallExpression") {
    const { callee, arguments: bindArguments } = node;
    if (parent.type === "Program" && callee.type === "MemberExpression" && callee.object.type === "Identifier" && callee.property.type === "Identifier" && callee.property.name === "bind" && (bindArguments.length === 0 || bindArguments.length === 1 && bindArguments[0].type === "ObjectExpression" && bindArguments[0].properties.length === 0)) {
      const boundIdentifier = callee.object.name;
      const template = findTemplate(boundIdentifier, parent);
      if (template) {
        return template;
      }
    }
  }
  return node;
}
function handleExportedName(storyName, originalNode, parent) {
  const node = expandBindExpression(originalNode, parent);
  const startLoc = {
    col: node.loc.start.column,
    line: node.loc.start.line
  };
  const endLoc = {
    col: node.loc.end.column,
    line: node.loc.end.line
  };
  return {
    [storyName]: {
      startLoc,
      endLoc,
      startBody: startLoc,
      endBody: endLoc
    }
  };
}
function handleADD(node, parent, storiesOfIdentifiers) {
  if (!node.property || !node.property.name || node.property.name !== "add") {
    return {};
  }
  const addArgs = parent.arguments;
  if (!addArgs || addArgs.length < 2) {
    return {};
  }
  let tmp = node.object;
  while (tmp.callee && tmp.callee.object) {
    tmp = tmp.callee.object;
  }
  const framework = tmp.callee && tmp.callee.name && storiesOfIdentifiers[tmp.callee.name];
  const storyName = addArgs[0];
  const body = addArgs[1];
  const lastArg = addArgs[addArgs.length - 1];
  if (storyName.type !== "Literal" && storyName.type !== "StringLiteral") {
    return {};
  }
  if (storyName.value && typeof storyName.value === "string") {
    const key = (0, import_csf.sanitize)(storyName.value);
    let idToFramework;
    if (key && framework) {
      idToFramework = { [key]: framework };
    }
    return {
      toAdd: {
        [key]: {
          startLoc: {
            col: storyName.loc.start.column,
            line: storyName.loc.start.line
          },
          endLoc: {
            col: lastArg.loc.end.column,
            line: lastArg.loc.end.line
          },
          startBody: {
            col: body.loc.start.column,
            line: body.loc.start.line
          },
          endBody: {
            col: body.loc.end.column,
            line: body.loc.end.line
          }
        }
      },
      idToFramework
    };
  }
  return {};
}
function handleSTORYOF(node, parts, source, lastIndex) {
  if (!node.callee || !node.callee.name || node.callee.name !== STORIES_OF) {
    return lastIndex;
  }
  parts.pop();
  pushParts(source, parts, lastIndex, node.end);
  return node.end;
}

// src/abstract-syntax-tree/traverse-helpers.js
var import_csf2 = require("@storybook/csf");
var import_estraverse = __toESM(require("estraverse"));
function splitSTORYOF(ast, source) {
  let lastIndex = 0;
  const parts = [source];
  import_estraverse.default.traverse(ast, {
    fallback: "iteration",
    enter: (node) => {
      patchNode(node);
      if (node.type === "CallExpression") {
        lastIndex = handleSTORYOF(node, parts, source, lastIndex);
      }
    }
  });
  return parts;
}
function isFunctionVariable(declarations, includeExclude) {
  return declarations && declarations.length === 1 && declarations[0].type === "VariableDeclarator" && declarations[0].id && declarations[0].id.name && declarations[0].init && ["CallExpression", "ArrowFunctionExpression", "FunctionExpression"].includes(
    declarations[0].init.type
  ) && (0, import_csf2.isExportStory)(declarations[0].id.name, includeExclude);
}
function isFunctionDeclaration(declaration, includeExclude) {
  return declaration.type === "FunctionDeclaration" && declaration.id && declaration.id.name && (0, import_csf2.isExportStory)(declaration.id.name, includeExclude);
}
function getDescriptor(metaDeclaration, propertyName) {
  const property = metaDeclaration && metaDeclaration.declaration && metaDeclaration.declaration.properties.find((p) => p.key && p.key.name === propertyName);
  if (!property) {
    return void 0;
  }
  const { type } = property.value;
  switch (type) {
    case "ArrayExpression":
      return property.value.elements.map((t) => {
        if (!["StringLiteral", "Literal"].includes(t.type)) {
          throw new Error(`Unexpected descriptor element: ${t.type}`);
        }
        return t.value;
      });
    case "Literal":
    case "RegExpLiteral":
      return property.value.value;
    default:
      throw new Error(`Unexpected descriptor: ${type}`);
  }
}
function findIncludeExclude(ast) {
  const program = ast && ast.program || ast;
  const metaDeclaration = program && program.body && program.body.find(
    (d) => d.type === "ExportDefaultDeclaration" && d.declaration.type === "ObjectExpression" && (d.declaration.properties || []).length
  );
  const includeStories = getDescriptor(metaDeclaration, "includeStories");
  const excludeStories = getDescriptor(metaDeclaration, "excludeStories");
  return {
    includeStories,
    excludeStories
  };
}
function splitExports(ast, source) {
  const parts = [];
  let lastIndex = 0;
  const includeExclude = findIncludeExclude(ast);
  import_estraverse.default.traverse(ast, {
    fallback: "iteration",
    enter: (node) => {
      patchNode(node);
      const isNamedExport = node.type === "ExportNamedDeclaration" && node.declaration;
      const isFunctionVariableExport = isNamedExport && isFunctionVariable(node.declaration.declarations, includeExclude);
      const isFunctionDeclarationExport = isNamedExport && isFunctionDeclaration(node.declaration, includeExclude);
      if (isFunctionDeclarationExport || isFunctionVariableExport) {
        const functionNode = isFunctionVariableExport ? node.declaration.declarations[0].init : node.declaration;
        parts.push({
          source: source.substring(lastIndex, functionNode.start - 1)
        });
        parts.push({
          source: source.substring(functionNode.start, functionNode.end),
          declaration: {
            isVariableDeclaration: isFunctionVariableExport,
            ident: isFunctionVariableExport ? node.declaration.declarations[0].id.name : functionNode.id.name
          }
        });
        lastIndex = functionNode.end;
      }
    }
  });
  if (source.length > lastIndex + 1)
    parts.push({ source: source.substring(lastIndex + 1) });
  if (parts.length === 1)
    return [source];
  return parts;
}
function findAddsMap(ast, storiesOfIdentifiers) {
  const addsMap = {};
  import_estraverse.default.traverse(ast, {
    fallback: "iteration",
    enter: (node, parent) => {
      patchNode(node);
      if (node.type === "MemberExpression") {
        const { toAdd, idToFramework } = handleADD(node, parent, storiesOfIdentifiers);
        Object.assign(addsMap, toAdd);
      }
    }
  });
  return addsMap;
}
function findExportsMap(ast) {
  const addsMap = {};
  import_estraverse.default.traverse(ast, {
    fallback: "iteration",
    enter: (node, parent) => {
      patchNode(node);
      const isNamedExport = node.type === "ExportNamedDeclaration" && node.declaration;
      const isFunctionVariableExport = isNamedExport && node.declaration.declarations && node.declaration.declarations.length === 1 && node.declaration.declarations[0].type === "VariableDeclarator" && node.declaration.declarations[0].id && node.declaration.declarations[0].id.name && node.declaration.declarations[0].init && ["CallExpression", "ArrowFunctionExpression", "FunctionExpression"].includes(
        node.declaration.declarations[0].init.type
      );
      const isFunctionDeclarationExport = isNamedExport && node.declaration.type === "FunctionDeclaration" && node.declaration.id && node.declaration.id.name;
      if (isFunctionDeclarationExport || isFunctionVariableExport) {
        const exportDeclaration = isFunctionVariableExport ? node.declaration.declarations[0] : node.declaration;
        const toAdd = handleExportedName(
          exportDeclaration.id.name,
          exportDeclaration.init || exportDeclaration,
          parent
        );
        Object.assign(addsMap, toAdd);
      }
    }
  });
  return addsMap;
}
function popParametersObjectFromDefaultExport(source, ast) {
  let splicedSource = source;
  let parametersSliceOfCode = "";
  let indexWhereToAppend = -1;
  let foundParametersProperty = false;
  import_estraverse.default.traverse(ast, {
    fallback: "iteration",
    enter: (node) => {
      var _a, _b, _c;
      patchNode(node);
      const isDefaultExport = node.type === "ExportDefaultDeclaration";
      const isObjectExpression = ((_a = node.declaration) == null ? void 0 : _a.type) === "ObjectExpression";
      const isTsAsExpression = ((_b = node.declaration) == null ? void 0 : _b.type) === "TSAsExpression";
      const targetNode = isObjectExpression ? node.declaration : (_c = node.declaration) == null ? void 0 : _c.expression;
      if (isDefaultExport && (isObjectExpression || isTsAsExpression) && (targetNode.properties || []).length) {
        const parametersProperty = targetNode.properties.find(
          (p) => p.key.name === "parameters" && p.value.type === "ObjectExpression"
        );
        foundParametersProperty = !!parametersProperty;
        if (foundParametersProperty) {
          patchNode(parametersProperty.value);
        } else {
          patchNode(targetNode);
        }
        splicedSource = parametersProperty ? source.substring(0, parametersProperty.value.start) + source.substring(parametersProperty.value.end + 1) : splicedSource;
        parametersSliceOfCode = parametersProperty ? source.substring(parametersProperty.value.start, parametersProperty.value.end) : "{}";
        indexWhereToAppend = parametersProperty ? parametersProperty.value.start : targetNode.start + 1;
      }
    }
  });
  return { splicedSource, parametersSliceOfCode, indexWhereToAppend, foundParametersProperty };
}

// src/extract-source.ts
function extractSource(location, lines) {
  const { startBody: start, endBody: end } = location;
  if (start.line === end.line && lines[start.line - 1] !== void 0) {
    return lines[start.line - 1].substring(start.col, end.col);
  }
  const startLine = lines[start.line - 1];
  const endLine = lines[end.line - 1];
  if (startLine === void 0 || endLine === void 0) {
    return null;
  }
  return [
    startLine.substring(start.col),
    ...lines.slice(start.line, end.line - 1),
    endLine.substring(0, end.col)
  ].join("\n");
}

// src/abstract-syntax-tree/generate-helpers.js
function sanitizeSource(source) {
  return JSON.stringify(source).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
}
function isUglyComment(comment, uglyCommentsRegex) {
  return uglyCommentsRegex.some((regex) => regex.test(comment));
}
function generateSourceWithoutUglyComments(source, { comments, uglyCommentsRegex }) {
  let lastIndex = 0;
  const parts = [source];
  comments.filter((comment) => isUglyComment(comment.value.trim(), uglyCommentsRegex)).map(patchNode).forEach((comment) => {
    parts.pop();
    const start = source.slice(lastIndex, comment.start);
    const end = source.slice(comment.end);
    parts.push(start, end);
    lastIndex = comment.end;
  });
  return parts.join("");
}
function prettifyCode(source, { prettierConfig, parser, filepath }) {
  let config = prettierConfig;
  let foundParser = null;
  if (parser === "flow")
    foundParser = "flow";
  if (parser === "javascript" || /jsx?/.test(parser))
    foundParser = "javascript";
  if (parser === "typescript" || /tsx?/.test(parser))
    foundParser = "typescript";
  if (!config.parser) {
    config = {
      ...prettierConfig
    };
  } else if (filepath) {
    config = {
      ...prettierConfig,
      filepath
    };
  } else {
    config = {
      ...prettierConfig
    };
  }
  try {
    return parsers_default(foundParser || "javascript").format(source, config);
  } catch (e) {
    return source;
  }
}
var ADD_PARAMETERS_STATEMENT = ".addParameters({ storySource: { source: __STORY__, locationsMap: __LOCATIONS_MAP__ } })";
var applyExportDecoratorStatement = (part) => part.declaration.isVariableDeclaration ? ` ${part.source};` : ` const ${part.declaration.ident} = ${part.source};`;
function generateSourceWithDecorators(source, ast) {
  const { comments = [] } = ast;
  const partsUsingStoryOfToken = splitSTORYOF(ast, source);
  if (partsUsingStoryOfToken.length > 1) {
    const newSource2 = partsUsingStoryOfToken.join(ADD_PARAMETERS_STATEMENT);
    return {
      storyOfTokenFound: true,
      changed: partsUsingStoryOfToken.length > 1,
      source: newSource2,
      comments
    };
  }
  const partsUsingExports = splitExports(ast, source);
  const newSource = partsUsingExports.map((part, i) => i % 2 === 0 ? part.source : applyExportDecoratorStatement(part)).join("");
  return {
    exportTokenFound: true,
    changed: partsUsingExports.length > 1,
    source: newSource,
    comments
  };
}
function generateSourceWithoutDecorators(source, ast) {
  const { comments = [] } = ast;
  return {
    changed: true,
    source,
    comments
  };
}
function generateAddsMap(ast, storiesOfIdentifiers) {
  return findAddsMap(ast, storiesOfIdentifiers);
}
function generateStoriesLocationsMap(ast, storiesOfIdentifiers) {
  const usingAddsMap = generateAddsMap(ast, storiesOfIdentifiers);
  const addsMap = usingAddsMap;
  if (Object.keys(addsMap).length > 0) {
    return usingAddsMap;
  }
  const usingExportsMap = findExportsMap(ast);
  return usingExportsMap || usingAddsMap;
}
function generateStorySource({ source, ...options }) {
  let storySource = source;
  storySource = generateSourceWithoutUglyComments(storySource, options);
  storySource = prettifyCode(storySource, options);
  return storySource;
}
function transformLocationMapToIds(parameters) {
  if (!(parameters == null ? void 0 : parameters.locationsMap))
    return parameters;
  const locationsMap = (0, import_mapKeys.default)(parameters.locationsMap, (_value, key) => {
    return (0, import_csf3.sanitize)((0, import_csf3.storyNameFromExport)(key));
  });
  return { ...parameters, locationsMap };
}
function generateSourcesInExportedParameters(source, ast, additionalParameters) {
  const { splicedSource, parametersSliceOfCode, indexWhereToAppend, foundParametersProperty } = popParametersObjectFromDefaultExport(source, ast);
  if (indexWhereToAppend !== -1) {
    const additionalParametersAsJson = JSON.stringify({
      storySource: transformLocationMapToIds(additionalParameters)
    }).slice(0, -1);
    const propertyDeclaration = foundParametersProperty ? "" : "parameters: ";
    const comma = foundParametersProperty ? "" : ",";
    const newParameters = `${propertyDeclaration}${additionalParametersAsJson},${parametersSliceOfCode.substring(
      1
    )}${comma}`;
    const additionalComma = comma === "," ? "" : ",";
    const result = `${splicedSource.substring(
      0,
      indexWhereToAppend
    )}${newParameters}${additionalComma}${splicedSource.substring(indexWhereToAppend)}`;
    return result;
  }
  return source;
}
function addStorySourceParameter(key, snippet) {
  const source = sanitizeSource(snippet);
  return `${key}.parameters = { storySource: { source: ${source} }, ...${key}.parameters };`;
}
function generateSourcesInStoryParameters(source, ast, additionalParameters) {
  if (!additionalParameters || !additionalParameters.source || !additionalParameters.locationsMap) {
    return source;
  }
  const { source: sanitizedSource, locationsMap } = additionalParameters;
  const lines = sanitizedSource.split("\n");
  const suffix = Object.entries(locationsMap).reduce((acc, [exportName, location]) => {
    const exportSource = extractSource(location, lines);
    if (exportSource) {
      const generated = addStorySourceParameter(exportName, exportSource);
      return `${acc}
${generated}`;
    }
    return acc;
  }, "");
  return suffix ? `${source}

${suffix}` : source;
}

// src/abstract-syntax-tree/inject-decorator.js
function extendOptions(source, comments, filepath, options) {
  return {
    ...default_options_default,
    ...options,
    source,
    comments,
    filepath
  };
}
function inject(source, filepath, options = {}, log = (message) => {
}) {
  const { injectDecorator = true, injectStoryParameters = false } = options;
  const obviouslyNotCode = ["md", "txt", "json"].includes(options.parser);
  let parser = null;
  try {
    parser = parsers_default(options.parser || filepath);
  } catch (e) {
    log(new Error(`(not fatal, only impacting storysource) Could not load a parser (${e})`));
  }
  if (obviouslyNotCode || !parser) {
    return {
      source,
      storySource: {},
      addsMap: {},
      changed: false
    };
  }
  const ast = parser.parse(source);
  const {
    changed,
    source: cleanedSource,
    comments,
    exportTokenFound
  } = injectDecorator === true ? generateSourceWithDecorators(source, ast) : generateSourceWithoutDecorators(source, ast);
  const storySource = generateStorySource(extendOptions(source, comments, filepath, options));
  const newAst = parser.parse(storySource);
  const addsMap = generateStoriesLocationsMap(newAst, []);
  let newSource = cleanedSource;
  if (exportTokenFound) {
    const cleanedSourceAst = parser.parse(cleanedSource);
    if (injectStoryParameters) {
      newSource = generateSourcesInStoryParameters(cleanedSource, cleanedSourceAst, {
        source: storySource,
        locationsMap: addsMap
      });
    } else {
      newSource = generateSourcesInExportedParameters(cleanedSource, cleanedSourceAst, {
        source: storySource,
        locationsMap: addsMap
      });
    }
  }
  if (!changed && Object.keys(addsMap || {}).length === 0) {
    return {
      source: newSource,
      storySource,
      addsMap: {},
      changed
    };
  }
  return {
    source: newSource,
    storySource,
    addsMap,
    changed
  };
}
var inject_decorator_default = inject;

// src/dependencies-lookup/readAsObject.js
function readAsObject(classLoader, inputSource, mainFile) {
  const options = classLoader.getOptions();
  const result = inject_decorator_default(
    inputSource,
    classLoader.resourcePath,
    {
      ...options,
      parser: options.parser || classLoader.extension
    },
    classLoader.emitWarning.bind(classLoader)
  );
  const sourceJson = sanitizeSource(result.storySource || inputSource);
  const addsMap = result.addsMap || {};
  const source = mainFile ? result.source : inputSource;
  return new Promise(
    (resolve) => resolve({
      source,
      sourceJson,
      addsMap
    })
  );
}
function readStory(classLoader, inputSource) {
  return readAsObject(classLoader, inputSource, true);
}

// src/build.js
async function transform(inputSource) {
  const sourceObject = await readStory(this, inputSource);
  if (!sourceObject.source || sourceObject.source.length === 0) {
    return inputSource;
  }
  const { source, sourceJson, addsMap } = sourceObject;
  const preamble = `
    /* eslint-disable */
    // @ts-nocheck
    // @ts-expect-error (Converted from ts-ignore)
    var __STORY__ = ${sourceJson};
    // @ts-expect-error (Converted from ts-ignore)
    var __LOCATIONS_MAP__ = ${JSON.stringify(addsMap)};
    `;
  return `${preamble}
${source}`;
}

// src/index.ts
var src_default = transform;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  extractSource
});
