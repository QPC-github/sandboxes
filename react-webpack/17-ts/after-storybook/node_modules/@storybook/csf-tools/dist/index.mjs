// src/CsfFile.ts
import fs from "fs-extra";
import { dedent } from "ts-dedent";
import * as t from "@babel/types";
import generate from "@babel/generator";
import traverse from "@babel/traverse";
import { toId, isExportStory, storyNameFromExport } from "@storybook/csf";

// src/babelParse.ts
import { parse } from "@babel/parser";
var babelParse = (code) => parse(code, {
  sourceType: "module",
  plugins: [
    "jsx",
    "typescript",
    ["decorators", { decoratorsBeforeExport: true }],
    "classProperties"
  ],
  tokens: true
});

// src/CsfFile.ts
var logger = console;
function parseIncludeExclude(prop) {
  if (t.isArrayExpression(prop)) {
    return prop.elements.map((e) => {
      if (t.isStringLiteral(e))
        return e.value;
      throw new Error(`Expected string literal: ${e}`);
    });
  }
  if (t.isStringLiteral(prop))
    return new RegExp(prop.value);
  if (t.isRegExpLiteral(prop))
    return new RegExp(prop.pattern, prop.flags);
  throw new Error(`Unknown include/exclude: ${prop}`);
}
var findVarInitialization = (identifier2, program) => {
  let init = null;
  let declarations = null;
  program.body.find((node) => {
    if (t.isVariableDeclaration(node)) {
      declarations = node.declarations;
    } else if (t.isExportNamedDeclaration(node) && t.isVariableDeclaration(node.declaration)) {
      declarations = node.declaration.declarations;
    }
    return declarations && declarations.find((decl) => {
      if (t.isVariableDeclarator(decl) && t.isIdentifier(decl.id) && decl.id.name === identifier2) {
        init = decl.init;
        return true;
      }
      return false;
    });
  });
  return init;
};
var formatLocation = (node, fileName) => {
  const { line, column } = node.loc.start;
  return `${fileName || ""} (line ${line}, col ${column})`.trim();
};
var isArgsStory = (init, parent, csf) => {
  let storyFn = init;
  if (t.isCallExpression(init)) {
    const { callee, arguments: bindArguments } = init;
    if (t.isProgram(parent) && t.isMemberExpression(callee) && t.isIdentifier(callee.object) && t.isIdentifier(callee.property) && callee.property.name === "bind" && (bindArguments.length === 0 || bindArguments.length === 1 && t.isObjectExpression(bindArguments[0]) && bindArguments[0].properties.length === 0)) {
      const boundIdentifier = callee.object.name;
      const template = findVarInitialization(boundIdentifier, parent);
      if (template) {
        csf._templates[boundIdentifier] = template;
        storyFn = template;
      }
    }
  }
  if (t.isArrowFunctionExpression(storyFn)) {
    return storyFn.params.length > 0;
  }
  if (t.isFunctionDeclaration(storyFn)) {
    return storyFn.params.length > 0;
  }
  return false;
};
var parseExportsOrder = (init) => {
  if (t.isArrayExpression(init)) {
    return init.elements.map((item) => {
      if (t.isStringLiteral(item)) {
        return item.value;
      }
      throw new Error(`Expected string literal named export: ${item}`);
    });
  }
  throw new Error(`Expected array of string literals: ${init}`);
};
var sortExports = (exportByName, order) => {
  return order.reduce((acc, name) => {
    const namedExport = exportByName[name];
    if (namedExport)
      acc[name] = namedExport;
    return acc;
  }, {});
};
var NoMetaError = class extends Error {
  constructor(ast, fileName) {
    super(dedent`
      CSF: missing default export ${formatLocation(ast, fileName)}

      More info: https://storybook.js.org/docs/react/writing-stories/introduction#default-export
    `);
    this.name = this.constructor.name;
  }
};
var CsfFile = class {
  constructor(ast, { fileName, makeTitle }) {
    this._stories = {};
    this._metaAnnotations = {};
    this._storyExports = {};
    this._storyAnnotations = {};
    this._templates = {};
    this._ast = ast;
    this._fileName = fileName;
    this.imports = [];
    this._makeTitle = makeTitle;
  }
  _parseTitle(value) {
    const node = t.isIdentifier(value) ? findVarInitialization(value.name, this._ast.program) : value;
    if (t.isStringLiteral(node))
      return node.value;
    throw new Error(dedent`
      CSF: unexpected dynamic title ${formatLocation(node, this._fileName)}

      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#string-literal-titles
    `);
  }
  _parseMeta(declaration, program) {
    const meta = {};
    declaration.properties.forEach((p) => {
      if (t.isIdentifier(p.key)) {
        this._metaAnnotations[p.key.name] = p.value;
        if (p.key.name === "title") {
          meta.title = this._parseTitle(p.value);
        } else if (["includeStories", "excludeStories"].includes(p.key.name)) {
          meta[p.key.name] = parseIncludeExclude(p.value);
        } else if (p.key.name === "component") {
          const { code } = generate(p.value, {});
          meta.component = code;
        } else if (p.key.name === "id") {
          if (t.isStringLiteral(p.value)) {
            meta.id = p.value.value;
          } else {
            throw new Error(`Unexpected component id: ${p.value}`);
          }
        }
      }
    });
    this._meta = meta;
  }
  parse() {
    const self = this;
    traverse(this._ast, {
      ExportDefaultDeclaration: {
        enter({ node, parent }) {
          let metaNode;
          const decl = t.isIdentifier(node.declaration) && t.isProgram(parent) ? findVarInitialization(node.declaration.name, parent) : node.declaration;
          if (t.isObjectExpression(decl)) {
            metaNode = decl;
          } else if (t.isTSAsExpression(decl) && t.isObjectExpression(decl.expression)) {
            metaNode = decl.expression;
          }
          if (!self._meta && metaNode && t.isProgram(parent)) {
            self._parseMeta(metaNode, parent);
          }
        }
      },
      ExportNamedDeclaration: {
        enter({ node, parent }) {
          let declarations;
          if (t.isVariableDeclaration(node.declaration)) {
            declarations = node.declaration.declarations.filter((d) => t.isVariableDeclarator(d));
          } else if (t.isFunctionDeclaration(node.declaration)) {
            declarations = [node.declaration];
          }
          if (declarations) {
            declarations.forEach((decl) => {
              if (t.isIdentifier(decl.id)) {
                const { name: exportName } = decl.id;
                if (exportName === "__namedExportsOrder" && t.isVariableDeclarator(decl)) {
                  self._namedExportsOrder = parseExportsOrder(decl.init);
                  return;
                }
                self._storyExports[exportName] = decl;
                let name = storyNameFromExport(exportName);
                if (self._storyAnnotations[exportName]) {
                  logger.warn(
                    `Unexpected annotations for "${exportName}" before story declaration`
                  );
                } else {
                  self._storyAnnotations[exportName] = {};
                }
                let parameters;
                if (t.isVariableDeclarator(decl) && t.isObjectExpression(decl.init)) {
                  let __isArgsStory = true;
                  decl.init.properties.forEach((p) => {
                    if (t.isIdentifier(p.key)) {
                      if (p.key.name === "render") {
                        __isArgsStory = isArgsStory(p.value, parent, self);
                      } else if (p.key.name === "name" && t.isStringLiteral(p.value)) {
                        name = p.value.value;
                      } else if (p.key.name === "storyName" && t.isStringLiteral(p.value)) {
                        logger.warn(
                          `Unexpected usage of "storyName" in "${exportName}". Please use "name" instead.`
                        );
                      }
                      self._storyAnnotations[exportName][p.key.name] = p.value;
                    }
                  });
                  parameters = { __isArgsStory };
                } else {
                  const fn = t.isVariableDeclarator(decl) ? decl.init : decl;
                  parameters = {
                    __isArgsStory: isArgsStory(fn, parent, self)
                  };
                }
                self._stories[exportName] = {
                  id: "FIXME",
                  name,
                  parameters
                };
              }
            });
          } else if (node.specifiers.length > 0) {
            node.specifiers.forEach((specifier) => {
              if (t.isExportSpecifier(specifier) && t.isIdentifier(specifier.exported)) {
                const { name: exportName } = specifier.exported;
                if (exportName === "default") {
                  let metaNode;
                  const decl = t.isProgram(parent) ? findVarInitialization(specifier.local.name, parent) : specifier.local;
                  if (t.isObjectExpression(decl)) {
                    metaNode = decl;
                  } else if (t.isTSAsExpression(decl) && t.isObjectExpression(decl.expression)) {
                    metaNode = decl.expression;
                  }
                  if (!self._meta && metaNode && t.isProgram(parent)) {
                    self._parseMeta(metaNode, parent);
                  }
                } else {
                  self._storyAnnotations[exportName] = {};
                  self._stories[exportName] = { id: "FIXME", name: exportName, parameters: {} };
                }
              }
            });
          }
        }
      },
      ExpressionStatement: {
        enter({ node, parent }) {
          const { expression } = node;
          if (t.isProgram(parent) && t.isAssignmentExpression(expression) && t.isMemberExpression(expression.left) && t.isIdentifier(expression.left.object) && t.isIdentifier(expression.left.property)) {
            const exportName = expression.left.object.name;
            const annotationKey = expression.left.property.name;
            const annotationValue = expression.right;
            if (self._storyAnnotations[exportName]) {
              if (annotationKey === "story" && t.isObjectExpression(annotationValue)) {
                annotationValue.properties.forEach((prop) => {
                  if (t.isIdentifier(prop.key)) {
                    self._storyAnnotations[exportName][prop.key.name] = prop.value;
                  }
                });
              } else {
                self._storyAnnotations[exportName][annotationKey] = annotationValue;
              }
            }
            if (annotationKey === "storyName" && t.isStringLiteral(annotationValue)) {
              const storyName = annotationValue.value;
              const story = self._stories[exportName];
              if (!story)
                return;
              story.name = storyName;
            }
          }
        }
      },
      CallExpression: {
        enter({ node }) {
          const { callee } = node;
          if (t.isIdentifier(callee) && callee.name === "storiesOf") {
            throw new Error(dedent`
              CSF: unexpected storiesOf call ${formatLocation(node, self._fileName)}

              More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#story-store-v7
            `);
          }
        }
      },
      ImportDeclaration: {
        enter({ node }) {
          const { source } = node;
          if (t.isStringLiteral(source)) {
            self.imports.push(source.value);
          } else {
            throw new Error("CSF: unexpected import source");
          }
        }
      }
    });
    if (!self._meta) {
      throw new NoMetaError(self._ast, self._fileName);
    }
    if (!self._meta.title && !self._meta.component) {
      throw new Error(dedent`
        CSF: missing title/component ${formatLocation(self._ast, self._fileName)}

        More info: https://storybook.js.org/docs/react/writing-stories/introduction#default-export
      `);
    }
    const entries = Object.entries(self._stories);
    self._meta.title = this._makeTitle(self._meta.title);
    self._stories = entries.reduce((acc, [key, story]) => {
      if (isExportStory(key, self._meta)) {
        const id = toId(self._meta.id || self._meta.title, storyNameFromExport(key));
        const parameters = { ...story.parameters, __id: id };
        if (entries.length === 1 && key === "__page") {
          parameters.docsOnly = true;
        }
        acc[key] = { ...story, id, parameters };
      }
      return acc;
    }, {});
    Object.keys(self._storyExports).forEach((key) => {
      if (!isExportStory(key, self._meta)) {
        delete self._storyExports[key];
        delete self._storyAnnotations[key];
      }
    });
    if (self._namedExportsOrder) {
      const unsortedExports = Object.keys(self._storyExports);
      self._storyExports = sortExports(self._storyExports, self._namedExportsOrder);
      self._stories = sortExports(self._stories, self._namedExportsOrder);
      const sortedExports = Object.keys(self._storyExports);
      if (unsortedExports.length !== sortedExports.length) {
        throw new Error(
          `Missing exports after sort: ${unsortedExports.filter(
            (key) => !sortedExports.includes(key)
          )}`
        );
      }
    }
    return self;
  }
  get meta() {
    return this._meta;
  }
  get stories() {
    return Object.values(this._stories);
  }
};
var loadCsf = (code, options) => {
  const ast = babelParse(code);
  return new CsfFile(ast, options);
};
var formatCsf = (csf) => {
  const { code } = generate(csf._ast, {});
  return code;
};
var readCsf = async (fileName, options) => {
  const code = (await fs.readFile(fileName, "utf-8")).toString();
  return loadCsf(code, { ...options, fileName });
};
var writeCsf = async (csf, fileName) => {
  const fname = fileName || csf._fileName;
  if (!fname)
    throw new Error("Please specify a fileName for writeCsf");
  await fs.writeFile(fileName, await formatCsf(csf));
};

// src/ConfigFile.ts
import fs2 from "fs-extra";
import * as t2 from "@babel/types";
import generate2 from "@babel/generator";
import traverse2 from "@babel/traverse";
var logger2 = console;
var propKey = (p) => {
  if (t2.isIdentifier(p.key))
    return p.key.name;
  if (t2.isStringLiteral(p.key))
    return p.key.value;
  return null;
};
var _getPath = (path, node) => {
  if (path.length === 0) {
    return node;
  }
  if (t2.isObjectExpression(node)) {
    const [first, ...rest] = path;
    const field = node.properties.find((p) => propKey(p) === first);
    if (field) {
      return _getPath(rest, field.value);
    }
  }
  return void 0;
};
var _findVarInitialization = (identifier2, program) => {
  let init = null;
  let declarations = null;
  program.body.find((node) => {
    if (t2.isVariableDeclaration(node)) {
      declarations = node.declarations;
    } else if (t2.isExportNamedDeclaration(node) && t2.isVariableDeclaration(node.declaration)) {
      declarations = node.declaration.declarations;
    }
    return declarations && declarations.find((decl) => {
      if (t2.isVariableDeclarator(decl) && t2.isIdentifier(decl.id) && decl.id.name === identifier2) {
        init = decl.init;
        return true;
      }
      return false;
    });
  });
  return init;
};
var _makeObjectExpression = (path, value) => {
  if (path.length === 0)
    return value;
  const [first, ...rest] = path;
  const innerExpression = _makeObjectExpression(rest, value);
  return t2.objectExpression([t2.objectProperty(t2.identifier(first), innerExpression)]);
};
var _updateExportNode = (path, expr, existing) => {
  const [first, ...rest] = path;
  const existingField = existing.properties.find(
    (p) => propKey(p) === first
  );
  if (!existingField) {
    existing.properties.push(
      t2.objectProperty(t2.identifier(first), _makeObjectExpression(rest, expr))
    );
  } else if (t2.isObjectExpression(existingField.value) && rest.length > 0) {
    _updateExportNode(rest, expr, existingField.value);
  } else {
    existingField.value = _makeObjectExpression(rest, expr);
  }
};
var ConfigFile = class {
  constructor(ast, code, fileName) {
    this._exports = {};
    this._ast = ast;
    this._code = code;
    this.fileName = fileName;
  }
  parse() {
    const self = this;
    traverse2(this._ast, {
      ExportNamedDeclaration: {
        enter({ node, parent }) {
          if (t2.isVariableDeclaration(node.declaration)) {
            node.declaration.declarations.forEach((decl) => {
              if (t2.isVariableDeclarator(decl) && t2.isIdentifier(decl.id)) {
                const { name: exportName } = decl.id;
                let exportVal = decl.init;
                if (t2.isIdentifier(exportVal)) {
                  exportVal = _findVarInitialization(exportVal.name, parent);
                }
                self._exports[exportName] = exportVal;
              }
            });
          } else {
            logger2.warn(`Unexpected ${JSON.stringify(node)}`);
          }
        }
      },
      ExpressionStatement: {
        enter({ node, parent }) {
          if (t2.isAssignmentExpression(node.expression) && node.expression.operator === "=") {
            const { left, right } = node.expression;
            if (t2.isMemberExpression(left) && t2.isIdentifier(left.object) && left.object.name === "module" && t2.isIdentifier(left.property) && left.property.name === "exports") {
              let exportObject = right;
              if (t2.isIdentifier(right)) {
                exportObject = _findVarInitialization(right.name, parent);
              }
              if (t2.isObjectExpression(exportObject)) {
                self._exportsObject = exportObject;
                exportObject.properties.forEach((p) => {
                  const exportName = propKey(p);
                  if (exportName) {
                    let exportVal = p.value;
                    if (t2.isIdentifier(exportVal)) {
                      exportVal = _findVarInitialization(exportVal.name, parent);
                    }
                    self._exports[exportName] = exportVal;
                  }
                });
              } else {
                logger2.warn(`Unexpected ${JSON.stringify(node)}`);
              }
            }
          }
        }
      }
    });
    return self;
  }
  getFieldNode(path) {
    const [root, ...rest] = path;
    const exported = this._exports[root];
    if (!exported)
      return void 0;
    return _getPath(rest, exported);
  }
  getFieldValue(path) {
    const node = this.getFieldNode(path);
    if (node) {
      const { code } = generate2(node, {});
      const value = (0, eval)(`(() => (${code}))()`);
      return value;
    }
    return void 0;
  }
  setFieldNode(path, expr) {
    const [first, ...rest] = path;
    const exportNode = this._exports[first];
    if (this._exportsObject) {
      _updateExportNode(path, expr, this._exportsObject);
      this._exports[path[0]] = expr;
    } else if (exportNode && t2.isObjectExpression(exportNode) && rest.length > 0) {
      _updateExportNode(rest, expr, exportNode);
    } else {
      const exportObj = _makeObjectExpression(rest, expr);
      const newExport = t2.exportNamedDeclaration(
        t2.variableDeclaration("const", [t2.variableDeclarator(t2.identifier(first), exportObj)])
      );
      this._exports[first] = exportObj;
      this._ast.program.body.push(newExport);
    }
  }
  _inferQuotes() {
    if (!this._quotes) {
      const occurrences = (this._ast.tokens || []).slice(0, 500).reduce(
        (acc, token) => {
          if (token.type.label === "string") {
            acc[this._code[token.start]] += 1;
          }
          return acc;
        },
        { "'": 0, '"': 0 }
      );
      this._quotes = occurrences["'"] > occurrences['"'] ? "single" : "double";
    }
    return this._quotes;
  }
  setFieldValue(path, value) {
    const quotes = this._inferQuotes();
    let valueNode;
    if (quotes === "single") {
      const { code } = generate2(t2.valueToNode(value), { jsescOption: { quotes } });
      const program = babelParse(`const __x = ${code}`);
      traverse2(program, {
        VariableDeclaration: {
          enter({ node }) {
            if (node.declarations.length === 1 && t2.isVariableDeclarator(node.declarations[0]) && t2.isIdentifier(node.declarations[0].id) && node.declarations[0].id.name === "__x") {
              valueNode = node.declarations[0].init;
            }
          }
        }
      });
    } else {
      valueNode = t2.valueToNode(value);
    }
    if (!valueNode) {
      throw new Error(`Unexpected value ${JSON.stringify(value)}`);
    }
    this.setFieldNode(path, valueNode);
  }
};
var loadConfig = (code, fileName) => {
  const ast = babelParse(code);
  return new ConfigFile(ast, code, fileName);
};
var formatConfig = (config) => {
  const { code } = generate2(config._ast, {});
  return code;
};
var readConfig = async (fileName) => {
  const code = (await fs2.readFile(fileName, "utf-8")).toString();
  return loadConfig(code, fileName).parse();
};
var writeConfig = async (config, fileName) => {
  const fname = fileName || config.fileName;
  if (!fname)
    throw new Error("Please specify a fileName for writeConfig");
  await fs2.writeFile(fname, await formatConfig(config));
};

// src/getStorySortParameter.ts
import * as t3 from "@babel/types";
import traverse3 from "@babel/traverse";
import generate3 from "@babel/generator";
import { dedent as dedent2 } from "ts-dedent";
var logger3 = console;
var getValue = (obj, key) => {
  let value;
  obj.properties.forEach((p) => {
    if (t3.isIdentifier(p.key) && p.key.name === key) {
      value = p.value;
    }
  });
  return value;
};
var parseValue = (expr) => {
  if (t3.isArrayExpression(expr)) {
    return expr.elements.map((o) => {
      return parseValue(o);
    });
  }
  if (t3.isObjectExpression(expr)) {
    return expr.properties.reduce((acc, p) => {
      if (t3.isIdentifier(p.key)) {
        acc[p.key.name] = parseValue(p.value);
      }
      return acc;
    }, {});
  }
  if (t3.isLiteral(expr)) {
    return expr.value;
  }
  throw new Error(`Unknown node type ${expr}`);
};
var unsupported = (unexpectedVar, isError) => {
  const message = dedent2`
    Unexpected '${unexpectedVar}'. Parameter 'options.storySort' should be defined inline e.g.:

    export const parameters = {
      options: {
        storySort: <array | object | function>
      }
    }
  `;
  if (isError) {
    throw new Error(message);
  } else {
    logger3.info(message);
  }
};
var getStorySortParameter = (previewCode) => {
  let storySort;
  const ast = babelParse(previewCode);
  traverse3(ast, {
    ExportNamedDeclaration: {
      enter({ node }) {
        if (t3.isVariableDeclaration(node.declaration)) {
          node.declaration.declarations.forEach((decl) => {
            if (t3.isVariableDeclarator(decl) && t3.isIdentifier(decl.id)) {
              const { name: exportName } = decl.id;
              if (exportName === "parameters") {
                const paramsObject = t3.isTSAsExpression(decl.init) ? decl.init.expression : decl.init;
                if (t3.isObjectExpression(paramsObject)) {
                  const options = getValue(paramsObject, "options");
                  if (options) {
                    if (t3.isObjectExpression(options)) {
                      storySort = getValue(options, "storySort");
                    } else {
                      unsupported("options", true);
                    }
                  }
                } else {
                  unsupported("parameters", true);
                }
              }
            }
          });
        } else {
          node.specifiers.forEach((spec) => {
            if (t3.isIdentifier(spec.exported) && spec.exported.name === "parameters") {
              unsupported("parameters", false);
            }
          });
        }
      }
    }
  });
  if (!storySort)
    return void 0;
  if (t3.isArrowFunctionExpression(storySort)) {
    const { code: sortCode } = generate3(storySort, {});
    return (0, eval)(sortCode);
  }
  if (t3.isFunctionExpression(storySort)) {
    const { code: sortCode } = generate3(storySort, {});
    const functionName = storySort.id.name;
    const wrapper = `(a, b) => {
      ${sortCode};
      return ${functionName}(a, b)
    }`;
    return (0, eval)(wrapper);
  }
  if (t3.isLiteral(storySort) || t3.isArrayExpression(storySort) || t3.isObjectExpression(storySort)) {
    return parseValue(storySort);
  }
  return unsupported("storySort", true);
};
export {
  ConfigFile,
  CsfFile,
  NoMetaError,
  formatConfig,
  formatCsf,
  getStorySortParameter,
  loadConfig,
  loadCsf,
  readConfig,
  readCsf,
  writeConfig,
  writeCsf
};
