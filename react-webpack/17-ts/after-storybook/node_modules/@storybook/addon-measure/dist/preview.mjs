import {
  PARAM_KEY
} from "./chunk-OI6RWK4S.mjs";

// src/withMeasure.ts
import { useEffect } from "@storybook/addons";

// src/box-model/visualizer.ts
import global2 from "global";

// src/box-model/canvas.ts
import global from "global";
function getDocumentWidthAndHeight() {
  const container = global.document.documentElement;
  const height = Math.max(container.scrollHeight, container.offsetHeight);
  const width = Math.max(container.scrollWidth, container.offsetWidth);
  return { width, height };
}
function createCanvas() {
  const canvas = global.document.createElement("canvas");
  canvas.id = "storybook-addon-measure";
  const context = canvas.getContext("2d");
  const { width, height } = getDocumentWidthAndHeight();
  setCanvasWidthAndHeight(canvas, context, { width, height });
  canvas.style.position = "absolute";
  canvas.style.left = "0";
  canvas.style.top = "0";
  canvas.style.zIndex = "2147483647";
  canvas.style.pointerEvents = "none";
  global.document.body.appendChild(canvas);
  return { canvas, context, width, height };
}
function setCanvasWidthAndHeight(canvas, context, { width, height }) {
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;
  const scale = global.window.devicePixelRatio;
  canvas.width = Math.floor(width * scale);
  canvas.height = Math.floor(height * scale);
  context.scale(scale, scale);
}
var state = {};
function init() {
  if (!state.canvas) {
    state = createCanvas();
  }
}
function clear() {
  if (state.context) {
    state.context.clearRect(0, 0, state.width, state.height);
  }
}
function draw(callback) {
  clear();
  callback(state.context);
}
function rescale() {
  setCanvasWidthAndHeight(state.canvas, state.context, { width: 0, height: 0 });
  const { width, height } = getDocumentWidthAndHeight();
  setCanvasWidthAndHeight(state.canvas, state.context, { width, height });
  state.width = width;
  state.height = height;
}
function destroy() {
  if (state.canvas) {
    clear();
    state.canvas.parentNode.removeChild(state.canvas);
    state = {};
  }
}

// src/box-model/labels.ts
var colors = {
  margin: "#f6b26b",
  border: "#ffe599",
  padding: "#93c47d",
  content: "#6fa8dc",
  text: "#232020"
};
var labelPadding = 6;
function roundedRect(context, { x, y, w, h, r }) {
  x = x - w / 2;
  y = y - h / 2;
  if (w < 2 * r)
    r = w / 2;
  if (h < 2 * r)
    r = h / 2;
  context.beginPath();
  context.moveTo(x + r, y);
  context.arcTo(x + w, y, x + w, y + h, r);
  context.arcTo(x + w, y + h, x, y + h, r);
  context.arcTo(x, y + h, x, y, r);
  context.arcTo(x, y, x + w, y, r);
  context.closePath();
}
function positionCoordinate(position, { padding, border, width, height, top, left }) {
  const contentWidth = width - border.left - border.right - padding.left - padding.right;
  const contentHeight = height - padding.top - padding.bottom - border.top - border.bottom;
  let x = left + border.left + padding.left;
  let y = top + border.top + padding.top;
  if (position === "top") {
    x += contentWidth / 2;
  } else if (position === "right") {
    x += contentWidth;
    y += contentHeight / 2;
  } else if (position === "bottom") {
    x += contentWidth / 2;
    y += contentHeight;
  } else if (position === "left") {
    y += contentHeight / 2;
  } else if (position === "center") {
    x += contentWidth / 2;
    y += contentHeight / 2;
  }
  return { x, y };
}
function offset(type, position, { margin, border, padding }, labelPaddingSize, external) {
  let shift = (dir) => 0;
  let offsetX = 0;
  let offsetY = 0;
  const locationMultiplier = external ? 1 : 0.5;
  const labelPaddingShift = external ? labelPaddingSize * 2 : 0;
  if (type === "padding") {
    shift = (dir) => padding[dir] * locationMultiplier + labelPaddingShift;
  } else if (type === "border") {
    shift = (dir) => padding[dir] + border[dir] * locationMultiplier + labelPaddingShift;
  } else if (type === "margin") {
    shift = (dir) => padding[dir] + border[dir] + margin[dir] * locationMultiplier + labelPaddingShift;
  }
  if (position === "top") {
    offsetY = -shift("top");
  } else if (position === "right") {
    offsetX = shift("right");
  } else if (position === "bottom") {
    offsetY = shift("bottom");
  } else if (position === "left") {
    offsetX = -shift("left");
  }
  return { offsetX, offsetY };
}
function collide(a, b) {
  return Math.abs(a.x - b.x) < Math.abs(a.w + b.w) / 2 && Math.abs(a.y - b.y) < Math.abs(a.h + b.h) / 2;
}
function overlapAdjustment(position, currentRect, prevRect) {
  if (position === "top") {
    currentRect.y = prevRect.y - prevRect.h - labelPadding;
  } else if (position === "right") {
    currentRect.x = prevRect.x + prevRect.w / 2 + labelPadding + currentRect.w / 2;
  } else if (position === "bottom") {
    currentRect.y = prevRect.y + prevRect.h + labelPadding;
  } else if (position === "left") {
    currentRect.x = prevRect.x - prevRect.w / 2 - labelPadding - currentRect.w / 2;
  }
  return { x: currentRect.x, y: currentRect.y };
}
function textWithRect(context, type, { x, y, w, h }, text) {
  roundedRect(context, { x, y, w, h, r: 3 });
  context.fillStyle = `${colors[type]}dd`;
  context.fill();
  context.strokeStyle = colors[type];
  context.stroke();
  context.fillStyle = colors.text;
  context.fillText(text, x, y);
  roundedRect(context, { x, y, w, h, r: 3 });
  context.fillStyle = `${colors[type]}dd`;
  context.fill();
  context.strokeStyle = colors[type];
  context.stroke();
  context.fillStyle = colors.text;
  context.fillText(text, x, y);
  return { x, y, w, h };
}
function configureText(context, text) {
  context.font = "600 12px monospace";
  context.textBaseline = "middle";
  context.textAlign = "center";
  const metrics = context.measureText(text);
  const actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
  const w = metrics.width + labelPadding * 2;
  const h = actualHeight + labelPadding * 2;
  return { w, h };
}
function drawLabel(context, measurements, { type, position = "center", text }, prevRect, external = false) {
  let { x, y } = positionCoordinate(position, measurements);
  const { offsetX, offsetY } = offset(type, position, measurements, labelPadding + 1, external);
  x += offsetX;
  y += offsetY;
  const { w, h } = configureText(context, text);
  if (prevRect && collide({ x, y, w, h }, prevRect)) {
    const adjusted = overlapAdjustment(position, { x, y, w, h }, prevRect);
    x = adjusted.x;
    y = adjusted.y;
  }
  return textWithRect(context, type, { x, y, w, h }, text);
}
function floatingOffset(alignment, { w, h }) {
  const deltaW = w * 0.5 + labelPadding;
  const deltaH = h * 0.5 + labelPadding;
  return {
    offsetX: (alignment.x === "left" ? -1 : 1) * deltaW,
    offsetY: (alignment.y === "top" ? -1 : 1) * deltaH
  };
}
function drawFloatingLabel(context, measurements, { type, text }) {
  const { floatingAlignment: floatingAlignment2, extremities } = measurements;
  let x = extremities[floatingAlignment2.x];
  let y = extremities[floatingAlignment2.y];
  const { w, h } = configureText(context, text);
  const { offsetX, offsetY } = floatingOffset(floatingAlignment2, {
    w,
    h
  });
  x += offsetX;
  y += offsetY;
  return textWithRect(context, type, { x, y, w, h }, text);
}
function drawStack(context, measurements, stack, external) {
  const rects = [];
  stack.forEach((l, idx) => {
    const rect = external && l.position === "center" ? drawFloatingLabel(context, measurements, l) : drawLabel(context, measurements, l, rects[idx - 1], external);
    rects[idx] = rect;
  });
}
function labelStacks(context, measurements, labels, externalLabels) {
  const stacks = labels.reduce((acc, l) => {
    if (!Object.prototype.hasOwnProperty.call(acc, l.position)) {
      acc[l.position] = [];
    }
    acc[l.position].push(l);
    return acc;
  }, {});
  if (stacks.top) {
    drawStack(context, measurements, stacks.top, externalLabels);
  }
  if (stacks.right) {
    drawStack(context, measurements, stacks.right, externalLabels);
  }
  if (stacks.bottom) {
    drawStack(context, measurements, stacks.bottom, externalLabels);
  }
  if (stacks.left) {
    drawStack(context, measurements, stacks.left, externalLabels);
  }
  if (stacks.center) {
    drawStack(context, measurements, stacks.center, externalLabels);
  }
}

// src/box-model/visualizer.ts
var colors2 = {
  margin: "#f6b26ba8",
  border: "#ffe599a8",
  padding: "#93c47d8c",
  content: "#6fa8dca8"
};
var SMALL_NODE_SIZE = 30;
function pxToNumber(px) {
  return parseInt(px.replace("px", ""), 10);
}
function round(value) {
  return Number.isInteger(value) ? value : value.toFixed(2);
}
function filterZeroValues(labels) {
  return labels.filter((l) => l.text !== 0 && l.text !== "0");
}
function floatingAlignment(extremities) {
  const windowExtremities = {
    top: global2.window.scrollY,
    bottom: global2.window.scrollY + global2.window.innerHeight,
    left: global2.window.scrollX,
    right: global2.window.scrollX + global2.window.innerWidth
  };
  const distances = {
    top: Math.abs(windowExtremities.top - extremities.top),
    bottom: Math.abs(windowExtremities.bottom - extremities.bottom),
    left: Math.abs(windowExtremities.left - extremities.left),
    right: Math.abs(windowExtremities.right - extremities.right)
  };
  return {
    x: distances.left > distances.right ? "left" : "right",
    y: distances.top > distances.bottom ? "top" : "bottom"
  };
}
function measureElement(element) {
  const style = global2.getComputedStyle(element);
  let { top, left, right, bottom, width, height } = element.getBoundingClientRect();
  const {
    marginTop,
    marginBottom,
    marginLeft,
    marginRight,
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight,
    borderBottomWidth,
    borderTopWidth,
    borderLeftWidth,
    borderRightWidth
  } = style;
  top = top + global2.window.scrollY;
  left = left + global2.window.scrollX;
  bottom = bottom + global2.window.scrollY;
  right = right + global2.window.scrollX;
  const margin = {
    top: pxToNumber(marginTop),
    bottom: pxToNumber(marginBottom),
    left: pxToNumber(marginLeft),
    right: pxToNumber(marginRight)
  };
  const padding = {
    top: pxToNumber(paddingTop),
    bottom: pxToNumber(paddingBottom),
    left: pxToNumber(paddingLeft),
    right: pxToNumber(paddingRight)
  };
  const border = {
    top: pxToNumber(borderTopWidth),
    bottom: pxToNumber(borderBottomWidth),
    left: pxToNumber(borderLeftWidth),
    right: pxToNumber(borderRightWidth)
  };
  const extremities = {
    top: top - margin.top,
    bottom: bottom + margin.bottom,
    left: left - margin.left,
    right: right + margin.right
  };
  return {
    margin,
    padding,
    border,
    top,
    left,
    bottom,
    right,
    width,
    height,
    extremities,
    floatingAlignment: floatingAlignment(extremities)
  };
}
function drawMargin(context, { margin, width, height, top, left, bottom, right }) {
  const marginHeight = height + margin.bottom + margin.top;
  context.fillStyle = colors2.margin;
  context.fillRect(left, top - margin.top, width, margin.top);
  context.fillRect(right, top - margin.top, margin.right, marginHeight);
  context.fillRect(left, bottom, width, margin.bottom);
  context.fillRect(left - margin.left, top - margin.top, margin.left, marginHeight);
  const marginLabels = [
    {
      type: "margin",
      text: round(margin.top),
      position: "top"
    },
    {
      type: "margin",
      text: round(margin.right),
      position: "right"
    },
    {
      type: "margin",
      text: round(margin.bottom),
      position: "bottom"
    },
    {
      type: "margin",
      text: round(margin.left),
      position: "left"
    }
  ];
  return filterZeroValues(marginLabels);
}
function drawPadding(context, { padding, border, width, height, top, left, bottom, right }) {
  const paddingWidth = width - border.left - border.right;
  const paddingHeight = height - padding.top - padding.bottom - border.top - border.bottom;
  context.fillStyle = colors2.padding;
  context.fillRect(left + border.left, top + border.top, paddingWidth, padding.top);
  context.fillRect(
    right - padding.right - border.right,
    top + padding.top + border.top,
    padding.right,
    paddingHeight
  );
  context.fillRect(
    left + border.left,
    bottom - padding.bottom - border.bottom,
    paddingWidth,
    padding.bottom
  );
  context.fillRect(left + border.left, top + padding.top + border.top, padding.left, paddingHeight);
  const paddingLabels = [
    {
      type: "padding",
      text: padding.top,
      position: "top"
    },
    {
      type: "padding",
      text: padding.right,
      position: "right"
    },
    {
      type: "padding",
      text: padding.bottom,
      position: "bottom"
    },
    {
      type: "padding",
      text: padding.left,
      position: "left"
    }
  ];
  return filterZeroValues(paddingLabels);
}
function drawBorder(context, { border, width, height, top, left, bottom, right }) {
  const borderHeight = height - border.top - border.bottom;
  context.fillStyle = colors2.border;
  context.fillRect(left, top, width, border.top);
  context.fillRect(left, bottom - border.bottom, width, border.bottom);
  context.fillRect(left, top + border.top, border.left, borderHeight);
  context.fillRect(right - border.right, top + border.top, border.right, borderHeight);
  const borderLabels = [
    {
      type: "border",
      text: border.top,
      position: "top"
    },
    {
      type: "border",
      text: border.right,
      position: "right"
    },
    {
      type: "border",
      text: border.bottom,
      position: "bottom"
    },
    {
      type: "border",
      text: border.left,
      position: "left"
    }
  ];
  return filterZeroValues(borderLabels);
}
function drawContent(context, { padding, border, width, height, top, left }) {
  const contentWidth = width - border.left - border.right - padding.left - padding.right;
  const contentHeight = height - padding.top - padding.bottom - border.top - border.bottom;
  context.fillStyle = colors2.content;
  context.fillRect(
    left + border.left + padding.left,
    top + border.top + padding.top,
    contentWidth,
    contentHeight
  );
  return [
    {
      type: "content",
      position: "center",
      text: `${round(contentWidth)} x ${round(contentHeight)}`
    }
  ];
}
function drawBoxModel(element) {
  return (context) => {
    if (element && context) {
      const measurements = measureElement(element);
      const marginLabels = drawMargin(context, measurements);
      const paddingLabels = drawPadding(context, measurements);
      const borderLabels = drawBorder(context, measurements);
      const contentLabels = drawContent(context, measurements);
      const externalLabels = measurements.width <= SMALL_NODE_SIZE * 3 || measurements.height <= SMALL_NODE_SIZE;
      labelStacks(
        context,
        measurements,
        [...contentLabels, ...paddingLabels, ...borderLabels, ...marginLabels],
        externalLabels
      );
    }
  };
}
function drawSelectedElement(element) {
  draw(drawBoxModel(element));
}

// src/util.ts
import global3 from "global";
var deepElementFromPoint = (x, y) => {
  const element = global3.document.elementFromPoint(x, y);
  const crawlShadows = (node) => {
    if (node && node.shadowRoot) {
      const nestedElement = node.shadowRoot.elementFromPoint(x, y);
      if (node.isEqualNode(nestedElement)) {
        return node;
      }
      if (nestedElement.shadowRoot) {
        return crawlShadows(nestedElement);
      }
      return nestedElement;
    }
    return node;
  };
  const shadowElement = crawlShadows(element);
  return shadowElement || element;
};

// src/withMeasure.ts
var nodeAtPointerRef;
var pointer = { x: 0, y: 0 };
function findAndDrawElement(x, y) {
  nodeAtPointerRef = deepElementFromPoint(x, y);
  drawSelectedElement(nodeAtPointerRef);
}
var withMeasure = (StoryFn, context) => {
  const { measureEnabled } = context.globals;
  useEffect(() => {
    const onMouseMove = (event) => {
      window.requestAnimationFrame(() => {
        event.stopPropagation();
        pointer.x = event.clientX;
        pointer.y = event.clientY;
      });
    };
    document.addEventListener("mousemove", onMouseMove);
    return () => {
      document.removeEventListener("mousemove", onMouseMove);
    };
  }, []);
  useEffect(() => {
    const onMouseOver = (event) => {
      window.requestAnimationFrame(() => {
        event.stopPropagation();
        findAndDrawElement(event.clientX, event.clientY);
      });
    };
    const onResize = () => {
      window.requestAnimationFrame(() => {
        rescale();
      });
    };
    if (measureEnabled) {
      document.addEventListener("mouseover", onMouseOver);
      init();
      window.addEventListener("resize", onResize);
      findAndDrawElement(pointer.x, pointer.y);
    }
    return () => {
      window.removeEventListener("resize", onResize);
      destroy();
    };
  }, [measureEnabled]);
  return StoryFn();
};

// src/preview.tsx
var decorators = [withMeasure];
var globals = {
  [PARAM_KEY]: false
};
export {
  decorators,
  globals
};
