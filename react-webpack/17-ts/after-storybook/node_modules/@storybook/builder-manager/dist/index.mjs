var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});

// src/index.ts
import { dirname as dirname2, join as join3 } from "path";
import { copy, writeFile as writeFile2, remove } from "fs-extra";
import express from "express";
import { logger } from "@storybook/node-logger";
import { globalExternals } from "@fal-works/esbuild-plugin-global-externals";
import { pnpPlugin } from "@yarnpkg/esbuild-plugin-pnp";
import aliasPlugin from "esbuild-plugin-alias";

// src/utils/template.ts
import path, { dirname, join } from "path";
import { readFile, pathExists } from "fs-extra";
import { render } from "ejs";
var getTemplatePath = async (template) => {
  return join(
    dirname(__require.resolve("@storybook/builder-manager/package.json")),
    "templates",
    template
  );
};
var readTemplate = async (template) => {
  const path2 = await getTemplatePath(template);
  return readFile(path2, "utf8");
};
var renderHTML = async (template, title, customHead, cssFiles, jsFiles, features, refs, logLevel, docsOptions, { versionCheck, releaseNotesData, docsMode, previewUrl, serverChannelUrl }) => {
  const customHeadRef = await customHead;
  const titleRef = await title;
  const templateRef = await template;
  return render(templateRef, {
    title: titleRef ? `${titleRef} - Storybook` : "Storybook",
    files: { js: jsFiles, css: cssFiles },
    globals: {
      FEATURES: JSON.stringify(await features, null, 2),
      REFS: JSON.stringify(await refs, null, 2),
      LOGLEVEL: JSON.stringify(await logLevel, null, 2),
      DOCS_OPTIONS: JSON.stringify(await docsOptions, null, 2),
      VERSIONCHECK: JSON.stringify(JSON.stringify(versionCheck), null, 2),
      RELEASE_NOTES_DATA: JSON.stringify(JSON.stringify(releaseNotesData), null, 2),
      PREVIEW_URL: JSON.stringify(previewUrl, null, 2),
      SERVER_CHANNEL_URL: JSON.stringify(serverChannelUrl, null, 2)
    },
    head: customHeadRef ? await readFile(customHeadRef, "utf8") : ""
  });
};

// src/utils/globals.ts
import { definitions } from "@storybook/ui/dist/globals";

// src/utils/data.ts
import { join as join2 } from "path";
import { getRefs } from "@storybook/core-common";

// src/utils/safeResolve.ts
var safeResolve = (path2) => {
  try {
    return Promise.resolve(__require.resolve(path2));
  } catch (e) {
    return Promise.resolve(false);
  }
};

// src/utils/data.ts
var getData = async (options) => {
  const refs = getRefs(options);
  const features = options.presets.apply("features");
  const logLevel = options.presets.apply("logLevel");
  const title = options.presets.apply("title");
  const docsOptions = options.presets.apply("docs", {});
  const template = readTemplate("template.ejs");
  const customHead = safeResolve(join2(options.configDir, "manager-head.html"));
  const [instance, config] = await Promise.all([
    executor.get(),
    getConfig(options)
  ]);
  return {
    refs,
    features,
    title,
    docsOptions,
    template,
    customHead,
    instance,
    config,
    logLevel
  };
};

// src/utils/files.ts
import { writeFile, ensureFile } from "fs-extra";
async function readOrderedFiles(addonsDir) {
  const files = await Promise.all(
    compilation?.outputFiles?.map(async (file) => {
      await ensureFile(file.path).then(() => writeFile(file.path, file.contents));
      return file.path.replace(addonsDir, "./sb-addons");
    }) || []
  );
  const jsFiles = files.filter((file) => file.endsWith(".mjs"));
  const cssFiles = files.filter((file) => file.endsWith(".css"));
  return { cssFiles, jsFiles };
}

// src/index.ts
var compilation;
var asyncIterator;
var getConfig = async (options) => {
  const [addonsEntryPoints, customManagerEntryPoint, tsconfigPath] = await Promise.all([
    options.presets.apply("managerEntries", []),
    safeResolve(join3(options.configDir, "manager")),
    getTemplatePath("addon.tsconfig.json")
  ]);
  return {
    entryPoints: customManagerEntryPoint ? [...addonsEntryPoints, customManagerEntryPoint] : addonsEntryPoints,
    outdir: join3(options.outputDir || "./", "sb-addons"),
    format: "esm",
    write: false,
    outExtension: { ".js": ".mjs" },
    loader: {
      ".js": "jsx",
      ".png": "dataurl",
      ".gif": "dataurl",
      ".jpg": "dataurl",
      ".jpeg": "dataurl",
      ".svg": "dataurl",
      ".webp": "dataurl",
      ".webm": "dataurl"
    },
    target: ["chrome100"],
    platform: "browser",
    bundle: true,
    minify: false,
    sourcemap: true,
    jsxFactory: "React.createElement",
    jsxFragment: "React.Fragment",
    jsx: "transform",
    jsxImportSource: "react",
    tsconfig: tsconfigPath,
    legalComments: "external",
    plugins: [
      aliasPlugin({
        process: __require.resolve("process/browser.js"),
        util: __require.resolve("util/util.js"),
        assert: __require.resolve("browser-assert")
      }),
      globalExternals(definitions),
      pnpPlugin()
    ],
    define: {
      "process.env.NODE_ENV": "'production'",
      "process.env": "{}",
      global: "window",
      module: "{}"
    }
  };
};
var executor = {
  get: async () => {
    const { build: build2 } = await import("esbuild");
    return build2;
  }
};
var starter = async function* starterGeneratorFn({
  startTime,
  options,
  router
}) {
  logger.info("=> Starting manager..");
  const { config, customHead, features, instance, refs, template, title, logLevel, docsOptions } = await getData(options);
  yield;
  const addonsDir = config.outdir;
  await remove(addonsDir);
  yield;
  compilation = await instance({
    ...config,
    watch: true
  });
  yield;
  const coreDirOrigin = join3(dirname2(__require.resolve("@storybook/ui/package.json")), "dist");
  router.use(`/sb-addons`, express.static(addonsDir));
  router.use(`/sb-manager`, express.static(coreDirOrigin));
  const { cssFiles, jsFiles } = await readOrderedFiles(addonsDir);
  yield;
  const html = await renderHTML(
    template,
    title,
    customHead,
    cssFiles,
    jsFiles,
    features,
    refs,
    logLevel,
    docsOptions,
    options
  );
  yield;
  router.use(`/`, ({ path: path2 }, res, next) => {
    if (path2 === "/") {
      res.status(200).send(html);
    } else {
      next();
    }
  });
  return {
    bail,
    stats: {
      toJson: () => ({})
    },
    totalTime: process.hrtime(startTime)
  };
};
var builder = async function* builderGeneratorFn({ startTime, options }) {
  if (!options.outputDir) {
    throw new Error("outputDir is required");
  }
  logger.info("=> Building manager..");
  const { config, customHead, features, instance, refs, template, title, logLevel, docsOptions } = await getData(options);
  yield;
  const addonsDir = config.outdir;
  const coreDirOrigin = join3(dirname2(__require.resolve("@storybook/ui/package.json")), "dist");
  const coreDirTarget = join3(options.outputDir, `sb-manager`);
  compilation = await instance({
    ...config,
    minify: true,
    watch: false
  });
  yield;
  const managerFiles = copy(coreDirOrigin, coreDirTarget);
  const { cssFiles, jsFiles } = await readOrderedFiles(addonsDir);
  yield;
  const html = await renderHTML(
    template,
    title,
    customHead,
    cssFiles,
    jsFiles,
    features,
    refs,
    logLevel,
    docsOptions,
    options
  );
  await Promise.all([
    writeFile2(join3(options.outputDir, "index.html"), html),
    managerFiles
  ]);
  logger.trace({ message: "=> Manager built", time: process.hrtime(startTime) });
  return {
    toJson: () => ({})
  };
};
var bail = async () => {
  if (asyncIterator) {
    try {
      await asyncIterator.throw(new Error());
    } catch (e) {
    }
  }
  if (compilation && compilation.stop) {
    try {
      compilation.stop();
      logger.warn("Force closed manager build");
    } catch (err) {
      logger.warn("Unable to close manager build!");
    }
  }
};
var start = async (options) => {
  asyncIterator = starter(options);
  let result;
  do {
    result = await asyncIterator.next();
  } while (!result.done);
  return result.value;
};
var build = async (options) => {
  asyncIterator = builder(options);
  let result;
  do {
    result = await asyncIterator.next();
  } while (!result.done);
  return result.value;
};
var corePresets = [];
var overridePresets = [];
export {
  bail,
  build,
  compilation,
  corePresets,
  executor,
  getConfig,
  overridePresets,
  start
};
