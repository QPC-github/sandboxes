// src/render.tsx
import global from "global";
import React, {
  Component as ReactComponent,
  StrictMode,
  Fragment,
  useLayoutEffect,
  useRef
} from "react";
import ReactDOM, { version as reactDomVersion } from "react-dom";
var { FRAMEWORK_OPTIONS } = global;
var nodes = /* @__PURE__ */ new Map();
var render = (args, context) => {
  const { id, component: Component } = context;
  if (!Component) {
    throw new Error(
      `Unable to render story ${id} as the component annotation is missing from the default export`
    );
  }
  return /* @__PURE__ */ React.createElement(Component, {
    ...args
  });
};
var WithCallback = ({
  callback,
  children
}) => {
  const once = useRef();
  useLayoutEffect(() => {
    if (once.current === callback)
      return;
    once.current = callback;
    callback();
  }, [callback]);
  return children;
};
var renderElement = async (node, el) => {
  const root = await getReactRoot(el);
  return new Promise((resolve) => {
    if (root) {
      root.render(/* @__PURE__ */ React.createElement(WithCallback, {
        callback: () => resolve(null)
      }, node));
    } else {
      ReactDOM.render(node, el, () => resolve(null));
    }
  });
};
var canUseNewReactRootApi = reactDomVersion && (reactDomVersion.startsWith("18") || reactDomVersion.startsWith("0.0.0"));
var shouldUseNewRootApi = FRAMEWORK_OPTIONS?.legacyRootApi !== true;
var isUsingNewReactRootApi = shouldUseNewRootApi && canUseNewReactRootApi;
var unmountElement = (el) => {
  const root = nodes.get(el);
  if (root && isUsingNewReactRootApi) {
    root.unmount();
    nodes.delete(el);
  } else {
    ReactDOM.unmountComponentAtNode(el);
  }
};
var getReactRoot = async (el) => {
  if (!isUsingNewReactRootApi) {
    return null;
  }
  let root = nodes.get(el);
  if (!root) {
    const reactDomClient = (await import("react-dom/client")).default;
    root = reactDomClient.createRoot(el);
    nodes.set(el, root);
  }
  return root;
};
var ErrorBoundary = class extends ReactComponent {
  constructor() {
    super(...arguments);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  componentDidMount() {
    const { hasError } = this.state;
    const { showMain } = this.props;
    if (!hasError) {
      showMain();
    }
  }
  componentDidCatch(err) {
    const { showException } = this.props;
    showException(err);
  }
  render() {
    const { hasError } = this.state;
    const { children } = this.props;
    return hasError ? null : children;
  }
};
var Wrapper = FRAMEWORK_OPTIONS?.strictMode ? StrictMode : Fragment;
async function renderToDOM({
  storyContext,
  unboundStoryFn,
  showMain,
  showException,
  forceRemount
}, domElement) {
  const Story = unboundStoryFn;
  const content = /* @__PURE__ */ React.createElement(ErrorBoundary, {
    showMain,
    showException
  }, /* @__PURE__ */ React.createElement(Story, {
    ...storyContext
  }));
  const element = Wrapper ? /* @__PURE__ */ React.createElement(Wrapper, null, content) : content;
  if (forceRemount) {
    unmountElement(domElement);
  }
  await renderElement(element, domElement);
  return () => unmountElement(domElement);
}

export {
  render,
  renderToDOM
};
