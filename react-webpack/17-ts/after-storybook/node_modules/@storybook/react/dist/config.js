"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/config.ts
var config_exports = {};
__export(config_exports, {
  argTypesEnhancers: () => argTypesEnhancers,
  decorators: () => decorators,
  parameters: () => parameters2,
  render: () => render,
  renderToDOM: () => renderToDOM
});
module.exports = __toCommonJS(config_exports);

// src/docs/config.ts
var import_docs_tools9 = require("@storybook/docs-tools");

// src/docs/extractProps.ts
var import_prop_types = __toESM(require("prop-types"));
var import_docs_tools7 = require("@storybook/docs-tools");

// src/docs/propTypes/createType.ts
var import_docs_tools = require("@storybook/docs-tools");

// src/docs/propTypes/generateFuncSignature.ts
function generateFuncSignature(params, returns) {
  const hasParams = params != null;
  const hasReturns = returns != null;
  if (!hasParams && !hasReturns) {
    return "";
  }
  const funcParts = [];
  if (hasParams) {
    const funcParams = params.map((x) => {
      const prettyName = x.getPrettyName();
      const typeName = x.getTypeName();
      if (typeName != null) {
        return `${prettyName}: ${typeName}`;
      }
      return prettyName;
    });
    funcParts.push(`(${funcParams.join(", ")})`);
  } else {
    funcParts.push("()");
  }
  if (hasReturns) {
    funcParts.push(`=> ${returns.getTypeName()}`);
  }
  return funcParts.join(" ");
}
function generateShortFuncSignature(params, returns) {
  const hasParams = params != null;
  const hasReturns = returns != null;
  if (!hasParams && !hasReturns) {
    return "";
  }
  const funcParts = [];
  if (hasParams) {
    funcParts.push("( ... )");
  } else {
    funcParts.push("()");
  }
  if (hasReturns) {
    funcParts.push(`=> ${returns.getTypeName()}`);
  }
  return funcParts.join(" ");
}
function toMultilineSignature(signature) {
  return signature.replace(/,/g, ",\r\n");
}

// src/docs/lib/captions.ts
var CUSTOM_CAPTION = "custom";
var OBJECT_CAPTION = "object";
var ARRAY_CAPTION = "array";
var CLASS_CAPTION = "class";
var FUNCTION_CAPTION = "func";
var ELEMENT_CAPTION = "element";

// src/docs/lib/isHtmlTag.ts
var import_html_tags = __toESM(require("html-tags"));
function isHtmlTag(tagName) {
  return import_html_tags.default.includes(tagName.toLowerCase());
}

// src/docs/lib/generateCode.ts
var import_escodegen = require("escodegen");
var import_ts_dedent = require("ts-dedent");
var BASIC_OPTIONS = {
  format: {
    indent: {
      style: "  "
    },
    semicolons: false
  }
};
var COMPACT_OPTIONS = {
  ...BASIC_OPTIONS,
  format: {
    newline: ""
  }
};
var PRETTY_OPTIONS = {
  ...BASIC_OPTIONS
};
function generateCode(ast, compact = false) {
  return (0, import_escodegen.generate)(ast, compact ? COMPACT_OPTIONS : PRETTY_OPTIONS);
}
function generateObjectCode(ast, compact = false) {
  return !compact ? generateCode(ast) : generateCompactObjectCode(ast);
}
function generateCompactObjectCode(ast) {
  let result = generateCode(ast, true);
  if (!result.endsWith(" }")) {
    result = `${result.slice(0, -1)} }`;
  }
  return result;
}
function generateArrayCode(ast, compact = false) {
  return !compact ? generateMultilineArrayCode(ast) : generateCompactArrayCode(ast);
}
function generateMultilineArrayCode(ast) {
  let result = generateCode(ast);
  if (result.endsWith("  }]")) {
    result = (0, import_ts_dedent.dedent)(result);
  }
  return result;
}
function generateCompactArrayCode(ast) {
  let result = generateCode(ast, true);
  if (result.startsWith("[    ")) {
    result = result.replace("[    ", "[");
  }
  return result;
}

// src/docs/lib/componentTypes.ts
var isMemo = (component) => component.$$typeof === Symbol.for("react.memo");
var isForwardRef = (component) => component.$$typeof === Symbol.for("react.forward_ref");

// src/docs/lib/inspection/acornParser.ts
var import_acorn = require("acorn");
var import_acorn_jsx = __toESM(require("acorn-jsx"));
var acornWalk = __toESM(require("acorn-walk"));
var ACORN_WALK_VISITORS = {
  ...acornWalk.base,
  JSXElement: () => {
  }
};
var acornParser = import_acorn.Parser.extend((0, import_acorn_jsx.default)());
function extractIdentifierName(identifierNode) {
  return identifierNode != null ? identifierNode.name : null;
}
function filterAncestors(ancestors) {
  return ancestors.filter((x) => x.type === "ObjectExpression" || x.type === "ArrayExpression");
}
function calculateNodeDepth(node) {
  const depths = [];
  acornWalk.ancestor(
    node,
    {
      ObjectExpression(_, ancestors) {
        depths.push(filterAncestors(ancestors).length);
      },
      ArrayExpression(_, ancestors) {
        depths.push(filterAncestors(ancestors).length);
      }
    },
    ACORN_WALK_VISITORS
  );
  return Math.max(...depths);
}
function parseIdentifier(identifierNode) {
  return {
    inferredType: {
      type: "Identifier" /* IDENTIFIER */,
      identifier: extractIdentifierName(identifierNode)
    },
    ast: identifierNode
  };
}
function parseLiteral(literalNode) {
  return {
    inferredType: { type: "Literal" /* LITERAL */ },
    ast: literalNode
  };
}
function parseFunction(funcNode) {
  let innerJsxElementNode;
  acornWalk.simple(
    funcNode.body,
    {
      JSXElement(node) {
        innerJsxElementNode = node;
      }
    },
    ACORN_WALK_VISITORS
  );
  const isJsx = innerJsxElementNode != null;
  const inferredType = {
    type: isJsx ? "Element" /* ELEMENT */ : "Function" /* FUNCTION */,
    params: funcNode.params,
    hasParams: funcNode.params.length !== 0
  };
  const identifierName = extractIdentifierName(funcNode.id);
  if (identifierName != null) {
    inferredType.identifier = identifierName;
  }
  return {
    inferredType,
    ast: funcNode
  };
}
function parseClass(classNode) {
  let innerJsxElementNode;
  acornWalk.simple(
    classNode.body,
    {
      JSXElement(node) {
        innerJsxElementNode = node;
      }
    },
    ACORN_WALK_VISITORS
  );
  const inferredType = {
    type: innerJsxElementNode != null ? "Element" /* ELEMENT */ : "Class" /* CLASS */,
    identifier: extractIdentifierName(classNode.id)
  };
  return {
    inferredType,
    ast: classNode
  };
}
function parseJsxElement(jsxElementNode) {
  const inferredType = {
    type: "Element" /* ELEMENT */
  };
  const identifierName = extractIdentifierName(jsxElementNode.openingElement.name);
  if (identifierName != null) {
    inferredType.identifier = identifierName;
  }
  return {
    inferredType,
    ast: jsxElementNode
  };
}
function parseCall(callNode) {
  const identifierNode = callNode.callee.type === "MemberExpression" ? callNode.callee.property : callNode.callee;
  const identifierName = extractIdentifierName(identifierNode);
  if (identifierName === "shape") {
    return parseObject(callNode.arguments[0]);
  }
  return null;
}
function parseObject(objectNode) {
  return {
    inferredType: { type: "Object" /* OBJECT */, depth: calculateNodeDepth(objectNode) },
    ast: objectNode
  };
}
function parseArray(arrayNode) {
  return {
    inferredType: { type: "Array" /* ARRAY */, depth: calculateNodeDepth(arrayNode) },
    ast: arrayNode
  };
}
function parseExpression(expression) {
  switch (expression.type) {
    case "Identifier":
      return parseIdentifier(expression);
    case "Literal":
      return parseLiteral(expression);
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      return parseFunction(expression);
    case "ClassExpression":
      return parseClass(expression);
    case "JSXElement":
      return parseJsxElement(expression);
    case "CallExpression":
      return parseCall(expression);
    case "ObjectExpression":
      return parseObject(expression);
    case "ArrayExpression":
      return parseArray(expression);
    default:
      return null;
  }
}
function parse(value) {
  const ast = acornParser.parse(`(${value})`);
  let parsingResult = {
    inferredType: { type: "Unknown" /* UNKNOWN */ },
    ast
  };
  if (ast.body[0] != null) {
    const rootNode = ast.body[0];
    switch (rootNode.type) {
      case "ExpressionStatement": {
        const expressionResult = parseExpression(rootNode.expression);
        if (expressionResult != null) {
          parsingResult = expressionResult;
        }
        break;
      }
      default:
        break;
    }
  }
  return parsingResult;
}

// src/docs/lib/inspection/inspectValue.ts
function inspectValue(value) {
  try {
    const parsingResult = parse(value);
    return { ...parsingResult };
  } catch (e) {
  }
  return { inferredType: { type: "Unknown" /* UNKNOWN */ } };
}

// src/docs/propTypes/createType.ts
var MAX_FUNC_LENGTH = 150;
function createTypeDef({
  name,
  short,
  compact,
  full,
  inferredType
}) {
  return {
    name,
    short,
    compact,
    full: full != null ? full : short,
    inferredType
  };
}
function cleanPropTypes(value) {
  return value.replace(/PropTypes./g, "").replace(/.isRequired/g, "");
}
function splitIntoLines(value) {
  return value.split(/\r?\n/);
}
function prettyObject(ast, compact = false) {
  return cleanPropTypes(generateObjectCode(ast, compact));
}
function prettyArray(ast, compact = false) {
  return cleanPropTypes(generateCode(ast, compact));
}
function getCaptionForInspectionType(type) {
  switch (type) {
    case "Object" /* OBJECT */:
      return OBJECT_CAPTION;
    case "Array" /* ARRAY */:
      return ARRAY_CAPTION;
    case "Class" /* CLASS */:
      return CLASS_CAPTION;
    case "Function" /* FUNCTION */:
      return FUNCTION_CAPTION;
    case "Element" /* ELEMENT */:
      return ELEMENT_CAPTION;
    default:
      return CUSTOM_CAPTION;
  }
}
function generateTypeFromString(value, originalTypeName) {
  const { inferredType, ast } = inspectValue(value);
  const { type } = inferredType;
  let short;
  let compact;
  let full;
  switch (type) {
    case "Identifier" /* IDENTIFIER */:
    case "Literal" /* LITERAL */:
      short = value;
      compact = value;
      break;
    case "Object" /* OBJECT */: {
      const { depth } = inferredType;
      short = OBJECT_CAPTION;
      compact = depth === 1 ? prettyObject(ast, true) : null;
      full = prettyObject(ast);
      break;
    }
    case "Element" /* ELEMENT */: {
      const { identifier } = inferredType;
      short = identifier != null && !isHtmlTag(identifier) ? identifier : ELEMENT_CAPTION;
      compact = splitIntoLines(value).length === 1 ? value : null;
      full = value;
      break;
    }
    case "Array" /* ARRAY */: {
      const { depth } = inferredType;
      short = ARRAY_CAPTION;
      compact = depth <= 2 ? prettyArray(ast, true) : null;
      full = prettyArray(ast);
      break;
    }
    default:
      short = getCaptionForInspectionType(type);
      compact = splitIntoLines(value).length === 1 ? value : null;
      full = value;
      break;
  }
  return createTypeDef({
    name: originalTypeName,
    short,
    compact,
    full,
    inferredType: type
  });
}
function generateCustom({ raw }) {
  if (raw != null) {
    return generateTypeFromString(raw, "custom" /* CUSTOM */);
  }
  return createTypeDef({
    name: "custom" /* CUSTOM */,
    short: CUSTOM_CAPTION,
    compact: CUSTOM_CAPTION
  });
}
function generateFunc(extractedProp) {
  const { jsDocTags } = extractedProp;
  if (jsDocTags != null) {
    if (jsDocTags.params != null || jsDocTags.returns != null) {
      return createTypeDef({
        name: "func" /* FUNC */,
        short: generateShortFuncSignature(jsDocTags.params, jsDocTags.returns),
        compact: null,
        full: generateFuncSignature(jsDocTags.params, jsDocTags.returns)
      });
    }
  }
  return createTypeDef({
    name: "func" /* FUNC */,
    short: FUNCTION_CAPTION,
    compact: FUNCTION_CAPTION
  });
}
function generateShape(type, extractedProp) {
  const fields = Object.keys(type.value).map((key) => `${key}: ${generateType(type.value[key], extractedProp).full}`).join(", ");
  const { inferredType, ast } = inspectValue(`{ ${fields} }`);
  const { depth } = inferredType;
  return createTypeDef({
    name: "shape" /* SHAPE */,
    short: OBJECT_CAPTION,
    compact: depth === 1 && ast ? prettyObject(ast, true) : null,
    full: ast ? prettyObject(ast) : null
  });
}
function objectOf(of) {
  return `objectOf(${of})`;
}
function generateObjectOf(type, extractedProp) {
  const { short, compact, full } = generateType(type.value, extractedProp);
  return createTypeDef({
    name: "objectOf" /* OBJECTOF */,
    short: objectOf(short),
    compact: compact != null ? objectOf(compact) : null,
    full: full ? objectOf(full) : full
  });
}
function generateUnion(type, extractedProp) {
  if (Array.isArray(type.value)) {
    const values = type.value.reduce(
      (acc, v) => {
        const { short, compact, full } = generateType(v, extractedProp);
        acc.short.push(short);
        acc.compact.push(compact);
        acc.full.push(full);
        return acc;
      },
      { short: [], compact: [], full: [] }
    );
    return createTypeDef({
      name: "union" /* UNION */,
      short: values.short.join(" | "),
      compact: values.compact.every((x) => x != null) ? values.compact.join(" | ") : null,
      full: values.full.join(" | ")
    });
  }
  return createTypeDef({ name: "union" /* UNION */, short: type.value, compact: null });
}
function generateEnumValue({ value, computed }) {
  return computed ? generateTypeFromString(value, "enumvalue") : createTypeDef({ name: "enumvalue", short: value, compact: value });
}
function generateEnum(type) {
  if (Array.isArray(type.value)) {
    const values = type.value.reduce(
      (acc, v) => {
        const { short, compact, full } = generateEnumValue(v);
        acc.short.push(short);
        acc.compact.push(compact);
        acc.full.push(full);
        return acc;
      },
      { short: [], compact: [], full: [] }
    );
    return createTypeDef({
      name: "enum" /* ENUM */,
      short: values.short.join(" | "),
      compact: values.compact.every((x) => x != null) ? values.compact.join(" | ") : null,
      full: values.full.join(" | ")
    });
  }
  return createTypeDef({ name: "enum" /* ENUM */, short: type.value, compact: type.value });
}
function braceAfter(of) {
  return `${of}[]`;
}
function braceAround(of) {
  return `[${of}]`;
}
function createArrayOfObjectTypeDef(short, compact, full) {
  return createTypeDef({
    name: "arrayOf" /* ARRAYOF */,
    short: braceAfter(short),
    compact: compact != null ? braceAround(compact) : null,
    full: full ? braceAround(full) : full
  });
}
function generateArray(type, extractedProp) {
  const { name, short, compact, full, inferredType } = generateType(type.value, extractedProp);
  if (name === "custom" /* CUSTOM */) {
    if (inferredType === "Object" /* OBJECT */) {
      return createArrayOfObjectTypeDef(short, compact, full);
    }
  } else if (name === "shape" /* SHAPE */) {
    return createArrayOfObjectTypeDef(short, compact, full);
  }
  return createTypeDef({
    name: "arrayOf" /* ARRAYOF */,
    short: braceAfter(short),
    compact: braceAfter(short)
  });
}
function generateType(type, extractedProp) {
  try {
    switch (type.name) {
      case "custom" /* CUSTOM */:
        return generateCustom(type);
      case "func" /* FUNC */:
        return generateFunc(extractedProp);
      case "shape" /* SHAPE */:
        return generateShape(type, extractedProp);
      case "instanceOf" /* INSTANCEOF */:
        return createTypeDef({
          name: "instanceOf" /* INSTANCEOF */,
          short: type.value,
          compact: type.value
        });
      case "objectOf" /* OBJECTOF */:
        return generateObjectOf(type, extractedProp);
      case "union" /* UNION */:
        return generateUnion(type, extractedProp);
      case "enum" /* ENUM */:
        return generateEnum(type);
      case "arrayOf" /* ARRAYOF */:
        return generateArray(type, extractedProp);
      default:
        return createTypeDef({ name: type.name, short: type.name, compact: type.name });
    }
  } catch (e) {
    console.error(e);
  }
  return createTypeDef({ name: "unknown", short: "unknown", compact: "unknown" });
}
function createType(extractedProp) {
  const { type } = extractedProp.docgenInfo;
  if (type == null) {
    return null;
  }
  try {
    switch (type.name) {
      case "custom" /* CUSTOM */:
      case "shape" /* SHAPE */:
      case "instanceOf" /* INSTANCEOF */:
      case "objectOf" /* OBJECTOF */:
      case "union" /* UNION */:
      case "enum" /* ENUM */:
      case "arrayOf" /* ARRAYOF */: {
        const { short, compact, full } = generateType(type, extractedProp);
        if (compact != null) {
          if (!(0, import_docs_tools.isTooLongForTypeSummary)(compact)) {
            return (0, import_docs_tools.createSummaryValue)(compact);
          }
        }
        return full ? (0, import_docs_tools.createSummaryValue)(short, full) : (0, import_docs_tools.createSummaryValue)(short);
      }
      case "func" /* FUNC */: {
        const { short, full } = generateType(type, extractedProp);
        let summary = short;
        let detail;
        if (full && full.length < MAX_FUNC_LENGTH) {
          summary = full;
        } else if (full) {
          detail = toMultilineSignature(full);
        }
        return (0, import_docs_tools.createSummaryValue)(summary, detail);
      }
      default:
        return null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
}

// src/docs/lib/defaultValues/createDefaultValue.ts
var import_docs_tools4 = require("@storybook/docs-tools");

// src/docs/lib/defaultValues/generateObject.ts
var import_docs_tools2 = require("@storybook/docs-tools");
function generateObject({ inferredType, ast }) {
  const { depth } = inferredType;
  if (depth === 1) {
    const compactObject = generateObjectCode(ast, true);
    if (!(0, import_docs_tools2.isTooLongForDefaultValueSummary)(compactObject)) {
      return (0, import_docs_tools2.createSummaryValue)(compactObject);
    }
  }
  return (0, import_docs_tools2.createSummaryValue)(OBJECT_CAPTION, generateObjectCode(ast));
}

// src/docs/lib/defaultValues/generateArray.ts
var import_docs_tools3 = require("@storybook/docs-tools");
function generateArray2({ inferredType, ast }) {
  const { depth } = inferredType;
  if (depth <= 2) {
    const compactArray = generateArrayCode(ast, true);
    if (!(0, import_docs_tools3.isTooLongForDefaultValueSummary)(compactArray)) {
      return (0, import_docs_tools3.createSummaryValue)(compactArray);
    }
  }
  return (0, import_docs_tools3.createSummaryValue)(ARRAY_CAPTION, generateArrayCode(ast));
}

// src/docs/lib/defaultValues/prettyIdentifier.ts
function getPrettyFuncIdentifier(identifier, hasArguments) {
  return hasArguments ? `${identifier}( ... )` : `${identifier}()`;
}
function getPrettyElementIdentifier(identifier) {
  return `<${identifier} />`;
}
function getPrettyIdentifier(inferredType) {
  const { type, identifier } = inferredType;
  switch (type) {
    case "Function" /* FUNCTION */:
      return getPrettyFuncIdentifier(identifier, inferredType.hasParams);
    case "Element" /* ELEMENT */:
      return getPrettyElementIdentifier(identifier);
    default:
      return identifier;
  }
}

// src/docs/lib/defaultValues/createDefaultValue.ts
function generateFunc2({ inferredType, ast }) {
  const { identifier } = inferredType;
  if (identifier != null) {
    return (0, import_docs_tools4.createSummaryValue)(
      getPrettyIdentifier(inferredType),
      generateCode(ast)
    );
  }
  const prettyCaption = generateCode(ast, true);
  return !(0, import_docs_tools4.isTooLongForDefaultValueSummary)(prettyCaption) ? (0, import_docs_tools4.createSummaryValue)(prettyCaption) : (0, import_docs_tools4.createSummaryValue)(FUNCTION_CAPTION, generateCode(ast));
}
function generateElement(defaultValue, inspectionResult) {
  const { inferredType } = inspectionResult;
  const { identifier } = inferredType;
  if (identifier != null) {
    if (!isHtmlTag(identifier)) {
      const prettyIdentifier = getPrettyIdentifier(
        inferredType
      );
      return (0, import_docs_tools4.createSummaryValue)(prettyIdentifier, defaultValue);
    }
  }
  return !(0, import_docs_tools4.isTooLongForDefaultValueSummary)(defaultValue) ? (0, import_docs_tools4.createSummaryValue)(defaultValue) : (0, import_docs_tools4.createSummaryValue)(ELEMENT_CAPTION, defaultValue);
}
function createDefaultValue(defaultValue) {
  try {
    const inspectionResult = inspectValue(defaultValue);
    switch (inspectionResult.inferredType.type) {
      case "Object" /* OBJECT */:
        return generateObject(inspectionResult);
      case "Function" /* FUNCTION */:
        return generateFunc2(inspectionResult);
      case "Element" /* ELEMENT */:
        return generateElement(defaultValue, inspectionResult);
      case "Array" /* ARRAY */:
        return generateArray2(inspectionResult);
      default:
        return null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
}

// src/docs/lib/defaultValues/createFromRawDefaultProp.ts
var import_isPlainObject = __toESM(require("lodash/isPlainObject"));
var import_isFunction = __toESM(require("lodash/isFunction"));
var import_isString = __toESM(require("lodash/isString"));
var import_react_element_to_jsx_string = __toESM(require("react-element-to-jsx-string"));
var import_docs_tools5 = require("@storybook/docs-tools");
function isReactElement(element) {
  return element.$$typeof != null;
}
function extractFunctionName(func, propName) {
  const { name } = func;
  if (name !== "" && name !== "anonymous" && name !== propName) {
    return name;
  }
  return null;
}
var stringResolver = (rawDefaultProp) => {
  return (0, import_docs_tools5.createSummaryValue)(JSON.stringify(rawDefaultProp));
};
function generateReactObject(rawDefaultProp) {
  const { type } = rawDefaultProp;
  const { displayName } = type;
  const jsx2 = (0, import_react_element_to_jsx_string.default)(rawDefaultProp, {});
  if (displayName != null) {
    const prettyIdentifier = getPrettyElementIdentifier(displayName);
    return (0, import_docs_tools5.createSummaryValue)(prettyIdentifier, jsx2);
  }
  if ((0, import_isString.default)(type)) {
    if (isHtmlTag(type)) {
      const jsxCompact = (0, import_react_element_to_jsx_string.default)(rawDefaultProp, { tabStop: 0 });
      const jsxSummary = jsxCompact.replace(/\r?\n|\r/g, "");
      if (!(0, import_docs_tools5.isTooLongForDefaultValueSummary)(jsxSummary)) {
        return (0, import_docs_tools5.createSummaryValue)(jsxSummary);
      }
    }
  }
  return (0, import_docs_tools5.createSummaryValue)(ELEMENT_CAPTION, jsx2);
}
var objectResolver = (rawDefaultProp) => {
  if (isReactElement(rawDefaultProp) && rawDefaultProp.type != null) {
    return generateReactObject(rawDefaultProp);
  }
  if ((0, import_isPlainObject.default)(rawDefaultProp)) {
    const inspectionResult = inspectValue(JSON.stringify(rawDefaultProp));
    return generateObject(inspectionResult);
  }
  if (Array.isArray(rawDefaultProp)) {
    const inspectionResult = inspectValue(JSON.stringify(rawDefaultProp));
    return generateArray2(inspectionResult);
  }
  return (0, import_docs_tools5.createSummaryValue)(OBJECT_CAPTION);
};
var functionResolver = (rawDefaultProp, propDef) => {
  let isElement = false;
  let inspectionResult;
  if ((0, import_isFunction.default)(rawDefaultProp.render)) {
    isElement = true;
  } else if (rawDefaultProp.prototype != null && (0, import_isFunction.default)(rawDefaultProp.prototype.render)) {
    isElement = true;
  } else {
    let innerElement;
    try {
      inspectionResult = inspectValue(rawDefaultProp.toString());
      const { hasParams, params } = inspectionResult.inferredType;
      if (hasParams) {
        if (params.length === 1 && params[0].type === "ObjectPattern") {
          innerElement = rawDefaultProp({});
        }
      } else {
        innerElement = rawDefaultProp();
      }
      if (innerElement != null) {
        if (isReactElement(innerElement)) {
          isElement = true;
        }
      }
    } catch (e) {
    }
  }
  const funcName = extractFunctionName(rawDefaultProp, propDef.name);
  if (funcName != null) {
    if (isElement) {
      return (0, import_docs_tools5.createSummaryValue)(getPrettyElementIdentifier(funcName));
    }
    if (inspectionResult != null) {
      inspectionResult = inspectValue(rawDefaultProp.toString());
    }
    const { hasParams } = inspectionResult.inferredType;
    return (0, import_docs_tools5.createSummaryValue)(getPrettyFuncIdentifier(funcName, hasParams));
  }
  return (0, import_docs_tools5.createSummaryValue)(isElement ? ELEMENT_CAPTION : FUNCTION_CAPTION);
};
var defaultResolver = (rawDefaultProp) => {
  return (0, import_docs_tools5.createSummaryValue)(rawDefaultProp.toString());
};
var DEFAULT_TYPE_RESOLVERS = {
  string: stringResolver,
  object: objectResolver,
  function: functionResolver,
  default: defaultResolver
};
function createTypeResolvers(customResolvers = {}) {
  return {
    ...DEFAULT_TYPE_RESOLVERS,
    ...customResolvers
  };
}
function createDefaultValueFromRawDefaultProp(rawDefaultProp, propDef, typeResolvers = DEFAULT_TYPE_RESOLVERS) {
  try {
    switch (typeof rawDefaultProp) {
      case "string":
        return typeResolvers.string(rawDefaultProp, propDef);
      case "object":
        return typeResolvers.object(rawDefaultProp, propDef);
      case "function": {
        return typeResolvers.function(rawDefaultProp, propDef);
      }
      default:
        return typeResolvers.default(rawDefaultProp, propDef);
    }
  } catch (e) {
    console.error(e);
  }
  return null;
}

// src/docs/propTypes/sortProps.ts
function keepOriginalDefinitionOrder(extractedProps, component) {
  const { propTypes } = component;
  if (propTypes != null) {
    return Object.keys(propTypes).map((x) => extractedProps.find((y) => y.name === x)).filter(Boolean);
  }
  return extractedProps;
}

// src/docs/propTypes/rawDefaultPropResolvers.ts
var import_docs_tools6 = require("@storybook/docs-tools");
var funcResolver = (rawDefaultProp, { name, type }) => {
  const isElement = type.summary === "element" || type.summary === "elementType";
  const funcName = extractFunctionName(rawDefaultProp, name);
  if (funcName != null) {
    if (isElement) {
      return (0, import_docs_tools6.createSummaryValue)(getPrettyElementIdentifier(funcName));
    }
    const { hasParams } = inspectValue(rawDefaultProp.toString()).inferredType;
    return (0, import_docs_tools6.createSummaryValue)(getPrettyFuncIdentifier(funcName, hasParams));
  }
  return (0, import_docs_tools6.createSummaryValue)(isElement ? ELEMENT_CAPTION : FUNCTION_CAPTION);
};
var rawDefaultPropTypeResolvers = createTypeResolvers({
  function: funcResolver
});

// src/docs/propTypes/handleProp.ts
function enhancePropTypesProp(extractedProp, rawDefaultProp) {
  const { propDef } = extractedProp;
  const newtype = createType(extractedProp);
  if (newtype != null) {
    propDef.type = newtype;
  }
  const { defaultValue } = extractedProp.docgenInfo;
  if (defaultValue != null && defaultValue.value != null) {
    const newDefaultValue = createDefaultValue(defaultValue.value);
    if (newDefaultValue != null) {
      propDef.defaultValue = newDefaultValue;
    }
  } else if (rawDefaultProp != null) {
    const newDefaultValue = createDefaultValueFromRawDefaultProp(
      rawDefaultProp,
      propDef,
      rawDefaultPropTypeResolvers
    );
    if (newDefaultValue != null) {
      propDef.defaultValue = newDefaultValue;
    }
  }
  return propDef;
}
function enhancePropTypesProps(extractedProps, component) {
  const rawDefaultProps = component.defaultProps != null ? component.defaultProps : {};
  const enhancedProps = extractedProps.map(
    (x) => enhancePropTypesProp(x, rawDefaultProps[x.propDef.name])
  );
  return keepOriginalDefinitionOrder(enhancedProps, component);
}

// src/docs/typeScript/handleProp.ts
function enhanceTypeScriptProp(extractedProp, rawDefaultProp) {
  const { propDef } = extractedProp;
  const { defaultValue } = extractedProp.docgenInfo;
  if (defaultValue != null && defaultValue.value != null) {
    const newDefaultValue = createDefaultValue(defaultValue.value);
    if (newDefaultValue != null) {
      propDef.defaultValue = newDefaultValue;
    }
  } else if (rawDefaultProp != null) {
    const newDefaultValue = createDefaultValueFromRawDefaultProp(rawDefaultProp, propDef);
    if (newDefaultValue != null) {
      propDef.defaultValue = newDefaultValue;
    }
  }
  return propDef;
}
function enhanceTypeScriptProps(extractedProps) {
  return extractedProps.map((prop) => enhanceTypeScriptProp(prop));
}

// src/docs/extractProps.ts
var propTypesMap = /* @__PURE__ */ new Map();
Object.keys(import_prop_types.default).forEach((typeName) => {
  const type = import_prop_types.default[typeName];
  propTypesMap.set(type, typeName);
  propTypesMap.set(type.isRequired, typeName);
});
function getPropDefs(component, section) {
  let processedComponent = component;
  if (!(0, import_docs_tools7.hasDocgen)(component) && !component.propTypes && isMemo(component)) {
    processedComponent = component.type;
  }
  const extractedProps = (0, import_docs_tools7.extractComponentProps)(processedComponent, section);
  if (extractedProps.length === 0) {
    return [];
  }
  switch (extractedProps[0].typeSystem) {
    case import_docs_tools7.TypeSystem.JAVASCRIPT:
      return enhancePropTypesProps(extractedProps, component);
    case import_docs_tools7.TypeSystem.TYPESCRIPT:
      return enhanceTypeScriptProps(extractedProps);
    default:
      return extractedProps.map((x) => x.propDef);
  }
}
var extractProps = (component) => ({
  rows: getPropDefs(component, "props")
});

// src/docs/extractArgTypes.ts
var extractArgTypes = (component) => {
  if (component) {
    const { rows } = extractProps(component);
    if (rows) {
      return rows.reduce((acc, row) => {
        const {
          name,
          description,
          type,
          sbType,
          defaultValue: defaultSummary,
          jsDocTags,
          required
        } = row;
        acc[name] = {
          name,
          description,
          type: { required, ...sbType },
          table: {
            type,
            jsDocTags,
            defaultValue: defaultSummary
          }
        };
        return acc;
      }, {});
    }
  }
  return null;
};

// src/docs/jsxDecorator.tsx
var import_react = __toESM(require("react"));
var import_react_element_to_jsx_string2 = __toESM(require("react-element-to-jsx-string"));
var import_ts_dedent2 = require("ts-dedent");
var import_util_deprecate = __toESM(require("util-deprecate"));
var import_addons = require("@storybook/addons");
var import_docs_tools8 = require("@storybook/docs-tools");
var import_client_logger = require("@storybook/client-logger");
var applyBeforeRender = (domString, options) => {
  if (typeof options.onBeforeRender !== "function") {
    return domString;
  }
  const deprecatedOnBeforeRender = (0, import_util_deprecate.default)(
    options.onBeforeRender,
    import_ts_dedent2.dedent`
      StoryFn.parameters.jsx.onBeforeRender was deprecated.
      Prefer StoryFn.parameters.jsx.transformSource instead.
      See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-onbeforerender for details.
    `
  );
  return deprecatedOnBeforeRender(domString);
};
var applyTransformSource = (domString, options, context) => {
  if (typeof options.transformSource !== "function") {
    return domString;
  }
  return options.transformSource(domString, context);
};
var renderJsx = (code, options) => {
  if (typeof code === "undefined") {
    import_client_logger.logger.warn("Too many skip or undefined component");
    return null;
  }
  let renderedJSX = code;
  const Type = renderedJSX.type;
  for (let i = 0; i < options.skip; i += 1) {
    if (typeof renderedJSX === "undefined") {
      import_client_logger.logger.warn("Cannot skip undefined element");
      return null;
    }
    if (import_react.default.Children.count(renderedJSX) > 1) {
      import_client_logger.logger.warn("Trying to skip an array of elements");
      return null;
    }
    if (typeof renderedJSX.props.children === "undefined") {
      import_client_logger.logger.warn("Not enough children to skip elements.");
      if (typeof renderedJSX.type === "function" && renderedJSX.type.name === "") {
        renderedJSX = /* @__PURE__ */ import_react.default.createElement(Type, {
          ...renderedJSX.props
        });
      }
    } else if (typeof renderedJSX.props.children === "function") {
      renderedJSX = renderedJSX.props.children();
    } else {
      renderedJSX = renderedJSX.props.children;
    }
  }
  const displayNameDefaults = typeof options.displayName === "string" ? { showFunctions: true, displayName: () => options.displayName } : {
    displayName: (el) => el.type.displayName || (0, import_docs_tools8.getDocgenSection)(el.type, "displayName") || (el.type.name !== "_default" ? el.type.name : null) || (typeof el.type === "function" ? "No Display Name" : null) || (isForwardRef(el.type) ? el.type.render.name : null) || (isMemo(el.type) ? el.type.type.name : null) || el.type
  };
  const filterDefaults = {
    filterProps: (value, key) => value !== void 0
  };
  const opts = {
    ...displayNameDefaults,
    ...filterDefaults,
    ...options
  };
  const result = import_react.default.Children.map(code, (c) => {
    const child = typeof c === "number" ? c.toString() : c;
    const toJSXString = typeof import_react_element_to_jsx_string2.default === "function" ? import_react_element_to_jsx_string2.default : import_react_element_to_jsx_string2.default.default;
    let string = applyBeforeRender(toJSXString(child, opts), options);
    if (string.indexOf("&quot;") > -1) {
      const matches = string.match(/\S+=\\"([^"]*)\\"/g);
      if (matches) {
        matches.forEach((match) => {
          string = string.replace(match, match.replace(/&quot;/g, "'"));
        });
      }
    }
    return string;
  }).join("\n");
  return result.replace(/function\s+noRefCheck\(\)\s+\{\}/, "() => {}");
};
var defaultOpts = {
  skip: 0,
  showFunctions: false,
  enableBeautify: true,
  showDefaultProps: false
};
var skipJsxRender = (context) => {
  var _a;
  const sourceParams = (_a = context == null ? void 0 : context.parameters.docs) == null ? void 0 : _a.source;
  const isArgsStory = context == null ? void 0 : context.parameters.__isArgsStory;
  if ((sourceParams == null ? void 0 : sourceParams.type) === import_docs_tools8.SourceType.DYNAMIC) {
    return false;
  }
  return !isArgsStory || (sourceParams == null ? void 0 : sourceParams.code) || (sourceParams == null ? void 0 : sourceParams.type) === import_docs_tools8.SourceType.CODE;
};
var isMdx = (node) => {
  var _a, _b;
  return ((_a = node.type) == null ? void 0 : _a.displayName) === "MDXCreateElement" && !!((_b = node.props) == null ? void 0 : _b.mdxType);
};
var mdxToJsx = (node) => {
  if (!isMdx(node))
    return node;
  const { mdxType, originalType, children, ...rest } = node.props;
  let jsxChildren = [];
  if (children) {
    const array = Array.isArray(children) ? children : [children];
    jsxChildren = array.map(mdxToJsx);
  }
  return (0, import_react.createElement)(originalType, rest, ...jsxChildren);
};
var jsxDecorator = (storyFn, context) => {
  var _a, _b;
  const channel = import_addons.addons.getChannel();
  const skip = skipJsxRender(context);
  let jsx2 = "";
  (0, import_addons.useEffect)(() => {
    if (!skip) {
      channel.emit(import_docs_tools8.SNIPPET_RENDERED, (context || {}).id, jsx2);
    }
  });
  const story = storyFn();
  if (skip) {
    return story;
  }
  const options = {
    ...defaultOpts,
    ...(context == null ? void 0 : context.parameters.jsx) || {}
  };
  const storyJsx = ((_b = (_a = context == null ? void 0 : context.parameters.docs) == null ? void 0 : _a.source) == null ? void 0 : _b.excludeDecorators) ? context.originalStoryFn(context.args, context) : story;
  const sourceJsx = mdxToJsx(storyJsx);
  const rendered = renderJsx(sourceJsx, options);
  if (rendered) {
    jsx2 = applyTransformSource(rendered, options, context);
  }
  return story;
};

// src/docs/config.ts
var parameters = {
  docs: {
    inlineStories: true,
    extractArgTypes,
    extractComponentDescription: import_docs_tools9.extractComponentDescription
  }
};
var decorators = [jsxDecorator];
var argTypesEnhancers = [import_docs_tools9.enhanceArgTypes];

// src/render.tsx
var import_global = __toESM(require("global"));
var import_react2 = __toESM(require("react"));
var import_react_dom = __toESM(require("react-dom"));
var { FRAMEWORK_OPTIONS } = import_global.default;
var nodes = /* @__PURE__ */ new Map();
var render = (args, context) => {
  const { id, component: Component } = context;
  if (!Component) {
    throw new Error(
      `Unable to render story ${id} as the component annotation is missing from the default export`
    );
  }
  return /* @__PURE__ */ import_react2.default.createElement(Component, {
    ...args
  });
};
var WithCallback = ({
  callback,
  children
}) => {
  const once = (0, import_react2.useRef)();
  (0, import_react2.useLayoutEffect)(() => {
    if (once.current === callback)
      return;
    once.current = callback;
    callback();
  }, [callback]);
  return children;
};
var renderElement = async (node, el) => {
  const root = await getReactRoot(el);
  return new Promise((resolve) => {
    if (root) {
      root.render(/* @__PURE__ */ import_react2.default.createElement(WithCallback, {
        callback: () => resolve(null)
      }, node));
    } else {
      import_react_dom.default.render(node, el, () => resolve(null));
    }
  });
};
var canUseNewReactRootApi = import_react_dom.version && (import_react_dom.version.startsWith("18") || import_react_dom.version.startsWith("0.0.0"));
var shouldUseNewRootApi = (FRAMEWORK_OPTIONS == null ? void 0 : FRAMEWORK_OPTIONS.legacyRootApi) !== true;
var isUsingNewReactRootApi = shouldUseNewRootApi && canUseNewReactRootApi;
var unmountElement = (el) => {
  const root = nodes.get(el);
  if (root && isUsingNewReactRootApi) {
    root.unmount();
    nodes.delete(el);
  } else {
    import_react_dom.default.unmountComponentAtNode(el);
  }
};
var getReactRoot = async (el) => {
  if (!isUsingNewReactRootApi) {
    return null;
  }
  let root = nodes.get(el);
  if (!root) {
    const reactDomClient = (await import("react-dom/client")).default;
    root = reactDomClient.createRoot(el);
    nodes.set(el, root);
  }
  return root;
};
var ErrorBoundary = class extends import_react2.Component {
  constructor() {
    super(...arguments);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  componentDidMount() {
    const { hasError } = this.state;
    const { showMain } = this.props;
    if (!hasError) {
      showMain();
    }
  }
  componentDidCatch(err) {
    const { showException } = this.props;
    showException(err);
  }
  render() {
    const { hasError } = this.state;
    const { children } = this.props;
    return hasError ? null : children;
  }
};
var Wrapper = (FRAMEWORK_OPTIONS == null ? void 0 : FRAMEWORK_OPTIONS.strictMode) ? import_react2.StrictMode : import_react2.Fragment;
async function renderToDOM({
  storyContext,
  unboundStoryFn,
  showMain,
  showException,
  forceRemount
}, domElement) {
  const Story = unboundStoryFn;
  const content = /* @__PURE__ */ import_react2.default.createElement(ErrorBoundary, {
    showMain,
    showException
  }, /* @__PURE__ */ import_react2.default.createElement(Story, {
    ...storyContext
  }));
  const element = Wrapper ? /* @__PURE__ */ import_react2.default.createElement(Wrapper, null, content) : content;
  if (forceRemount) {
    unmountElement(domElement);
  }
  await renderElement(element, domElement);
  return () => unmountElement(domElement);
}

// src/config.ts
var parameters2 = {
  framework: "react",
  ...parameters
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  argTypesEnhancers,
  decorators,
  parameters,
  render,
  renderToDOM
});
