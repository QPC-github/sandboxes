import * as _storybook_csf from '@storybook/csf';
import { AnyFramework, ProjectAnnotations, StrictArgTypes, StrictGlobalTypes, ComponentAnnotations, ComponentId, ComponentTitle, StoryAnnotations, StoryId, StoryName, StoryFn as StoryFn$1, StoryContextForEnhancers, LegacyStoryFn, StoryContextForLoaders, StoryContext, PartialStoryFn, StoryIdentifier, Parameters, ViewMode, Args, DecoratorFunction, Globals, GlobalTypes, InputType, StrictInputType, ArgTypes, LegacyStoryAnnotationsOrFn, StepRunner, AnnotatedStoryFn, ArgTypesEnhancer, StoryContextUpdate } from '@storybook/csf';
export { Parameters, StoryId } from '@storybook/csf';
import { SynchronousPromise } from 'synchronous-promise';
import { StoryIndexEntry, IndexEntry, HooksContext, Parameters as Parameters$1, StorySortParameterV7, StorySortParameter } from '@storybook/addons';
export { DocsIndexEntry, HooksContext, IndexEntry, StandaloneDocsIndexEntry, StoryIndexEntry, TemplateDocsIndexEntry, applyHooks, useArgs, useCallback, useChannel, useEffect, useGlobals, useMemo, useParameter, useReducer, useRef, useState, useStoryContext } from '@storybook/addons';

declare type Path = string;
declare type ModuleExport = any;
declare type ModuleExports = Record<string, ModuleExport>;
declare type PromiseLike<T> = Promise<T> | SynchronousPromise<T>;
declare type ModuleImportFn = (path: Path) => PromiseLike<ModuleExports>;
declare type MaybePromise<T> = Promise<T> | T;
declare type TeardownRenderToDOM = () => MaybePromise<void>;
declare type RenderToDOM<TFramework extends AnyFramework> = (context: RenderContext<TFramework>, element: Element) => MaybePromise<void | TeardownRenderToDOM>;
declare type WebProjectAnnotations<TFramework extends AnyFramework> = ProjectAnnotations<TFramework> & {
    renderToDOM?: RenderToDOM<TFramework>;
};
declare type NormalizedProjectAnnotations<TFramework extends AnyFramework = AnyFramework> = ProjectAnnotations<TFramework> & {
    argTypes?: StrictArgTypes;
    globalTypes?: StrictGlobalTypes;
};
declare type NormalizedComponentAnnotations<TFramework extends AnyFramework = AnyFramework> = ComponentAnnotations<TFramework> & {
    id: ComponentId;
    title: ComponentTitle;
    argTypes?: StrictArgTypes;
};
declare type NormalizedStoryAnnotations<TFramework extends AnyFramework = AnyFramework> = Omit<StoryAnnotations<TFramework>, 'storyName' | 'story'> & {
    moduleExport: ModuleExport;
    id: StoryId;
    argTypes?: StrictArgTypes;
    name: StoryName;
    userStoryFn?: StoryFn$1<TFramework>;
};
declare type CSFFile<TFramework extends AnyFramework = AnyFramework> = {
    meta: NormalizedComponentAnnotations<TFramework>;
    stories: Record<StoryId, NormalizedStoryAnnotations<TFramework>>;
};
declare type Story<TFramework extends AnyFramework = AnyFramework> = StoryContextForEnhancers<TFramework> & {
    moduleExport: ModuleExport;
    originalStoryFn: StoryFn$1<TFramework>;
    undecoratedStoryFn: LegacyStoryFn<TFramework>;
    unboundStoryFn: LegacyStoryFn<TFramework>;
    applyLoaders: (context: StoryContextForLoaders<TFramework>) => Promise<StoryContextForLoaders<TFramework> & {
        loaded: StoryContext<TFramework>['loaded'];
    }>;
    playFunction?: (context: StoryContext<TFramework>) => Promise<void> | void;
};
declare type BoundStory<TFramework extends AnyFramework = AnyFramework> = Story<TFramework> & {
    storyFn: PartialStoryFn<TFramework>;
};
declare type RenderContext<TFramework extends AnyFramework = AnyFramework> = StoryIdentifier & {
    showMain: () => void;
    showError: (error: {
        title: string;
        description: string;
    }) => void;
    showException: (err: Error) => void;
    forceRemount: boolean;
    storyContext: StoryContext<TFramework>;
    storyFn: PartialStoryFn<TFramework>;
    unboundStoryFn: LegacyStoryFn<TFramework>;
};
interface V2CompatIndexEntry extends Omit<StoryIndexEntry, 'type'> {
    kind: StoryIndexEntry['title'];
    story: StoryIndexEntry['name'];
    parameters: Parameters;
}
interface StoryIndexV3 {
    v: number;
    stories: Record<StoryId, V2CompatIndexEntry>;
}
interface StoryIndex {
    v: number;
    entries: Record<StoryId, IndexEntry>;
}
declare type StorySpecifier = StoryId | {
    name: StoryName;
    title: ComponentTitle;
} | '*';
interface SelectionSpecifier {
    storySpecifier: StorySpecifier;
    viewMode: ViewMode;
    args?: Args;
    globals?: Args;
}
interface Selection {
    storyId: StoryId;
    viewMode: ViewMode;
}
declare type DecoratorApplicator<TFramework extends AnyFramework = AnyFramework> = (storyFn: LegacyStoryFn<TFramework>, decorators: DecoratorFunction<TFramework>[]) => LegacyStoryFn<TFramework>;
interface StoriesSpecifier {
    directory: string;
    titlePrefix?: string;
}
interface NormalizedStoriesSpecifier$1 {
    glob?: string;
    specifier?: StoriesSpecifier;
}
declare type ExtractOptions = {
    includeDocsOnly?: boolean;
};

declare class StoryIndexStore {
    entries: StoryIndex['entries'];
    constructor({ entries }?: StoryIndex);
    entryFromSpecifier(specifier: StorySpecifier): IndexEntry | undefined;
    storyIdToEntry(storyId: StoryId): IndexEntry;
    importPathToEntry(importPath: Path): IndexEntry;
}

declare class ArgsStore {
    initialArgsByStoryId: Record<StoryId, Args>;
    argsByStoryId: Record<StoryId, Args>;
    get(storyId: StoryId): Args;
    setInitial(story: Story<any>): void;
    updateFromDelta(story: Story<any>, delta: Args): void;
    updateFromPersisted(story: Story<any>, persisted: Args): void;
    update(storyId: StoryId, argsUpdate: Partial<Args>): void;
}

declare class GlobalsStore {
    allowedGlobalNames: Set<string>;
    initialGlobals: Globals;
    globals: Globals;
    constructor({ globals, globalTypes, }: {
        globals?: Globals;
        globalTypes?: GlobalTypes;
    });
    set({ globals, globalTypes }: {
        globals?: Globals;
        globalTypes?: GlobalTypes;
    }): void;
    filterAllowedGlobals(globals: Globals): Globals;
    updateFromPersisted(persisted: Globals): void;
    get(): Globals;
    update(newGlobals: Globals): void;
}

declare const normalizeInputType: (inputType: InputType, key: string) => StrictInputType;
declare const normalizeInputTypes: (inputTypes: ArgTypes | GlobalTypes) => StrictArgTypes | StrictGlobalTypes;

declare function normalizeStory<TFramework extends AnyFramework>(key: StoryId, storyAnnotations: LegacyStoryAnnotationsOrFn<TFramework>, meta: NormalizedComponentAnnotations<TFramework>): NormalizedStoryAnnotations<TFramework>;

declare function processCSFFile<TFramework extends AnyFramework>(moduleExports: ModuleExports, importPath: Path, title: ComponentTitle): CSFFile<TFramework>;

declare function prepareStory<TFramework extends AnyFramework>(storyAnnotations: NormalizedStoryAnnotations<TFramework>, componentAnnotations: NormalizedComponentAnnotations<TFramework>, projectAnnotations: NormalizedProjectAnnotations<TFramework>): Story<TFramework>;

declare function normalizeComponentAnnotations<TFramework extends AnyFramework>(defaultExport: ModuleExports['default'], title?: string, importPath?: string): NormalizedComponentAnnotations<TFramework>;

declare function normalizeProjectAnnotations<TFramework extends AnyFramework>({ argTypes, globalTypes, argTypesEnhancers, ...annotations }: ProjectAnnotations<TFramework>): NormalizedProjectAnnotations<TFramework>;

declare const getValuesFromArgTypes: (argTypes?: ArgTypes) => ArgTypes<_storybook_csf.Args>;

declare function getField<TFieldType = any>(moduleExportList: ModuleExports[], field: string): TFieldType | TFieldType[];
declare function getArrayField<TFieldType = any>(moduleExportList: ModuleExports[], field: string): TFieldType[];
declare function getObjectField<TFieldType = Record<string, any>>(moduleExportList: ModuleExports[], field: string): TFieldType;
declare function getSingletonField<TFieldType = any>(moduleExportList: ModuleExports[], field: string): TFieldType;
declare function composeConfigs<TFramework extends AnyFramework>(moduleExportList: ModuleExports[]): WebProjectAnnotations<TFramework>;

/**
 * Compose step runners to create a single step runner that applies each step runner in order.
 *
 * A step runner is a a function that takes a defined step: `step('label', () => { ... })`
 * and runs it. The prototypical example is from `@storybook/addon-interactions` where the
 * step runner will decorate all instrumented code inside the step with information about the
 * label.
 *
 * In theory it is possible to have more than one addon that wants to run steps; they can be
 * composed together in a similar fashion to decorators. In some ways step runners are like
 * decorators except it is not intended that they change the context or the play function.
 *
 * The basic implementation of a step runner is `async (label, play, context) => play(context)`
 *  -- in fact this is what `composeStepRunners([])` will do.
 *
 * @param stepRunners an array of StepRunner
 * @returns a StepRunner that is the composition of the arguments
 */
declare function composeStepRunners<TFramework extends AnyFramework>(stepRunners: StepRunner<TFramework>[]): StepRunner<TFramework>;

declare type CSFExports<TFramework extends AnyFramework = AnyFramework> = {
    default: ComponentAnnotations<TFramework, Args>;
    __esModule?: boolean;
    __namedExportsOrder?: string[];
};
declare type ComposedStoryPlayContext = Partial<StoryContext> & Pick<StoryContext, 'canvasElement'>;
declare type ComposedStoryPlayFn = (context: ComposedStoryPlayContext) => Promise<void> | void;
declare type StoryFn<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = AnnotatedStoryFn<TFramework, TArgs> & {
    play: ComposedStoryPlayFn;
};
declare type ComposedStory<TFramework extends AnyFramework = AnyFramework, TArgs = Args> = StoryFn<TFramework, TArgs> | StoryAnnotations<TFramework, TArgs>;
/**
 * T represents the whole ES module of a stories file. K of T means named exports (basically the Story type)
 * 1. pick the keys K of T that have properties that are Story<AnyProps>
 * 2. infer the actual prop type for each Story
 * 3. reconstruct Story with Partial. Story<Props> -> Story<Partial<Props>>
 */
declare type StoriesWithPartialProps<TFramework extends AnyFramework, TModule> = {
    [K in keyof TModule]: TModule[K] extends ComposedStory<infer _, infer TProps> ? AnnotatedStoryFn<TFramework, Partial<TProps>> : unknown;
};

declare function setProjectAnnotations<TFramework extends AnyFramework = AnyFramework>(projectAnnotations: ProjectAnnotations<TFramework> | ProjectAnnotations<TFramework>[]): void;
interface ComposeStory<TFramework extends AnyFramework = AnyFramework, TArgs extends Args = Args> {
    (storyAnnotations: AnnotatedStoryFn<TFramework, TArgs> | StoryAnnotations<TFramework, TArgs>, componentAnnotations: ComponentAnnotations<TFramework, TArgs>, projectAnnotations: ProjectAnnotations<TFramework>, exportsName?: string): {
        (extraArgs: Partial<TArgs>): TFramework['storyResult'];
        storyName: string;
        args: Args;
        play: ComposedStoryPlayFn;
        parameters: Parameters;
    };
}
declare function composeStory<TFramework extends AnyFramework = AnyFramework, TArgs extends Args = Args>(storyAnnotations: LegacyStoryAnnotationsOrFn<TFramework>, componentAnnotations: ComponentAnnotations<TFramework, TArgs>, projectAnnotations?: ProjectAnnotations<TFramework>, defaultConfig?: ProjectAnnotations<TFramework>, exportsName?: string): {
    (extraArgs: Partial<TArgs>): TFramework["storyResult"];
    storyName: string;
    args: Args;
    play: ComposedStoryPlayFn;
    parameters: Parameters;
};
declare function composeStories<TModule extends CSFExports>(storiesImport: TModule, globalConfig: ProjectAnnotations<AnyFramework>, composeStoryFn: ComposeStory): {};

declare function useSharedState<S>(sharedId: string, defaultState?: S): [S, (s: S) => void];
declare function useAddonState<S>(addonId: string, defaultState?: S): [S, (s: S) => void];

declare class StoryStore<TFramework extends AnyFramework> {
    storyIndex?: StoryIndexStore;
    importFn?: ModuleImportFn;
    projectAnnotations?: NormalizedProjectAnnotations<TFramework>;
    globals?: GlobalsStore;
    args: ArgsStore;
    hooks: Record<StoryId, HooksContext<TFramework>>;
    cachedCSFFiles?: Record<Path, CSFFile<TFramework>>;
    processCSFFileWithCache: typeof processCSFFile;
    prepareStoryWithCache: typeof prepareStory;
    initializationPromise: SynchronousPromise<void>;
    resolveInitializationPromise: () => void;
    constructor();
    setProjectAnnotations(projectAnnotations: ProjectAnnotations<TFramework>): void;
    initialize({ storyIndex, importFn, cache, }: {
        storyIndex?: StoryIndex;
        importFn: ModuleImportFn;
        cache?: boolean;
    }): PromiseLike<void>;
    onStoriesChanged({ importFn, storyIndex, }: {
        importFn?: ModuleImportFn;
        storyIndex?: StoryIndex;
    }): Promise<void>;
    storyIdToEntry(storyId: StoryId): Promise<IndexEntry>;
    loadCSFFileByStoryId(storyId: StoryId): PromiseLike<CSFFile<TFramework>>;
    loadAllCSFFiles(): PromiseLike<StoryStore<TFramework>['cachedCSFFiles']>;
    cacheAllCSFFiles(): PromiseLike<void>;
    loadStory({ storyId }: {
        storyId: StoryId;
    }): Promise<Story<TFramework>>;
    storyFromCSFFile({ storyId, csfFile, }: {
        storyId: StoryId;
        csfFile: CSFFile<TFramework>;
    }): Story<TFramework>;
    componentStoriesFromCSFFile({ csfFile }: {
        csfFile: CSFFile<TFramework>;
    }): Story<TFramework>[];
    loadEntry(id: StoryId): Promise<{
        entryExports: ModuleExports;
        csfFiles: CSFFile<TFramework>[];
    }>;
    getStoryContext(story: Story<TFramework>): Omit<StoryContextForLoaders<TFramework>, 'viewMode'>;
    cleanupStory(story: Story<TFramework>): void;
    extract(options?: ExtractOptions): Record<StoryId, StoryContextForEnhancers<TFramework>>;
    getSetStoriesPayload(): {
        v: number;
        globals: _storybook_csf.Globals;
        globalParameters: {};
        kindParameters: Parameters;
        stories: Record<string, StoryContextForEnhancers<TFramework, _storybook_csf.Args>>;
    };
    getStoriesJsonData: () => StoryIndexV3;
    raw(): BoundStory<TFramework>[];
    fromId(storyId: StoryId): BoundStory<TFramework> | null;
}

/**
 * Safely combine parameters recursively. Only copy objects when needed.
 * Algorithm = always overwrite the existing value UNLESS both values
 * are plain objects. In this case flag the key as "special" and handle
 * it with a heuristic.
 */
declare const combineParameters: (...parameterSets: (Parameters$1 | undefined)[]) => Parameters$1;

declare type PropDescriptor = string[] | RegExp;
declare const filterArgTypes: (argTypes: StrictArgTypes, include?: PropDescriptor | undefined, exclude?: PropDescriptor | undefined) => StrictArgTypes<_storybook_csf.Args>;

declare const inferControls: ArgTypesEnhancer<AnyFramework>;

declare function decorateStory<TFramework extends AnyFramework>(storyFn: LegacyStoryFn<TFramework>, decorator: DecoratorFunction<TFramework>, bindWithContext: (storyFn: LegacyStoryFn<TFramework>) => PartialStoryFn<TFramework>): LegacyStoryFn<TFramework>;
/**
 * Currently StoryContextUpdates are allowed to have any key in the type.
 * However, you cannot overwrite any of the build-it "static" keys.
 *
 * @param inputContextUpdate StoryContextUpdate
 * @returns StoryContextUpdate
 */
declare function sanitizeStoryContextUpdate({ componentId, title, kind, id, name, story, parameters, initialArgs, argTypes, ...update }?: StoryContextUpdate): StoryContextUpdate;
declare function defaultDecorateStory<TFramework extends AnyFramework>(storyFn: LegacyStoryFn<TFramework>, decorators: DecoratorFunction<TFramework>[]): LegacyStoryFn<TFramework>;

declare const mapArgsToTypes: (args: Args, argTypes: ArgTypes) => Args;
declare const combineArgs: (value: any, update: any) => Args;
declare const validateOptions: (args: Args, argTypes: ArgTypes) => Args;
declare const DEEPLY_EQUAL: unique symbol;
declare const deepDiff: (value: any, update: any) => any;
declare const NO_TARGET_NAME = "";
declare function groupArgsByTarget<TArgs = Args>({ args, argTypes, }: StoryContext<AnyFramework, TArgs>): Record<string, Partial<TArgs>>;
declare function noTargetArgs<TArgs = Args>(context: StoryContext<AnyFramework, TArgs>): Partial<TArgs>;

interface NormalizedStoriesSpecifier {
    titlePrefix?: string;
    directory: string;
    files?: string;
    importPathMatcher: RegExp;
}
declare const userOrAutoTitleFromSpecifier: (fileName: string | number, entry: NormalizedStoriesSpecifier, userTitle?: string | undefined) => string | undefined;
declare const userOrAutoTitle: (fileName: string, storiesEntries: NormalizedStoriesSpecifier[], userTitle?: string | undefined) => string | undefined;

declare const sortStoriesV7: (stories: IndexEntry[], storySortParameter: StorySortParameterV7, fileNameOrder: Path[]) => IndexEntry[];
declare const sortStoriesV6: (stories: [string, Story, Parameters, Parameters][], storySortParameter: StorySortParameter, fileNameOrder: Path[]) => IndexEntry[];

export { BoundStory, CSFExports, CSFFile, ComposedStory, ComposedStoryPlayContext, ComposedStoryPlayFn, DEEPLY_EQUAL, DecoratorApplicator, ExtractOptions, ModuleExport, ModuleExports, ModuleImportFn, NO_TARGET_NAME, NormalizedComponentAnnotations, NormalizedProjectAnnotations, NormalizedStoriesSpecifier$1 as NormalizedStoriesSpecifier, NormalizedStoryAnnotations, Path, PromiseLike, PropDescriptor, RenderContext, RenderToDOM, Selection, SelectionSpecifier, StoriesSpecifier, StoriesWithPartialProps, Story, StoryFn, StoryIndex, StoryIndexV3, StorySpecifier, StoryStore, TeardownRenderToDOM, V2CompatIndexEntry, WebProjectAnnotations, combineArgs, combineParameters, composeConfigs, composeStepRunners, composeStories, composeStory, decorateStory, deepDiff, defaultDecorateStory, filterArgTypes, getArrayField, getField, getObjectField, getSingletonField, getValuesFromArgTypes, groupArgsByTarget, inferControls, mapArgsToTypes, noTargetArgs, normalizeComponentAnnotations, normalizeInputType, normalizeInputTypes, normalizeProjectAnnotations, normalizeStory, prepareStory, processCSFFile, sanitizeStoryContextUpdate, setProjectAnnotations, sortStoriesV6, sortStoriesV7, useAddonState, useSharedState, userOrAutoTitle, userOrAutoTitleFromSpecifier, validateOptions };
