// src/StoryStore.ts
import memoize2 from "memoizerific";
import mapValues4 from "lodash/mapValues";
import pick from "lodash/pick";
import { SynchronousPromise } from "synchronous-promise";

// src/StoryIndexStore.ts
import { dedent } from "ts-dedent";
import memoize from "memoizerific";
var getImportPathMap = memoize(1)(
  (entries) => Object.values(entries).reduce((acc, entry) => {
    acc[entry.importPath] = acc[entry.importPath] || entry;
    return acc;
  }, {})
);
var StoryIndexStore = class {
  constructor({ entries } = { v: 4, entries: {} }) {
    this.entries = entries;
  }
  entryFromSpecifier(specifier) {
    const entries = Object.values(this.entries);
    if (specifier === "*") {
      return entries[0];
    }
    if (typeof specifier === "string") {
      if (this.entries[specifier]) {
        return this.entries[specifier];
      }
      return entries.find((entry) => entry.id.startsWith(specifier));
    }
    const { name, title } = specifier;
    return entries.find((entry) => entry.name === name && entry.title === title);
  }
  storyIdToEntry(storyId) {
    const storyEntry = this.entries[storyId];
    if (!storyEntry) {
      throw new Error(dedent`Couldn't find story matching '${storyId}' after HMR.
      - Did you remove it from your CSF file?
      - Are you sure a story with that id exists?
      - Please check your entries field of your main.js config.
      - Also check the browser console and terminal for error messages.`);
    }
    return storyEntry;
  }
  importPathToEntry(importPath) {
    return getImportPathMap(this.entries)[importPath];
  }
};

// src/args.ts
import { dequal as deepEqual } from "dequal";
import { once } from "@storybook/client-logger";
import isPlainObject from "lodash/isPlainObject";
import { dedent as dedent2 } from "ts-dedent";
var INCOMPATIBLE = Symbol("incompatible");
var map = (arg, argType) => {
  const type = argType.type;
  if (arg === void 0 || arg === null || !type)
    return arg;
  if (argType.mapping) {
    return arg;
  }
  switch (type.name) {
    case "string":
      return String(arg);
    case "enum":
      return arg;
    case "number":
      return Number(arg);
    case "boolean":
      return arg === "true";
    case "array":
      if (!type.value || !Array.isArray(arg))
        return INCOMPATIBLE;
      return arg.reduce((acc, item, index) => {
        const mapped = map(item, { type: type.value });
        if (mapped !== INCOMPATIBLE)
          acc[index] = mapped;
        return acc;
      }, new Array(arg.length));
    case "object":
      if (typeof arg === "string" || typeof arg === "number")
        return arg;
      if (!type.value || typeof arg !== "object")
        return INCOMPATIBLE;
      return Object.entries(arg).reduce((acc, [key, val]) => {
        const mapped = map(val, { type: type.value[key] });
        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
      }, {});
    default:
      return INCOMPATIBLE;
  }
};
var mapArgsToTypes = (args, argTypes) => {
  return Object.entries(args).reduce((acc, [key, value]) => {
    if (!argTypes[key])
      return acc;
    const mapped = map(value, argTypes[key]);
    return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
  }, {});
};
var combineArgs = (value, update) => {
  if (Array.isArray(value) && Array.isArray(update)) {
    return update.reduce(
      (acc, upd, index) => {
        acc[index] = combineArgs(value[index], update[index]);
        return acc;
      },
      [...value]
    ).filter((v) => v !== void 0);
  }
  if (!isPlainObject(value) || !isPlainObject(update))
    return update;
  return Object.keys({ ...value, ...update }).reduce((acc, key) => {
    if (key in update) {
      const combined = combineArgs(value[key], update[key]);
      if (combined !== void 0)
        acc[key] = combined;
    } else {
      acc[key] = value[key];
    }
    return acc;
  }, {});
};
var validateOptions = (args, argTypes) => {
  return Object.entries(argTypes).reduce((acc, [key, { options }]) => {
    function allowArg() {
      if (key in args) {
        acc[key] = args[key];
      }
      return acc;
    }
    if (!options)
      return allowArg();
    if (!Array.isArray(options)) {
      once.error(dedent2`
        Invalid argType: '${key}.options' should be an array.

        More info: https://storybook.js.org/docs/react/api/argtypes
      `);
      return allowArg();
    }
    if (options.some((opt) => opt && ["object", "function"].includes(typeof opt))) {
      once.error(dedent2`
        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values
      `);
      return allowArg();
    }
    const isArray = Array.isArray(args[key]);
    const invalidIndex = isArray && args[key].findIndex((val) => !options.includes(val));
    const isValidArray = isArray && invalidIndex === -1;
    if (args[key] === void 0 || options.includes(args[key]) || isValidArray) {
      return allowArg();
    }
    const field = isArray ? `${key}[${invalidIndex}]` : key;
    const supportedOptions = options.map((opt) => typeof opt === "string" ? `'${opt}'` : String(opt)).join(", ");
    once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`);
    return acc;
  }, {});
};
var DEEPLY_EQUAL = Symbol("Deeply equal");
var deepDiff = (value, update) => {
  if (typeof value !== typeof update)
    return update;
  if (deepEqual(value, update))
    return DEEPLY_EQUAL;
  if (Array.isArray(value) && Array.isArray(update)) {
    const res = update.reduce((acc, upd, index) => {
      const diff = deepDiff(value[index], upd);
      if (diff !== DEEPLY_EQUAL)
        acc[index] = diff;
      return acc;
    }, new Array(update.length));
    if (update.length >= value.length)
      return res;
    return res.concat(new Array(value.length - update.length).fill(void 0));
  }
  if (isPlainObject(value) && isPlainObject(update)) {
    return Object.keys({ ...value, ...update }).reduce((acc, key) => {
      const diff = deepDiff(value?.[key], update?.[key]);
      return diff === DEEPLY_EQUAL ? acc : Object.assign(acc, { [key]: diff });
    }, {});
  }
  return update;
};
var NO_TARGET_NAME = "";
function groupArgsByTarget({
  args,
  argTypes
}) {
  const groupedArgs = {};
  Object.entries(args).forEach(([name, value]) => {
    const { target = NO_TARGET_NAME } = argTypes[name] || {};
    groupedArgs[target] = groupedArgs[target] || {};
    groupedArgs[target][name] = value;
  });
  return groupedArgs;
}
function noTargetArgs(context) {
  return groupArgsByTarget(context)[NO_TARGET_NAME];
}

// src/ArgsStore.ts
function deleteUndefined(obj) {
  Object.keys(obj).forEach((key) => obj[key] === void 0 && delete obj[key]);
  return obj;
}
var ArgsStore = class {
  constructor() {
    this.initialArgsByStoryId = {};
    this.argsByStoryId = {};
  }
  get(storyId) {
    if (!(storyId in this.argsByStoryId)) {
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    }
    return this.argsByStoryId[storyId];
  }
  setInitial(story) {
    if (!this.initialArgsByStoryId[story.id]) {
      this.initialArgsByStoryId[story.id] = story.initialArgs;
      this.argsByStoryId[story.id] = story.initialArgs;
    } else if (this.initialArgsByStoryId[story.id] !== story.initialArgs) {
      const delta = deepDiff(this.initialArgsByStoryId[story.id], this.argsByStoryId[story.id]);
      this.initialArgsByStoryId[story.id] = story.initialArgs;
      this.argsByStoryId[story.id] = story.initialArgs;
      if (delta !== DEEPLY_EQUAL) {
        this.updateFromDelta(story, delta);
      }
    }
  }
  updateFromDelta(story, delta) {
    const validatedDelta = validateOptions(delta, story.argTypes);
    this.argsByStoryId[story.id] = combineArgs(this.argsByStoryId[story.id], validatedDelta);
  }
  updateFromPersisted(story, persisted) {
    const mappedPersisted = mapArgsToTypes(persisted, story.argTypes);
    return this.updateFromDelta(story, mappedPersisted);
  }
  update(storyId, argsUpdate) {
    if (!(storyId in this.argsByStoryId)) {
      throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
    }
    this.argsByStoryId[storyId] = deleteUndefined({
      ...this.argsByStoryId[storyId],
      ...argsUpdate
    });
  }
};

// src/GlobalsStore.ts
import deprecate from "util-deprecate";
import { dedent as dedent3 } from "ts-dedent";

// src/csf/getValuesFromArgTypes.ts
var getValuesFromArgTypes = (argTypes = {}) => Object.entries(argTypes).reduce((acc, [arg, { defaultValue }]) => {
  if (typeof defaultValue !== "undefined") {
    acc[arg] = defaultValue;
  }
  return acc;
}, {});

// src/GlobalsStore.ts
var setUndeclaredWarning = deprecate(
  () => {
  },
  dedent3`
    Setting a global value that is undeclared (i.e. not in the user's initial set of globals
    or globalTypes) is deprecated and will have no effect in 7.0.
  `
);
var GlobalsStore = class {
  constructor({
    globals = {},
    globalTypes = {}
  }) {
    this.set({ globals, globalTypes });
  }
  set({ globals = {}, globalTypes = {} }) {
    const delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);
    const defaultGlobals = getValuesFromArgTypes(globalTypes);
    this.initialGlobals = { ...defaultGlobals, ...globals };
    this.globals = this.initialGlobals;
    if (delta && delta !== DEEPLY_EQUAL) {
      this.updateFromPersisted(delta);
    }
  }
  filterAllowedGlobals(globals) {
    return Object.entries(globals).reduce((acc, [key, value]) => {
      if (this.allowedGlobalNames.has(key))
        acc[key] = value;
      return acc;
    }, {});
  }
  updateFromPersisted(persisted) {
    const allowedUrlGlobals = this.filterAllowedGlobals(persisted);
    this.globals = { ...this.globals, ...allowedUrlGlobals };
  }
  get() {
    return this.globals;
  }
  update(newGlobals) {
    Object.keys(newGlobals).forEach((key) => {
      if (!this.allowedGlobalNames.has(key)) {
        setUndeclaredWarning();
      }
    });
    this.globals = { ...this.globals, ...newGlobals };
  }
};

// src/csf/normalizeInputTypes.ts
import mapValues from "lodash/mapValues";
var normalizeType = (type) => {
  return typeof type === "string" ? { name: type } : type;
};
var normalizeControl = (control) => typeof control === "string" ? { type: control } : control;
var normalizeInputType = (inputType, key) => {
  const { type, control, ...rest } = inputType;
  const normalized = {
    name: key,
    ...rest
  };
  if (type)
    normalized.type = normalizeType(type);
  if (control) {
    normalized.control = normalizeControl(control);
  } else if (control === false) {
    normalized.control = { disable: true };
  }
  return normalized;
};
var normalizeInputTypes = (inputTypes) => mapValues(inputTypes, normalizeInputType);

// src/csf/normalizeStory.ts
import { storyNameFromExport, toId } from "@storybook/csf";
import { dedent as dedent4 } from "ts-dedent";
import { logger } from "@storybook/client-logger";
import deprecate2 from "util-deprecate";
var deprecatedStoryAnnotation = dedent4`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
var deprecatedStoryAnnotationWarning = deprecate2(() => {
}, deprecatedStoryAnnotation);
function normalizeStory(key, storyAnnotations, meta) {
  const storyObject = storyAnnotations;
  const userStoryFn = typeof storyAnnotations === "function" ? storyAnnotations : null;
  const { story } = storyObject;
  if (story) {
    logger.debug("deprecated story", story);
    deprecatedStoryAnnotationWarning();
  }
  const exportName = storyNameFromExport(key);
  const name = typeof storyObject !== "function" && storyObject.name || storyObject.storyName || story?.name || exportName;
  const decorators = [...storyObject.decorators || [], ...story?.decorators || []];
  const parameters = { ...story?.parameters, ...storyObject.parameters };
  const args = { ...story?.args, ...storyObject.args };
  const argTypes = { ...story?.argTypes, ...storyObject.argTypes };
  const loaders = [...storyObject.loaders || [], ...story?.loaders || []];
  const { render, play } = storyObject;
  const id = parameters.__id || toId(meta.id, exportName);
  return {
    moduleExport: storyAnnotations,
    id,
    name,
    decorators,
    parameters,
    args,
    argTypes: normalizeInputTypes(argTypes),
    loaders,
    ...render && { render },
    ...userStoryFn && { userStoryFn },
    ...play && { play }
  };
}

// src/csf/processCSFFile.ts
import { isExportStory } from "@storybook/csf";
import { logger as logger2 } from "@storybook/client-logger";

// src/csf/normalizeComponentAnnotations.ts
import { sanitize } from "@storybook/csf";
function normalizeComponentAnnotations(defaultExport, title = defaultExport.title, importPath) {
  const { id, argTypes } = defaultExport;
  return {
    id: sanitize(id || title),
    ...defaultExport,
    title,
    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
    parameters: {
      fileName: importPath,
      ...defaultExport.parameters
    }
  };
}

// src/csf/processCSFFile.ts
var checkGlobals = (parameters) => {
  const { globals, globalTypes } = parameters;
  if (globals || globalTypes) {
    logger2.error(
      "Global args/argTypes can only be set globally",
      JSON.stringify({
        globals,
        globalTypes
      })
    );
  }
};
var checkStorySort = (parameters) => {
  const { options } = parameters;
  if (options?.storySort)
    logger2.error("The storySort option parameter can only be set globally");
};
var checkDisallowedParameters = (parameters) => {
  if (!parameters)
    return;
  checkGlobals(parameters);
  checkStorySort(parameters);
};
function processCSFFile(moduleExports, importPath, title) {
  const { default: defaultExport, __namedExportsOrder, ...namedExports } = moduleExports;
  const meta = normalizeComponentAnnotations(defaultExport, title, importPath);
  checkDisallowedParameters(meta.parameters);
  const csfFile = { meta, stories: {} };
  Object.keys(namedExports).forEach((key) => {
    if (isExportStory(key, meta)) {
      const storyMeta = normalizeStory(key, namedExports[key], meta);
      checkDisallowedParameters(storyMeta.parameters);
      csfFile.stories[storyMeta.id] = storyMeta;
    }
  });
  return csfFile;
}

// src/csf/prepareStory.ts
import { dedent as dedent5 } from "ts-dedent";
import deprecate3 from "util-deprecate";
import global from "global";
import { includeConditionalArg } from "@storybook/csf";

// src/parameters.ts
import isPlainObject2 from "lodash/isPlainObject";
var combineParameters = (...parameterSets) => {
  const mergeKeys = {};
  const definedParametersSets = parameterSets.filter(Boolean);
  const combined = definedParametersSets.reduce((acc, parameters) => {
    Object.entries(parameters).forEach(([key, value]) => {
      const existing = acc[key];
      if (Array.isArray(value) || typeof existing === "undefined") {
        acc[key] = value;
      } else if (isPlainObject2(value) && isPlainObject2(existing)) {
        mergeKeys[key] = true;
      } else if (typeof value !== "undefined") {
        acc[key] = value;
      }
    });
    return acc;
  }, {});
  Object.keys(mergeKeys).forEach((key) => {
    const mergeValues = definedParametersSets.filter(Boolean).map((p) => p[key]).filter((value) => typeof value !== "undefined");
    if (mergeValues.every((value) => isPlainObject2(value))) {
      combined[key] = combineParameters(...mergeValues);
    } else {
      combined[key] = mergeValues[mergeValues.length - 1];
    }
  });
  return combined;
};

// src/hooks.ts
import { SHARED_STATE_CHANGED, SHARED_STATE_SET } from "@storybook/core-events";
import {
  addons,
  HooksContext,
  applyHooks,
  useMemo,
  useCallback,
  useRef,
  useState,
  useReducer,
  useEffect,
  useChannel,
  useStoryContext,
  useParameter,
  useArgs,
  useGlobals
} from "@storybook/addons";
function useSharedState(sharedId, defaultState) {
  const channel = addons.getChannel();
  const [lastValue] = channel.last(`${SHARED_STATE_CHANGED}-manager-${sharedId}`) || channel.last(`${SHARED_STATE_SET}-manager-${sharedId}`) || [];
  const [state, setState] = useState(lastValue || defaultState);
  const allListeners = useMemo(
    () => ({
      [`${SHARED_STATE_CHANGED}-manager-${sharedId}`]: (s) => setState(s),
      [`${SHARED_STATE_SET}-manager-${sharedId}`]: (s) => setState(s)
    }),
    [sharedId]
  );
  const emit = useChannel(allListeners, [sharedId]);
  useEffect(() => {
    if (defaultState !== void 0 && !lastValue) {
      emit(`${SHARED_STATE_SET}-client-${sharedId}`, defaultState);
    }
  }, [sharedId]);
  return [
    state,
    (s) => {
      setState(s);
      emit(`${SHARED_STATE_CHANGED}-client-${sharedId}`, s);
    }
  ];
}
function useAddonState(addonId, defaultState) {
  return useSharedState(addonId, defaultState);
}

// src/decorators.ts
function decorateStory(storyFn, decorator, bindWithContext) {
  const boundStoryFunction = bindWithContext(storyFn);
  return (context) => decorator(boundStoryFunction, context);
}
function sanitizeStoryContextUpdate({
  componentId,
  title,
  kind,
  id,
  name,
  story,
  parameters,
  initialArgs,
  argTypes,
  ...update
} = {}) {
  return update;
}
function defaultDecorateStory(storyFn, decorators) {
  const contextStore = {};
  const bindWithContext = (decoratedStoryFn) => (update) => {
    if (!contextStore.value)
      throw new Error("Decorated function called without init");
    contextStore.value = {
      ...contextStore.value,
      ...sanitizeStoryContextUpdate(update)
    };
    return decoratedStoryFn(contextStore.value);
  };
  const decoratedWithContextStore = decorators.reduce(
    (story, decorator) => decorateStory(story, decorator, bindWithContext),
    storyFn
  );
  return (context) => {
    contextStore.value = context;
    return decoratedWithContextStore(context);
  };
}

// src/csf/prepareStory.ts
var argTypeDefaultValueWarning = deprecate3(
  () => {
  },
  dedent5`
  \`argType.defaultValue\` is deprecated and will be removed in Storybook 7.0.

  https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#no-longer-inferring-default-values-of-args`
);
function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {
  const { moduleExport, id, name } = storyAnnotations;
  const { title } = componentAnnotations;
  const parameters = combineParameters(
    projectAnnotations.parameters,
    componentAnnotations.parameters,
    storyAnnotations.parameters
  );
  const decorators = [
    ...storyAnnotations.decorators || [],
    ...componentAnnotations.decorators || [],
    ...projectAnnotations.decorators || []
  ];
  const {
    applyDecorators = defaultDecorateStory,
    argTypesEnhancers = [],
    argsEnhancers = [],
    runStep
  } = projectAnnotations;
  const loaders = [
    ...projectAnnotations.loaders || [],
    ...componentAnnotations.loaders || [],
    ...storyAnnotations.loaders || []
  ];
  const render = storyAnnotations.userStoryFn || storyAnnotations.render || componentAnnotations.render || projectAnnotations.render;
  if (!render)
    throw new Error(`No render function available for storyId '${id}'`);
  const passedArgTypes = combineParameters(
    projectAnnotations.argTypes,
    componentAnnotations.argTypes,
    storyAnnotations.argTypes
  );
  const { passArgsFirst = true } = parameters;
  parameters.__isArgsStory = passArgsFirst && render.length > 0;
  const passedArgs = {
    ...projectAnnotations.args,
    ...componentAnnotations.args,
    ...storyAnnotations.args
  };
  const contextForEnhancers = {
    componentId: componentAnnotations.id,
    title,
    kind: title,
    id,
    name,
    story: name,
    component: componentAnnotations.component,
    subcomponents: componentAnnotations.subcomponents,
    parameters,
    initialArgs: passedArgs,
    argTypes: passedArgTypes
  };
  contextForEnhancers.argTypes = argTypesEnhancers.reduce(
    (accumulatedArgTypes, enhancer) => enhancer({ ...contextForEnhancers, argTypes: accumulatedArgTypes }),
    contextForEnhancers.argTypes
  );
  const defaultArgs = getValuesFromArgTypes(contextForEnhancers.argTypes);
  if (Object.keys(defaultArgs).length > 0) {
    argTypeDefaultValueWarning();
  }
  const initialArgsBeforeEnhancers = { ...defaultArgs, ...passedArgs };
  contextForEnhancers.initialArgs = argsEnhancers.reduce(
    (accumulatedArgs, enhancer) => ({
      ...accumulatedArgs,
      ...enhancer({
        ...contextForEnhancers,
        initialArgs: accumulatedArgs
      })
    }),
    initialArgsBeforeEnhancers
  );
  if (!global.FEATURES?.breakingChangesV7) {
    contextForEnhancers.parameters = {
      ...contextForEnhancers.parameters,
      __id: id,
      globals: projectAnnotations.globals,
      globalTypes: projectAnnotations.globalTypes,
      args: contextForEnhancers.initialArgs,
      argTypes: contextForEnhancers.argTypes
    };
  }
  const applyLoaders = async (context) => {
    const loadResults = await Promise.all(loaders.map((loader) => loader(context)));
    const loaded = Object.assign({}, ...loadResults);
    return { ...context, loaded };
  };
  const undecoratedStoryFn = (context) => {
    const mappedArgs = Object.entries(context.args).reduce((acc, [key, val]) => {
      const mapping = context.argTypes[key]?.mapping;
      acc[key] = mapping && val in mapping ? mapping[val] : val;
      return acc;
    }, {});
    const includedArgs = Object.entries(mappedArgs).reduce((acc, [key, val]) => {
      const argType = context.argTypes[key] || {};
      if (includeConditionalArg(argType, mappedArgs, context.globals))
        acc[key] = val;
      return acc;
    }, {});
    const includedContext = { ...context, args: includedArgs };
    const { passArgsFirst: renderTimePassArgsFirst = true } = context.parameters;
    return renderTimePassArgsFirst ? render(includedContext.args, includedContext) : render(includedContext);
  };
  const decoratedStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators);
  const unboundStoryFn = (context) => {
    let finalContext = context;
    if (global.FEATURES?.argTypeTargetsV7) {
      const argsByTarget = groupArgsByTarget(context);
      finalContext = {
        ...context,
        allArgs: context.args,
        argsByTarget,
        args: argsByTarget[NO_TARGET_NAME] || {}
      };
    }
    return decoratedStoryFn(finalContext);
  };
  const { play } = storyAnnotations;
  const playFunction = play && (async (storyContext) => {
    const playFunctionContext = {
      ...storyContext,
      step: (label, play2) => runStep(label, play2, playFunctionContext)
    };
    return play(playFunctionContext);
  });
  return Object.freeze({
    ...contextForEnhancers,
    moduleExport,
    originalStoryFn: render,
    undecoratedStoryFn,
    unboundStoryFn,
    applyLoaders,
    playFunction
  });
}

// src/inferArgTypes.ts
import mapValues2 from "lodash/mapValues";
import { dedent as dedent6 } from "ts-dedent";
import { logger as logger3 } from "@storybook/client-logger";
var inferType = (value, name, visited) => {
  const type = typeof value;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: type };
    default:
      break;
  }
  if (value) {
    if (visited.has(value)) {
      logger3.warn(dedent6`
        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/react/essentials/controls#fully-custom-args
      `);
      return { name: "other", value: "cyclic object" };
    }
    visited.add(value);
    if (Array.isArray(value)) {
      const childType = value.length > 0 ? inferType(value[0], name, new Set(visited)) : { name: "other", value: "unknown" };
      return { name: "array", value: childType };
    }
    const fieldTypes = mapValues2(value, (field) => inferType(field, name, new Set(visited)));
    return { name: "object", value: fieldTypes };
  }
  return { name: "object", value: {} };
};
var inferArgTypes = (context) => {
  const { id, argTypes: userArgTypes = {}, initialArgs = {} } = context;
  const argTypes = mapValues2(initialArgs, (arg, key) => ({
    name: key,
    type: inferType(arg, `${id}.${key}`, /* @__PURE__ */ new Set())
  }));
  const userArgTypesNames = mapValues2(userArgTypes, (argType, key) => ({
    name: key
  }));
  return combineParameters(argTypes, userArgTypesNames, userArgTypes);
};
inferArgTypes.secondPass = true;

// src/inferControls.ts
import mapValues3 from "lodash/mapValues";
import { logger as logger4 } from "@storybook/client-logger";

// src/filterArgTypes.ts
import pickBy from "lodash/pickBy";
var matches = (name, descriptor) => Array.isArray(descriptor) ? descriptor.includes(name) : name.match(descriptor);
var filterArgTypes = (argTypes, include, exclude) => {
  if (!include && !exclude) {
    return argTypes;
  }
  return argTypes && pickBy(argTypes, (argType, key) => {
    const name = argType.name || key;
    return (!include || matches(name, include)) && (!exclude || !matches(name, exclude));
  });
};

// src/inferControls.ts
var inferControl = (argType, name, matchers) => {
  const { type, options } = argType;
  if (!type) {
    return void 0;
  }
  if (matchers.color && matchers.color.test(name)) {
    const controlType = type.name;
    if (controlType === "string") {
      return { control: { type: "color" } };
    }
    if (controlType !== "enum") {
      logger4.warn(
        `Addon controls: Control of type color only supports string, received "${controlType}" instead`
      );
    }
  }
  if (matchers.date && matchers.date.test(name)) {
    return { control: { type: "date" } };
  }
  switch (type.name) {
    case "array":
      return { control: { type: "object" } };
    case "boolean":
      return { control: { type: "boolean" } };
    case "string":
      return { control: { type: "text" } };
    case "number":
      return { control: { type: "number" } };
    case "enum": {
      const { value } = type;
      return { control: { type: value?.length <= 5 ? "radio" : "select" }, options: value };
    }
    case "function":
    case "symbol":
      return null;
    default:
      return { control: { type: options ? "select" : "object" } };
  }
};
var inferControls = (context) => {
  const {
    argTypes,
    parameters: { __isArgsStory, controls: { include = null, exclude = null, matchers = {} } = {} }
  } = context;
  if (!__isArgsStory)
    return argTypes;
  const filteredArgTypes = filterArgTypes(argTypes, include, exclude);
  const withControls = mapValues3(filteredArgTypes, (argType, name) => {
    return argType?.type && inferControl(argType, name, matchers);
  });
  return combineParameters(withControls, filteredArgTypes);
};
inferControls.secondPass = true;

// src/csf/normalizeProjectAnnotations.ts
function normalizeProjectAnnotations({
  argTypes,
  globalTypes,
  argTypesEnhancers,
  ...annotations
}) {
  return {
    ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
    ...globalTypes && { globalTypes: normalizeInputTypes(globalTypes) },
    argTypesEnhancers: [
      ...argTypesEnhancers || [],
      inferArgTypes,
      inferControls
    ],
    ...annotations
  };
}

// src/csf/stepRunners.ts
function composeStepRunners(stepRunners) {
  return async (label, play, playContext) => {
    const composedPlay = stepRunners.reduceRight(
      (innerPlay, stepRunner) => async () => stepRunner(label, innerPlay, playContext),
      async () => play(playContext)
    );
    await composedPlay();
  };
}

// src/csf/composeConfigs.ts
function getField(moduleExportList, field) {
  return moduleExportList.map((xs) => xs[field]).filter(Boolean);
}
function getArrayField(moduleExportList, field) {
  return getField(moduleExportList, field).reduce((a, b) => [...a, ...b], []);
}
function getObjectField(moduleExportList, field) {
  return Object.assign({}, ...getField(moduleExportList, field));
}
function getSingletonField(moduleExportList, field) {
  return getField(moduleExportList, field).pop();
}
function composeConfigs(moduleExportList) {
  const allArgTypeEnhancers = getArrayField(moduleExportList, "argTypesEnhancers");
  const stepRunners = getField(moduleExportList, "runStep");
  return {
    parameters: combineParameters(...getField(moduleExportList, "parameters")),
    decorators: getArrayField(moduleExportList, "decorators"),
    args: getObjectField(moduleExportList, "args"),
    argsEnhancers: getArrayField(moduleExportList, "argsEnhancers"),
    argTypes: getObjectField(moduleExportList, "argTypes"),
    argTypesEnhancers: [
      ...allArgTypeEnhancers.filter((e) => !e.secondPass),
      ...allArgTypeEnhancers.filter((e) => e.secondPass)
    ],
    globals: getObjectField(moduleExportList, "globals"),
    globalTypes: getObjectField(moduleExportList, "globalTypes"),
    loaders: getArrayField(moduleExportList, "loaders"),
    render: getSingletonField(moduleExportList, "render"),
    renderToDOM: getSingletonField(moduleExportList, "renderToDOM"),
    applyDecorators: getSingletonField(moduleExportList, "applyDecorators"),
    runStep: composeStepRunners(stepRunners)
  };
}

// src/csf/testing-utils/index.ts
import {
  isExportStory as isExportStory2
} from "@storybook/csf";
var GLOBAL_STORYBOOK_PROJECT_ANNOTATIONS = {};
function setProjectAnnotations(projectAnnotations) {
  const annotations = Array.isArray(projectAnnotations) ? projectAnnotations : [projectAnnotations];
  GLOBAL_STORYBOOK_PROJECT_ANNOTATIONS = composeConfigs(annotations);
}
function composeStory(storyAnnotations, componentAnnotations, projectAnnotations = GLOBAL_STORYBOOK_PROJECT_ANNOTATIONS, defaultConfig = {}, exportsName) {
  if (storyAnnotations === void 0) {
    throw new Error("Expected a story but received undefined.");
  }
  componentAnnotations.title = componentAnnotations.title ?? "ComposedStory";
  const normalizedComponentAnnotations = normalizeComponentAnnotations(componentAnnotations);
  const storyName = exportsName || storyAnnotations.storyName || storyAnnotations.story?.name || storyAnnotations.name || "unknown";
  const normalizedStory = normalizeStory(
    storyName,
    storyAnnotations,
    normalizedComponentAnnotations
  );
  const normalizedProjectAnnotations = normalizeProjectAnnotations({
    ...projectAnnotations,
    ...defaultConfig
  });
  const story = prepareStory(
    normalizedStory,
    normalizedComponentAnnotations,
    normalizedProjectAnnotations
  );
  const defaultGlobals = getValuesFromArgTypes(projectAnnotations.globalTypes);
  const composedStory = (extraArgs) => {
    const context = {
      ...story,
      hooks: new HooksContext(),
      globals: defaultGlobals,
      args: { ...story.initialArgs, ...extraArgs }
    };
    return story.unboundStoryFn(context);
  };
  composedStory.storyName = storyName;
  composedStory.args = story.initialArgs;
  composedStory.play = story.playFunction;
  composedStory.parameters = story.parameters;
  return composedStory;
}
function composeStories(storiesImport, globalConfig, composeStoryFn) {
  const { default: meta, __esModule, __namedExportsOrder, ...stories } = storiesImport;
  const composedStories = Object.entries(stories).reduce((storiesMap, [exportsName, story]) => {
    if (!isExportStory2(exportsName, meta)) {
      return storiesMap;
    }
    const result = Object.assign(storiesMap, {
      [exportsName]: composeStoryFn(
        story,
        meta,
        globalConfig,
        exportsName
      )
    });
    return result;
  }, {});
  return composedStories;
}

// src/StoryStore.ts
var CSF_CACHE_SIZE = 1e3;
var STORY_CACHE_SIZE = 1e4;
var StoryStore = class {
  constructor() {
    this.getStoriesJsonData = () => {
      const { storyIndex } = this;
      if (!storyIndex)
        throw new Error(`getStoriesJsonData called before initialization`);
      const value = this.getSetStoriesPayload();
      const allowedParameters = ["fileName", "docsOnly", "framework", "__id", "__isArgsStory"];
      const stories = mapValues4(value.stories, (story) => {
        const { importPath } = storyIndex.entries[story.id];
        return {
          ...pick(story, ["id", "name", "title"]),
          importPath,
          kind: story.title,
          story: story.name,
          parameters: {
            ...pick(story.parameters, allowedParameters),
            fileName: importPath
          }
        };
      });
      return {
        v: 3,
        stories
      };
    };
    this.args = new ArgsStore();
    this.hooks = {};
    this.processCSFFileWithCache = memoize2(CSF_CACHE_SIZE)(processCSFFile);
    this.prepareStoryWithCache = memoize2(STORY_CACHE_SIZE)(prepareStory);
    this.initializationPromise = new SynchronousPromise((resolve) => {
      this.resolveInitializationPromise = resolve;
    });
  }
  setProjectAnnotations(projectAnnotations) {
    this.projectAnnotations = normalizeProjectAnnotations(projectAnnotations);
    const { globals, globalTypes } = projectAnnotations;
    if (this.globals) {
      this.globals.set({ globals, globalTypes });
    } else {
      this.globals = new GlobalsStore({ globals, globalTypes });
    }
  }
  initialize({
    storyIndex,
    importFn,
    cache = false
  }) {
    this.storyIndex = new StoryIndexStore(storyIndex);
    this.importFn = importFn;
    this.resolveInitializationPromise();
    return cache ? this.cacheAllCSFFiles() : SynchronousPromise.resolve();
  }
  async onStoriesChanged({
    importFn,
    storyIndex
  }) {
    if (!this.storyIndex)
      throw new Error(`onStoriesChanged called before initialization`);
    if (importFn)
      this.importFn = importFn;
    if (storyIndex)
      this.storyIndex.entries = storyIndex.entries;
    if (this.cachedCSFFiles)
      await this.cacheAllCSFFiles();
  }
  async storyIdToEntry(storyId) {
    await this.initializationPromise;
    return this.storyIndex.storyIdToEntry(storyId);
  }
  loadCSFFileByStoryId(storyId) {
    if (!this.storyIndex || !this.importFn)
      throw new Error(`loadCSFFileByStoryId called before initialization`);
    const { importPath, title } = this.storyIndex.storyIdToEntry(storyId);
    return this.importFn(importPath).then(
      (moduleExports) => this.processCSFFileWithCache(moduleExports, importPath, title)
    );
  }
  loadAllCSFFiles() {
    if (!this.storyIndex)
      throw new Error(`loadAllCSFFiles called before initialization`);
    const importPaths = {};
    Object.entries(this.storyIndex.entries).forEach(([storyId, { importPath }]) => {
      importPaths[importPath] = storyId;
    });
    const csfFilePromiseList = Object.entries(importPaths).map(
      ([importPath, storyId]) => this.loadCSFFileByStoryId(storyId).then((csfFile) => ({
        importPath,
        csfFile
      }))
    );
    return SynchronousPromise.all(csfFilePromiseList).then(
      (list) => list.reduce((acc, { importPath, csfFile }) => {
        acc[importPath] = csfFile;
        return acc;
      }, {})
    );
  }
  cacheAllCSFFiles() {
    return this.initializationPromise.then(
      () => this.loadAllCSFFiles().then((csfFiles) => {
        this.cachedCSFFiles = csfFiles;
      })
    );
  }
  async loadStory({ storyId }) {
    await this.initializationPromise;
    const csfFile = await this.loadCSFFileByStoryId(storyId);
    return this.storyFromCSFFile({ storyId, csfFile });
  }
  storyFromCSFFile({
    storyId,
    csfFile
  }) {
    if (!this.projectAnnotations)
      throw new Error(`storyFromCSFFile called before initialization`);
    const storyAnnotations = csfFile.stories[storyId];
    if (!storyAnnotations) {
      throw new Error(`Didn't find '${storyId}' in CSF file, this is unexpected`);
    }
    const componentAnnotations = csfFile.meta;
    const story = this.prepareStoryWithCache(
      storyAnnotations,
      componentAnnotations,
      this.projectAnnotations
    );
    this.args.setInitial(story);
    this.hooks[story.id] = this.hooks[story.id] || new HooksContext();
    return story;
  }
  componentStoriesFromCSFFile({ csfFile }) {
    if (!this.storyIndex)
      throw new Error(`componentStoriesFromCSFFile called before initialization`);
    return Object.keys(this.storyIndex.entries).filter((storyId) => !!csfFile.stories[storyId]).map((storyId) => this.storyFromCSFFile({ storyId, csfFile }));
  }
  async loadEntry(id) {
    const entry = await this.storyIdToEntry(id);
    const { importFn, storyIndex } = this;
    if (!storyIndex || !importFn)
      throw new Error(`loadEntry called before initialization`);
    const storyImports = entry.type === "docs" ? entry.storiesImports : [];
    const [entryExports, ...csfFiles] = await Promise.all([
      importFn(entry.importPath),
      ...storyImports.map((storyImportPath) => {
        const firstStoryEntry = storyIndex.importPathToEntry(storyImportPath);
        return this.loadCSFFileByStoryId(firstStoryEntry.id);
      })
    ]);
    return { entryExports, csfFiles };
  }
  getStoryContext(story) {
    if (!this.globals)
      throw new Error(`getStoryContext called before initialization`);
    return {
      ...story,
      args: this.args.get(story.id),
      globals: this.globals.get(),
      hooks: this.hooks[story.id]
    };
  }
  cleanupStory(story) {
    this.hooks[story.id].clean();
  }
  extract(options = { includeDocsOnly: false }) {
    if (!this.storyIndex)
      throw new Error(`extract called before initialization`);
    const { cachedCSFFiles } = this;
    if (!cachedCSFFiles)
      throw new Error("Cannot call extract() unless you call cacheAllCSFFiles() first.");
    return Object.entries(this.storyIndex.entries).reduce(
      (acc, [storyId, { type, importPath }]) => {
        if (type === "docs")
          return acc;
        const csfFile = cachedCSFFiles[importPath];
        const story = this.storyFromCSFFile({ storyId, csfFile });
        if (!options.includeDocsOnly && story.parameters.docsOnly) {
          return acc;
        }
        acc[storyId] = Object.entries(story).reduce(
          (storyAcc, [key, value]) => {
            if (key === "moduleExport")
              return storyAcc;
            if (typeof value === "function") {
              return storyAcc;
            }
            if (Array.isArray(value)) {
              return Object.assign(storyAcc, { [key]: value.slice().sort() });
            }
            return Object.assign(storyAcc, { [key]: value });
          },
          { args: story.initialArgs }
        );
        return acc;
      },
      {}
    );
  }
  getSetStoriesPayload() {
    if (!this.globals)
      throw new Error(`getSetStoriesPayload called before initialization`);
    const stories = this.extract({ includeDocsOnly: true });
    const kindParameters = Object.values(stories).reduce(
      (acc, { title }) => {
        acc[title] = {};
        return acc;
      },
      {}
    );
    return {
      v: 2,
      globals: this.globals.get(),
      globalParameters: {},
      kindParameters,
      stories
    };
  }
  raw() {
    return Object.values(this.extract()).map(({ id }) => this.fromId(id)).filter(Boolean);
  }
  fromId(storyId) {
    if (!this.storyIndex)
      throw new Error(`fromId called before initialization`);
    if (!this.cachedCSFFiles)
      throw new Error("Cannot call fromId/raw() unless you call cacheAllCSFFiles() first.");
    let importPath;
    try {
      ({ importPath } = this.storyIndex.storyIdToEntry(storyId));
    } catch (err) {
      return null;
    }
    const csfFile = this.cachedCSFFiles[importPath];
    const story = this.storyFromCSFFile({ storyId, csfFile });
    return {
      ...story,
      storyFn: (update) => {
        const context = {
          ...this.getStoryContext(story),
          viewMode: "story"
        };
        return story.unboundStoryFn({ ...context, ...update });
      }
    };
  }
};

// src/autoTitle.ts
import slash from "slash";
import { dedent as dedent7 } from "ts-dedent";
import { once as once2 } from "@storybook/client-logger";
var stripExtension = (path) => {
  let parts = [...path];
  const last = parts[parts.length - 1];
  const dotIndex = last.indexOf(".");
  const stripped = dotIndex > 0 ? last.substr(0, dotIndex) : last;
  parts[parts.length - 1] = stripped;
  const [first, ...rest] = parts;
  if (first === "") {
    parts = rest;
  }
  return parts;
};
var indexRe = /^index$/i;
var removeRedundantFilename = (paths) => {
  let prevVal;
  return paths.filter((val, index) => {
    if (index === paths.length - 1 && (val === prevVal || indexRe.test(val))) {
      return false;
    }
    prevVal = val;
    return true;
  });
};
function pathJoin(paths) {
  const slashes = new RegExp("/{1,}", "g");
  return paths.join("/").replace(slashes, "/");
}
var userOrAutoTitleFromSpecifier = (fileName, entry, userTitle) => {
  const { directory, importPathMatcher, titlePrefix = "" } = entry || {};
  if (typeof fileName === "number") {
    once2.warn(dedent7`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  }
  const normalizedFileName = slash(String(fileName));
  if (importPathMatcher.exec(normalizedFileName)) {
    if (!userTitle) {
      const suffix = normalizedFileName.replace(directory, "");
      const titleAndSuffix = slash(pathJoin([titlePrefix, suffix]));
      let path = titleAndSuffix.split("/");
      path = stripExtension(path);
      path = removeRedundantFilename(path);
      return path.join("/");
    }
    if (!titlePrefix) {
      return userTitle;
    }
    return slash(pathJoin([titlePrefix, userTitle]));
  }
  return void 0;
};
var userOrAutoTitle = (fileName, storiesEntries, userTitle) => {
  for (let i = 0; i < storiesEntries.length; i += 1) {
    const title = userOrAutoTitleFromSpecifier(fileName, storiesEntries[i], userTitle);
    if (title)
      return title;
  }
  return userTitle || void 0;
};

// src/sortStories.ts
import { dedent as dedent8 } from "ts-dedent";

// src/storySort.ts
var STORY_KIND_PATH_SEPARATOR = /\s*\/\s*/;
var storySort = (options = {}) => (a, b) => {
  if (a.title === b.title && !options.includeNames) {
    return 0;
  }
  const method = options.method || "configure";
  let order = options.order || [];
  const storyTitleA = a.title.trim().split(STORY_KIND_PATH_SEPARATOR);
  const storyTitleB = b.title.trim().split(STORY_KIND_PATH_SEPARATOR);
  if (options.includeNames) {
    storyTitleA.push(a.name);
    storyTitleB.push(b.name);
  }
  let depth = 0;
  while (storyTitleA[depth] || storyTitleB[depth]) {
    if (!storyTitleA[depth]) {
      return -1;
    }
    if (!storyTitleB[depth]) {
      return 1;
    }
    const nameA = storyTitleA[depth];
    const nameB = storyTitleB[depth];
    if (nameA !== nameB) {
      let indexA = order.indexOf(nameA);
      let indexB = order.indexOf(nameB);
      const indexWildcard = order.indexOf("*");
      if (indexA !== -1 || indexB !== -1) {
        if (indexA === -1) {
          if (indexWildcard !== -1) {
            indexA = indexWildcard;
          } else {
            indexA = order.length;
          }
        }
        if (indexB === -1) {
          if (indexWildcard !== -1) {
            indexB = indexWildcard;
          } else {
            indexB = order.length;
          }
        }
        return indexA - indexB;
      }
      if (method === "configure") {
        return 0;
      }
      return nameA.localeCompare(nameB, options.locales ? options.locales : void 0, {
        numeric: true,
        sensitivity: "accent"
      });
    }
    let index = order.indexOf(nameA);
    if (index === -1)
      index = order.indexOf("*");
    order = index !== -1 && Array.isArray(order[index + 1]) ? order[index + 1] : [];
    depth += 1;
  }
  return 0;
};

// src/sortStories.ts
var sortStoriesCommon = (stories, storySortParameter, fileNameOrder) => {
  if (storySortParameter) {
    let sortFn;
    if (typeof storySortParameter === "function") {
      sortFn = storySortParameter;
    } else {
      sortFn = storySort(storySortParameter);
    }
    stories.sort(sortFn);
  } else {
    stories.sort(
      (s1, s2) => fileNameOrder.indexOf(s1.importPath) - fileNameOrder.indexOf(s2.importPath)
    );
  }
  return stories;
};
var sortStoriesV7 = (stories, storySortParameter, fileNameOrder) => {
  try {
    return sortStoriesCommon(stories, storySortParameter, fileNameOrder);
  } catch (err) {
    throw new Error(dedent8`
    Error sorting stories with sort parameter ${storySortParameter}:

    > ${err.message}
    
    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
  }
};
var toIndexEntry = (story) => {
  const { id, title, name, parameters, type } = story;
  return { id, title, name, importPath: parameters.fileName, type };
};
var sortStoriesV6 = (stories, storySortParameter, fileNameOrder) => {
  if (storySortParameter && typeof storySortParameter === "function") {
    stories.sort(storySortParameter);
    return stories.map((s) => toIndexEntry(s[1]));
  }
  const storiesV7 = stories.map((s) => toIndexEntry(s[1]));
  return sortStoriesCommon(storiesV7, storySortParameter, fileNameOrder);
};
export {
  DEEPLY_EQUAL,
  HooksContext,
  NO_TARGET_NAME,
  StoryStore,
  applyHooks,
  combineArgs,
  combineParameters,
  composeConfigs,
  composeStepRunners,
  composeStories,
  composeStory,
  decorateStory,
  deepDiff,
  defaultDecorateStory,
  filterArgTypes,
  getArrayField,
  getField,
  getObjectField,
  getSingletonField,
  getValuesFromArgTypes,
  groupArgsByTarget,
  inferControls,
  mapArgsToTypes,
  noTargetArgs,
  normalizeComponentAnnotations,
  normalizeInputType,
  normalizeInputTypes,
  normalizeProjectAnnotations,
  normalizeStory,
  prepareStory,
  processCSFFile,
  sanitizeStoryContextUpdate,
  setProjectAnnotations,
  sortStoriesV6,
  sortStoriesV7,
  useAddonState,
  useArgs,
  useCallback,
  useChannel,
  useEffect,
  useGlobals,
  useMemo,
  useParameter,
  useReducer,
  useRef,
  useSharedState,
  useState,
  useStoryContext,
  userOrAutoTitle,
  userOrAutoTitleFromSpecifier,
  validateOptions
};
