// src/ClientApi.ts
import deprecate2 from "util-deprecate";
import { dedent as dedent2 } from "ts-dedent";
import global2 from "global";
import { logger as logger2 } from "@storybook/client-logger";
import { toId as toId2, sanitize } from "@storybook/csf";
import {
  combineParameters,
  composeStepRunners,
  normalizeInputTypes
} from "@storybook/store";

// src/StoryStoreFacade.ts
import global from "global";
import { dedent } from "ts-dedent";
import { SynchronousPromise } from "synchronous-promise";
import {
  toId,
  isExportStory,
  storyNameFromExport
} from "@storybook/csf";
import { userOrAutoTitle, sortStoriesV6 } from "@storybook/store";
import { logger } from "@storybook/client-logger";
import deprecate from "util-deprecate";
var docs2Warning = deprecate(
  () => {
  },
  `You cannot use \`.mdx\` files without using \`storyStoreV7\`. Consider upgrading to the new store.`
);
var StoryStoreFacade = class {
  constructor() {
    this.projectAnnotations = {
      loaders: [],
      decorators: [],
      parameters: {},
      argsEnhancers: [],
      argTypesEnhancers: [],
      args: {},
      argTypes: {}
    };
    this.entries = {};
    this.csfExports = {};
  }
  importFn(path) {
    return SynchronousPromise.resolve().then(() => {
      const moduleExports = this.csfExports[path];
      if (!moduleExports)
        throw new Error(`Unknown path: ${path}`);
      return moduleExports;
    });
  }
  getStoryIndex(store) {
    const fileNameOrder = Object.keys(this.csfExports);
    const storySortParameter = this.projectAnnotations.parameters?.options?.storySort;
    const storyEntries = Object.entries(this.entries);
    const sortableV6 = storyEntries.map(
      ([storyId, { type, importPath, ...entry }]) => {
        const exports = this.csfExports[importPath];
        const csfFile = store.processCSFFileWithCache(
          exports,
          importPath,
          exports.default.title
        );
        let storyLike;
        if (type === "story") {
          storyLike = store.storyFromCSFFile({ storyId, csfFile });
        } else {
          storyLike = {
            ...entry,
            story: entry.name,
            kind: entry.title,
            componentId: toId(entry.componentId || entry.title),
            parameters: { fileName: importPath }
          };
        }
        return [storyId, storyLike, csfFile.meta.parameters, this.projectAnnotations.parameters];
      }
    );
    let sortedV7;
    try {
      sortedV7 = sortStoriesV6(sortableV6, storySortParameter, fileNameOrder);
    } catch (err) {
      if (typeof storySortParameter === "function") {
        throw new Error(dedent`
          Error sorting stories with sort parameter ${storySortParameter}:

          > ${err.message}
          
          Are you using a V7-style sort function in V6 compatibility mode?
          
          More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
        `);
      }
      throw err;
    }
    const entries = sortedV7.reduce((acc, s) => {
      acc[s.id] = this.entries[s.id];
      return acc;
    }, {});
    return { v: 4, entries };
  }
  clearFilenameExports(fileName) {
    if (!this.csfExports[fileName]) {
      return;
    }
    Object.entries(this.entries).forEach(([id, { importPath }]) => {
      if (importPath === fileName) {
        delete this.entries[id];
      }
    });
    this.csfExports[fileName] = {};
  }
  addStoriesFromExports(fileName, fileExports) {
    if (fileName.match(/\.mdx$/) && !fileName.match(/\.stories\.mdx$/)) {
      docs2Warning();
      return;
    }
    if (this.csfExports[fileName] === fileExports) {
      return;
    }
    this.clearFilenameExports(fileName);
    const { default: defaultExport, __namedExportsOrder, ...namedExports } = fileExports;
    let { id: componentId, title } = defaultExport || {};
    const specifiers = (global.STORIES || []).map(
      (specifier) => ({
        ...specifier,
        importPathMatcher: new RegExp(specifier.importPathMatcher)
      })
    );
    title = userOrAutoTitle(fileName, specifiers, title);
    if (!title) {
      logger.info(
        `Unexpected default export without title in '${fileName}': ${JSON.stringify(
          fileExports.default
        )}`
      );
      return;
    }
    this.csfExports[fileName] = {
      ...fileExports,
      default: { ...defaultExport, title }
    };
    let sortedExports = namedExports;
    if (Array.isArray(__namedExportsOrder)) {
      sortedExports = {};
      __namedExportsOrder.forEach((name) => {
        const namedExport = namedExports[name];
        if (namedExport)
          sortedExports[name] = namedExport;
      });
    }
    const docsOptions = global.DOCS_OPTIONS || {};
    const seenTitles = /* @__PURE__ */ new Set();
    Object.entries(sortedExports).filter(([key]) => isExportStory(key, defaultExport)).forEach(([key, storyExport]) => {
      const exportName = storyNameFromExport(key);
      const id = storyExport.parameters?.__id || toId(componentId || title, exportName);
      const name = typeof storyExport !== "function" && storyExport.name || storyExport.storyName || storyExport.story?.name || exportName;
      if (!seenTitles.has(title) && docsOptions.docsPage) {
        const name2 = docsOptions.defaultName;
        const docsId = toId(componentId || title, name2);
        seenTitles.add(title);
        this.entries[docsId] = {
          type: "docs",
          standalone: false,
          id: docsId,
          title,
          name: name2,
          importPath: fileName,
          storiesImports: [],
          componentId
        };
      }
      this.entries[id] = {
        type: "story",
        id,
        name,
        title,
        importPath: fileName,
        componentId
      };
    });
  }
};

// src/ClientApi.ts
var singleton;
var warningAlternatives = {
  addDecorator: `Instead, use \`export const decorators = [];\` in your \`preview.js\`.`,
  addParameters: `Instead, use \`export const parameters = {};\` in your \`preview.js\`.`,
  addLoaders: `Instead, use \`export const loaders = [];\` in your \`preview.js\`.`
};
var warningMessage = (method) => deprecate2(
  () => {
  },
  dedent2`
  \`${method}\` is deprecated, and will be removed in Storybook 7.0.

  ${warningAlternatives[method]}

  Read more at https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-addparameters-and-adddecorator).`
);
var warnings = {
  addDecorator: warningMessage("addDecorator"),
  addParameters: warningMessage("addParameters"),
  addLoaders: warningMessage("addLoaders")
};
var checkMethod = (method, deprecationWarning) => {
  if (global2.FEATURES?.storyStoreV7) {
    throw new Error(
      dedent2`You cannot use \`${method}\` with the new Story Store.

      ${warningAlternatives[method]}`
    );
  }
  if (!singleton) {
    throw new Error(`Singleton client API not yet initialized, cannot call \`${method}\`.`);
  }
  if (deprecationWarning) {
    warnings[method]();
  }
};
var addDecorator = (decorator, deprecationWarning = true) => {
  checkMethod("addDecorator", deprecationWarning);
  singleton.addDecorator(decorator);
};
var addParameters = (parameters, deprecationWarning = true) => {
  checkMethod("addParameters", deprecationWarning);
  singleton.addParameters(parameters);
};
var addLoader = (loader, deprecationWarning = true) => {
  checkMethod("addLoader", deprecationWarning);
  singleton.addLoader(loader);
};
var addArgs = (args) => {
  checkMethod("addArgs", false);
  singleton.addArgs(args);
};
var addArgTypes = (argTypes) => {
  checkMethod("addArgTypes", false);
  singleton.addArgTypes(argTypes);
};
var addArgsEnhancer = (enhancer) => {
  checkMethod("addArgsEnhancer", false);
  singleton.addArgsEnhancer(enhancer);
};
var addArgTypesEnhancer = (enhancer) => {
  checkMethod("addArgTypesEnhancer", false);
  singleton.addArgTypesEnhancer(enhancer);
};
var addStepRunner = (stepRunner) => {
  checkMethod("addStepRunner", false);
  singleton.addStepRunner(stepRunner);
};
var setGlobalRender = (render) => {
  checkMethod("setGlobalRender", false);
  singleton.facade.projectAnnotations.render = render;
};
var invalidStoryTypes = /* @__PURE__ */ new Set(["string", "number", "boolean", "symbol"]);
var ClientApi = class {
  constructor({ storyStore } = {}) {
    this.lastFileName = 0;
    this.setAddon = deprecate2(
      (addon) => {
        this.addons = { ...this.addons, ...addon };
      },
      dedent2`
      \`setAddon\` is deprecated and will be removed in Storybook 7.0.

      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-setaddon
    `
    );
    this.addDecorator = (decorator) => {
      this.facade.projectAnnotations.decorators.push(decorator);
    };
    this.clearDecorators = deprecate2(
      () => {
        this.facade.projectAnnotations.decorators = [];
      },
      dedent2`
      \`clearDecorators\` is deprecated and will be removed in Storybook 7.0.

      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-cleardecorators
    `
    );
    this.addParameters = ({
      globals,
      globalTypes,
      ...parameters
    }) => {
      this.facade.projectAnnotations.parameters = combineParameters(
        this.facade.projectAnnotations.parameters,
        parameters
      );
      if (globals) {
        this.facade.projectAnnotations.globals = {
          ...this.facade.projectAnnotations.globals,
          ...globals
        };
      }
      if (globalTypes) {
        this.facade.projectAnnotations.globalTypes = {
          ...this.facade.projectAnnotations.globalTypes,
          ...normalizeInputTypes(globalTypes)
        };
      }
    };
    this.addStepRunner = (stepRunner) => {
      this.facade.projectAnnotations.runStep = composeStepRunners(
        [this.facade.projectAnnotations.runStep, stepRunner].filter(Boolean)
      );
    };
    this.addLoader = (loader) => {
      this.facade.projectAnnotations.loaders.push(loader);
    };
    this.addArgs = (args) => {
      this.facade.projectAnnotations.args = {
        ...this.facade.projectAnnotations.args,
        ...args
      };
    };
    this.addArgTypes = (argTypes) => {
      this.facade.projectAnnotations.argTypes = {
        ...this.facade.projectAnnotations.argTypes,
        ...normalizeInputTypes(argTypes)
      };
    };
    this.addArgsEnhancer = (enhancer) => {
      this.facade.projectAnnotations.argsEnhancers.push(enhancer);
    };
    this.addArgTypesEnhancer = (enhancer) => {
      this.facade.projectAnnotations.argTypesEnhancers.push(enhancer);
    };
    this.storiesOf = (kind, m) => {
      if (!kind && typeof kind !== "string") {
        throw new Error("Invalid or missing kind provided for stories, should be a string");
      }
      if (!m) {
        logger2.warn(
          `Missing 'module' parameter for story with a kind of '${kind}'. It will break your HMR`
        );
      }
      if (m) {
        const proto = Object.getPrototypeOf(m);
        if (proto.exports && proto.exports.default) {
          logger2.error(
            `Illegal mix of CSF default export and storiesOf calls in a single file: ${proto.i}`
          );
        }
      }
      const baseFilename = m && m.id ? `${m.id}` : (this.lastFileName++).toString();
      let fileName = baseFilename;
      let i = 1;
      while (this.facade.csfExports[fileName] && Object.keys(this.facade.csfExports[fileName]).length > 0) {
        i += 1;
        fileName = `${baseFilename}-${i}`;
      }
      if (m && m.hot && m.hot.accept) {
        m.hot.accept();
        m.hot.dispose(() => {
          this.facade.clearFilenameExports(fileName);
          setTimeout(() => {
            this.onImportFnChanged?.({ importFn: this.importFn.bind(this) });
          }, 0);
        });
      }
      let hasAdded = false;
      const api = {
        kind: kind.toString(),
        add: () => api,
        addDecorator: () => api,
        addLoader: () => api,
        addParameters: () => api
      };
      Object.keys(this.addons).forEach((name) => {
        const addon = this.addons[name];
        api[name] = (...args) => {
          addon.apply(api, args);
          return api;
        };
      });
      const meta = {
        id: sanitize(kind),
        title: kind,
        decorators: [],
        loaders: [],
        parameters: {}
      };
      this.facade.csfExports[fileName] = { default: meta };
      let counter = 0;
      api.add = (storyName, storyFn, parameters = {}) => {
        hasAdded = true;
        if (typeof storyName !== "string") {
          throw new Error(`Invalid or missing storyName provided for a "${kind}" story.`);
        }
        if (!storyFn || Array.isArray(storyFn) || invalidStoryTypes.has(typeof storyFn)) {
          throw new Error(
            `Cannot load story "${storyName}" in "${kind}" due to invalid format. Storybook expected a function/object but received ${typeof storyFn} instead.`
          );
        }
        const { decorators, loaders, component, args, argTypes, ...storyParameters } = parameters;
        const storyId = parameters.__id || toId2(kind, storyName);
        const csfExports = this.facade.csfExports[fileName];
        csfExports[`story${counter}`] = {
          name: storyName,
          parameters: { fileName, __id: storyId, ...storyParameters },
          decorators,
          loaders,
          args,
          argTypes,
          component,
          render: storyFn
        };
        counter += 1;
        this.facade.entries[storyId] = {
          id: storyId,
          title: csfExports.default.title,
          name: storyName,
          importPath: fileName,
          type: "story"
        };
        return api;
      };
      api.addDecorator = (decorator) => {
        if (hasAdded)
          throw new Error(`You cannot add a decorator after the first story for a kind.
Read more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);
        meta.decorators.push(decorator);
        return api;
      };
      api.addLoader = (loader) => {
        if (hasAdded)
          throw new Error(`You cannot add a loader after the first story for a kind.`);
        meta.loaders.push(loader);
        return api;
      };
      api.addParameters = ({ component, args, argTypes, ...parameters }) => {
        if (hasAdded)
          throw new Error(`You cannot add parameters after the first story for a kind.
Read more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);
        meta.parameters = combineParameters(meta.parameters, parameters);
        if (component)
          meta.component = component;
        if (args)
          meta.args = { ...meta.args, ...args };
        if (argTypes)
          meta.argTypes = { ...meta.argTypes, ...argTypes };
        return api;
      };
      return api;
    };
    this.getStorybook = () => {
      const { entries } = this.storyStore.storyIndex;
      const kinds = {};
      Object.entries(entries).forEach(([storyId, { title, name, importPath, type }]) => {
        if (type && type !== "story")
          return;
        if (!kinds[title]) {
          kinds[title] = { kind: title, fileName: importPath, stories: [] };
        }
        const { storyFn } = this.storyStore.fromId(storyId);
        kinds[title].stories.push({ name, render: storyFn });
      });
      return Object.values(kinds);
    };
    this.raw = () => {
      return this.storyStore.raw();
    };
    this.facade = new StoryStoreFacade();
    this.addons = {};
    this.storyStore = storyStore;
    singleton = this;
  }
  importFn(path) {
    return this.facade.importFn(path);
  }
  getStoryIndex() {
    if (!this.storyStore) {
      throw new Error("Cannot get story index before setting storyStore");
    }
    return this.facade.getStoryIndex(this.storyStore);
  }
  get _storyStore() {
    return this.storyStore;
  }
};

// src/queryparams.ts
import global3 from "global";
import { parse } from "qs";
var { document } = global3;
var getQueryParams = () => {
  if (document && document.location && document.location.search) {
    return parse(document.location.search, { ignoreQueryPrefix: true });
  }
  return {};
};
var getQueryParam = (key) => {
  const params = getQueryParams();
  return params[key];
};

// src/index.ts
export * from "@storybook/store";
export {
  ClientApi,
  addArgTypes,
  addArgTypesEnhancer,
  addArgs,
  addArgsEnhancer,
  addDecorator,
  addLoader,
  addParameters,
  addStepRunner,
  getQueryParam,
  getQueryParams,
  setGlobalRender
};
