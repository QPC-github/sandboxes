var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ClientApi: () => ClientApi,
  addArgTypes: () => addArgTypes,
  addArgTypesEnhancer: () => addArgTypesEnhancer,
  addArgs: () => addArgs,
  addArgsEnhancer: () => addArgsEnhancer,
  addDecorator: () => addDecorator,
  addLoader: () => addLoader,
  addParameters: () => addParameters,
  addStepRunner: () => addStepRunner,
  getQueryParam: () => getQueryParam,
  getQueryParams: () => getQueryParams,
  setGlobalRender: () => setGlobalRender
});
module.exports = __toCommonJS(src_exports);

// src/ClientApi.ts
var import_util_deprecate2 = __toESM(require("util-deprecate"));
var import_ts_dedent2 = require("ts-dedent");
var import_global2 = __toESM(require("global"));
var import_client_logger2 = require("@storybook/client-logger");
var import_csf2 = require("@storybook/csf");
var import_store2 = require("@storybook/store");

// src/StoryStoreFacade.ts
var import_global = __toESM(require("global"));
var import_ts_dedent = require("ts-dedent");
var import_synchronous_promise = require("synchronous-promise");
var import_csf = require("@storybook/csf");
var import_store = require("@storybook/store");
var import_client_logger = require("@storybook/client-logger");
var import_util_deprecate = __toESM(require("util-deprecate"));
var docs2Warning = (0, import_util_deprecate.default)(
  () => {
  },
  `You cannot use \`.mdx\` files without using \`storyStoreV7\`. Consider upgrading to the new store.`
);
var StoryStoreFacade = class {
  constructor() {
    this.projectAnnotations = {
      loaders: [],
      decorators: [],
      parameters: {},
      argsEnhancers: [],
      argTypesEnhancers: [],
      args: {},
      argTypes: {}
    };
    this.entries = {};
    this.csfExports = {};
  }
  importFn(path) {
    return import_synchronous_promise.SynchronousPromise.resolve().then(() => {
      const moduleExports = this.csfExports[path];
      if (!moduleExports)
        throw new Error(`Unknown path: ${path}`);
      return moduleExports;
    });
  }
  getStoryIndex(store) {
    var _a, _b;
    const fileNameOrder = Object.keys(this.csfExports);
    const storySortParameter = (_b = (_a = this.projectAnnotations.parameters) == null ? void 0 : _a.options) == null ? void 0 : _b.storySort;
    const storyEntries = Object.entries(this.entries);
    const sortableV6 = storyEntries.map(
      ([storyId, { type, importPath, ...entry }]) => {
        const exports = this.csfExports[importPath];
        const csfFile = store.processCSFFileWithCache(
          exports,
          importPath,
          exports.default.title
        );
        let storyLike;
        if (type === "story") {
          storyLike = store.storyFromCSFFile({ storyId, csfFile });
        } else {
          storyLike = {
            ...entry,
            story: entry.name,
            kind: entry.title,
            componentId: (0, import_csf.toId)(entry.componentId || entry.title),
            parameters: { fileName: importPath }
          };
        }
        return [storyId, storyLike, csfFile.meta.parameters, this.projectAnnotations.parameters];
      }
    );
    let sortedV7;
    try {
      sortedV7 = (0, import_store.sortStoriesV6)(sortableV6, storySortParameter, fileNameOrder);
    } catch (err) {
      if (typeof storySortParameter === "function") {
        throw new Error(import_ts_dedent.dedent`
          Error sorting stories with sort parameter ${storySortParameter}:

          > ${err.message}
          
          Are you using a V7-style sort function in V6 compatibility mode?
          
          More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
        `);
      }
      throw err;
    }
    const entries = sortedV7.reduce((acc, s) => {
      acc[s.id] = this.entries[s.id];
      return acc;
    }, {});
    return { v: 4, entries };
  }
  clearFilenameExports(fileName) {
    if (!this.csfExports[fileName]) {
      return;
    }
    Object.entries(this.entries).forEach(([id, { importPath }]) => {
      if (importPath === fileName) {
        delete this.entries[id];
      }
    });
    this.csfExports[fileName] = {};
  }
  addStoriesFromExports(fileName, fileExports) {
    if (fileName.match(/\.mdx$/) && !fileName.match(/\.stories\.mdx$/)) {
      docs2Warning();
      return;
    }
    if (this.csfExports[fileName] === fileExports) {
      return;
    }
    this.clearFilenameExports(fileName);
    const { default: defaultExport, __namedExportsOrder, ...namedExports } = fileExports;
    let { id: componentId, title } = defaultExport || {};
    const specifiers = (import_global.default.STORIES || []).map(
      (specifier) => ({
        ...specifier,
        importPathMatcher: new RegExp(specifier.importPathMatcher)
      })
    );
    title = (0, import_store.userOrAutoTitle)(fileName, specifiers, title);
    if (!title) {
      import_client_logger.logger.info(
        `Unexpected default export without title in '${fileName}': ${JSON.stringify(
          fileExports.default
        )}`
      );
      return;
    }
    this.csfExports[fileName] = {
      ...fileExports,
      default: { ...defaultExport, title }
    };
    let sortedExports = namedExports;
    if (Array.isArray(__namedExportsOrder)) {
      sortedExports = {};
      __namedExportsOrder.forEach((name) => {
        const namedExport = namedExports[name];
        if (namedExport)
          sortedExports[name] = namedExport;
      });
    }
    const docsOptions = import_global.default.DOCS_OPTIONS || {};
    const seenTitles = /* @__PURE__ */ new Set();
    Object.entries(sortedExports).filter(([key]) => (0, import_csf.isExportStory)(key, defaultExport)).forEach(([key, storyExport]) => {
      var _a, _b;
      const exportName = (0, import_csf.storyNameFromExport)(key);
      const id = ((_a = storyExport.parameters) == null ? void 0 : _a.__id) || (0, import_csf.toId)(componentId || title, exportName);
      const name = typeof storyExport !== "function" && storyExport.name || storyExport.storyName || ((_b = storyExport.story) == null ? void 0 : _b.name) || exportName;
      if (!seenTitles.has(title) && docsOptions.docsPage) {
        const name2 = docsOptions.defaultName;
        const docsId = (0, import_csf.toId)(componentId || title, name2);
        seenTitles.add(title);
        this.entries[docsId] = {
          type: "docs",
          standalone: false,
          id: docsId,
          title,
          name: name2,
          importPath: fileName,
          storiesImports: [],
          componentId
        };
      }
      this.entries[id] = {
        type: "story",
        id,
        name,
        title,
        importPath: fileName,
        componentId
      };
    });
  }
};

// src/ClientApi.ts
var singleton;
var warningAlternatives = {
  addDecorator: `Instead, use \`export const decorators = [];\` in your \`preview.js\`.`,
  addParameters: `Instead, use \`export const parameters = {};\` in your \`preview.js\`.`,
  addLoaders: `Instead, use \`export const loaders = [];\` in your \`preview.js\`.`
};
var warningMessage = (method) => (0, import_util_deprecate2.default)(
  () => {
  },
  import_ts_dedent2.dedent`
  \`${method}\` is deprecated, and will be removed in Storybook 7.0.

  ${warningAlternatives[method]}

  Read more at https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-addparameters-and-adddecorator).`
);
var warnings = {
  addDecorator: warningMessage("addDecorator"),
  addParameters: warningMessage("addParameters"),
  addLoaders: warningMessage("addLoaders")
};
var checkMethod = (method, deprecationWarning) => {
  var _a;
  if ((_a = import_global2.default.FEATURES) == null ? void 0 : _a.storyStoreV7) {
    throw new Error(
      import_ts_dedent2.dedent`You cannot use \`${method}\` with the new Story Store.

      ${warningAlternatives[method]}`
    );
  }
  if (!singleton) {
    throw new Error(`Singleton client API not yet initialized, cannot call \`${method}\`.`);
  }
  if (deprecationWarning) {
    warnings[method]();
  }
};
var addDecorator = (decorator, deprecationWarning = true) => {
  checkMethod("addDecorator", deprecationWarning);
  singleton.addDecorator(decorator);
};
var addParameters = (parameters, deprecationWarning = true) => {
  checkMethod("addParameters", deprecationWarning);
  singleton.addParameters(parameters);
};
var addLoader = (loader, deprecationWarning = true) => {
  checkMethod("addLoader", deprecationWarning);
  singleton.addLoader(loader);
};
var addArgs = (args) => {
  checkMethod("addArgs", false);
  singleton.addArgs(args);
};
var addArgTypes = (argTypes) => {
  checkMethod("addArgTypes", false);
  singleton.addArgTypes(argTypes);
};
var addArgsEnhancer = (enhancer) => {
  checkMethod("addArgsEnhancer", false);
  singleton.addArgsEnhancer(enhancer);
};
var addArgTypesEnhancer = (enhancer) => {
  checkMethod("addArgTypesEnhancer", false);
  singleton.addArgTypesEnhancer(enhancer);
};
var addStepRunner = (stepRunner) => {
  checkMethod("addStepRunner", false);
  singleton.addStepRunner(stepRunner);
};
var setGlobalRender = (render) => {
  checkMethod("setGlobalRender", false);
  singleton.facade.projectAnnotations.render = render;
};
var invalidStoryTypes = /* @__PURE__ */ new Set(["string", "number", "boolean", "symbol"]);
var ClientApi = class {
  constructor({ storyStore } = {}) {
    this.lastFileName = 0;
    this.setAddon = (0, import_util_deprecate2.default)(
      (addon) => {
        this.addons = { ...this.addons, ...addon };
      },
      import_ts_dedent2.dedent`
      \`setAddon\` is deprecated and will be removed in Storybook 7.0.

      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-setaddon
    `
    );
    this.addDecorator = (decorator) => {
      this.facade.projectAnnotations.decorators.push(decorator);
    };
    this.clearDecorators = (0, import_util_deprecate2.default)(
      () => {
        this.facade.projectAnnotations.decorators = [];
      },
      import_ts_dedent2.dedent`
      \`clearDecorators\` is deprecated and will be removed in Storybook 7.0.

      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-cleardecorators
    `
    );
    this.addParameters = ({
      globals,
      globalTypes,
      ...parameters
    }) => {
      this.facade.projectAnnotations.parameters = (0, import_store2.combineParameters)(
        this.facade.projectAnnotations.parameters,
        parameters
      );
      if (globals) {
        this.facade.projectAnnotations.globals = {
          ...this.facade.projectAnnotations.globals,
          ...globals
        };
      }
      if (globalTypes) {
        this.facade.projectAnnotations.globalTypes = {
          ...this.facade.projectAnnotations.globalTypes,
          ...(0, import_store2.normalizeInputTypes)(globalTypes)
        };
      }
    };
    this.addStepRunner = (stepRunner) => {
      this.facade.projectAnnotations.runStep = (0, import_store2.composeStepRunners)(
        [this.facade.projectAnnotations.runStep, stepRunner].filter(Boolean)
      );
    };
    this.addLoader = (loader) => {
      this.facade.projectAnnotations.loaders.push(loader);
    };
    this.addArgs = (args) => {
      this.facade.projectAnnotations.args = {
        ...this.facade.projectAnnotations.args,
        ...args
      };
    };
    this.addArgTypes = (argTypes) => {
      this.facade.projectAnnotations.argTypes = {
        ...this.facade.projectAnnotations.argTypes,
        ...(0, import_store2.normalizeInputTypes)(argTypes)
      };
    };
    this.addArgsEnhancer = (enhancer) => {
      this.facade.projectAnnotations.argsEnhancers.push(enhancer);
    };
    this.addArgTypesEnhancer = (enhancer) => {
      this.facade.projectAnnotations.argTypesEnhancers.push(enhancer);
    };
    this.storiesOf = (kind, m) => {
      if (!kind && typeof kind !== "string") {
        throw new Error("Invalid or missing kind provided for stories, should be a string");
      }
      if (!m) {
        import_client_logger2.logger.warn(
          `Missing 'module' parameter for story with a kind of '${kind}'. It will break your HMR`
        );
      }
      if (m) {
        const proto = Object.getPrototypeOf(m);
        if (proto.exports && proto.exports.default) {
          import_client_logger2.logger.error(
            `Illegal mix of CSF default export and storiesOf calls in a single file: ${proto.i}`
          );
        }
      }
      const baseFilename = m && m.id ? `${m.id}` : (this.lastFileName++).toString();
      let fileName = baseFilename;
      let i = 1;
      while (this.facade.csfExports[fileName] && Object.keys(this.facade.csfExports[fileName]).length > 0) {
        i += 1;
        fileName = `${baseFilename}-${i}`;
      }
      if (m && m.hot && m.hot.accept) {
        m.hot.accept();
        m.hot.dispose(() => {
          this.facade.clearFilenameExports(fileName);
          setTimeout(() => {
            var _a;
            (_a = this.onImportFnChanged) == null ? void 0 : _a.call(this, { importFn: this.importFn.bind(this) });
          }, 0);
        });
      }
      let hasAdded = false;
      const api = {
        kind: kind.toString(),
        add: () => api,
        addDecorator: () => api,
        addLoader: () => api,
        addParameters: () => api
      };
      Object.keys(this.addons).forEach((name) => {
        const addon = this.addons[name];
        api[name] = (...args) => {
          addon.apply(api, args);
          return api;
        };
      });
      const meta = {
        id: (0, import_csf2.sanitize)(kind),
        title: kind,
        decorators: [],
        loaders: [],
        parameters: {}
      };
      this.facade.csfExports[fileName] = { default: meta };
      let counter = 0;
      api.add = (storyName, storyFn, parameters = {}) => {
        hasAdded = true;
        if (typeof storyName !== "string") {
          throw new Error(`Invalid or missing storyName provided for a "${kind}" story.`);
        }
        if (!storyFn || Array.isArray(storyFn) || invalidStoryTypes.has(typeof storyFn)) {
          throw new Error(
            `Cannot load story "${storyName}" in "${kind}" due to invalid format. Storybook expected a function/object but received ${typeof storyFn} instead.`
          );
        }
        const { decorators, loaders, component, args, argTypes, ...storyParameters } = parameters;
        const storyId = parameters.__id || (0, import_csf2.toId)(kind, storyName);
        const csfExports = this.facade.csfExports[fileName];
        csfExports[`story${counter}`] = {
          name: storyName,
          parameters: { fileName, __id: storyId, ...storyParameters },
          decorators,
          loaders,
          args,
          argTypes,
          component,
          render: storyFn
        };
        counter += 1;
        this.facade.entries[storyId] = {
          id: storyId,
          title: csfExports.default.title,
          name: storyName,
          importPath: fileName,
          type: "story"
        };
        return api;
      };
      api.addDecorator = (decorator) => {
        if (hasAdded)
          throw new Error(`You cannot add a decorator after the first story for a kind.
Read more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);
        meta.decorators.push(decorator);
        return api;
      };
      api.addLoader = (loader) => {
        if (hasAdded)
          throw new Error(`You cannot add a loader after the first story for a kind.`);
        meta.loaders.push(loader);
        return api;
      };
      api.addParameters = ({ component, args, argTypes, ...parameters }) => {
        if (hasAdded)
          throw new Error(`You cannot add parameters after the first story for a kind.
Read more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);
        meta.parameters = (0, import_store2.combineParameters)(meta.parameters, parameters);
        if (component)
          meta.component = component;
        if (args)
          meta.args = { ...meta.args, ...args };
        if (argTypes)
          meta.argTypes = { ...meta.argTypes, ...argTypes };
        return api;
      };
      return api;
    };
    this.getStorybook = () => {
      const { entries } = this.storyStore.storyIndex;
      const kinds = {};
      Object.entries(entries).forEach(([storyId, { title, name, importPath, type }]) => {
        if (type && type !== "story")
          return;
        if (!kinds[title]) {
          kinds[title] = { kind: title, fileName: importPath, stories: [] };
        }
        const { storyFn } = this.storyStore.fromId(storyId);
        kinds[title].stories.push({ name, render: storyFn });
      });
      return Object.values(kinds);
    };
    this.raw = () => {
      return this.storyStore.raw();
    };
    this.facade = new StoryStoreFacade();
    this.addons = {};
    this.storyStore = storyStore;
    singleton = this;
  }
  importFn(path) {
    return this.facade.importFn(path);
  }
  getStoryIndex() {
    if (!this.storyStore) {
      throw new Error("Cannot get story index before setting storyStore");
    }
    return this.facade.getStoryIndex(this.storyStore);
  }
  get _storyStore() {
    return this.storyStore;
  }
};

// src/queryparams.ts
var import_global3 = __toESM(require("global"));
var import_qs = require("qs");
var { document } = import_global3.default;
var getQueryParams = () => {
  if (document && document.location && document.location.search) {
    return (0, import_qs.parse)(document.location.search, { ignoreQueryPrefix: true });
  }
  return {};
};
var getQueryParam = (key) => {
  const params = getQueryParams();
  return params[key];
};

// src/index.ts
__reExport(src_exports, require("@storybook/store"), module.exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ClientApi,
  addArgTypes,
  addArgTypesEnhancer,
  addArgs,
  addArgsEnhancer,
  addDecorator,
  addLoader,
  addParameters,
  addStepRunner,
  getQueryParam,
  getQueryParams,
  setGlobalRender
});
