// src/preset/preview.ts
import { addons } from "@storybook/addons";
import { FORCE_REMOUNT, STORY_RENDER_PHASE_CHANGED } from "@storybook/core-events";
import { instrument } from "@storybook/instrumenter";
import { ModuleMocker } from "jest-mock";
var JestMock = new ModuleMocker(window);
var fn = JestMock.fn.bind(JestMock);
var { action } = instrument({ action: fn }, { retain: true });
var channel = addons.getChannel();
var seen = /* @__PURE__ */ new Set();
var spies = [];
channel.on(FORCE_REMOUNT, () => spies.forEach((mock) => mock?.mockClear?.()));
channel.on(STORY_RENDER_PHASE_CHANGED, ({ newPhase }) => {
  if (newPhase === "loading")
    spies.forEach((mock) => mock?.mockClear?.());
});
var addSpies = (id, val, key) => {
  if (seen.has(val))
    return val;
  seen.add(val);
  try {
    if (Object.prototype.toString.call(val) === "[object Object]") {
      for (const [k, v] of Object.entries(val))
        val[k] = addSpies(id, v, k);
      return val;
    }
    if (Array.isArray(val)) {
      return val.map((item, index) => addSpies(id, item, `${key}[${index}]`));
    }
    if (typeof val === "function" && val.isAction) {
      Object.defineProperty(val, "name", { value: key, writable: false });
      Object.defineProperty(val, "__storyId__", { value: id, writable: false });
      const spy = action(val);
      spies.push(spy);
      return spy;
    }
  } catch (e) {
  }
  return val;
};
var addActionsFromArgTypes = ({ id, initialArgs }) => addSpies(id, initialArgs);
var argsEnhancers = [addActionsFromArgTypes];
var { step: runStep } = instrument(
  { step: (label, play, context) => play(context) },
  { intercept: true }
);
var parameters = {
  throwPlayFunctionExceptions: false
};
export {
  argsEnhancers,
  parameters,
  runStep
};
