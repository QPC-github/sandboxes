var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});

// <define:process.env>
var define_process_env_default = {};

// src/presets.ts
import { dedent as dedent2 } from "ts-dedent";
import { logger } from "@storybook/node-logger";
import { dirname } from "path";

// src/utils/load-custom-presets.ts
import path2 from "path";

// src/utils/interpret-files.ts
import fs from "fs";
var boost = /* @__PURE__ */ new Set([".js", ".jsx", ".ts", ".tsx", ".cjs", ".mjs"]);
function sortExtensions() {
  return [...Array.from(boost)];
}
var possibleExtensions = sortExtensions();
function getInterpretedFile(pathToFile) {
  return possibleExtensions.map((ext) => pathToFile.endsWith(ext) ? pathToFile : `${pathToFile}${ext}`).find((candidate) => fs.existsSync(candidate));
}
function getInterpretedFileWithExt(pathToFile) {
  return possibleExtensions.map((ext) => ({ path: pathToFile.endsWith(ext) ? pathToFile : `${pathToFile}${ext}`, ext })).find((candidate) => fs.existsSync(candidate.path));
}

// src/utils/interpret-require.ts
var registered = false;
function interopRequireDefault(filePath) {
  if (registered === false) {
    const { register } = __require("esbuild-register/dist/node");
    registered = true;
    register({
      target: `node${process.version.slice(1)}`,
      format: "cjs",
      hookIgnoreNodeModules: false,
      tsconfigRaw: `{
      "compilerOptions": {
        "strict": false,
        "skipLibCheck": true,
      },
    }`
    });
  }
  const result = __require(filePath);
  const isES6DefaultExported = typeof result === "object" && result !== null && typeof result.default !== "undefined";
  return isES6DefaultExported ? result.default : result;
}
function getCandidate(paths) {
  for (let i = 0; i < paths.length; i += 1) {
    const candidate = getInterpretedFileWithExt(paths[i]);
    if (candidate) {
      return candidate;
    }
  }
  return void 0;
}
function serverRequire(filePath) {
  const candidatePath = serverResolve(filePath);
  if (!candidatePath) {
    return null;
  }
  return interopRequireDefault(candidatePath);
}
function serverResolve(filePath) {
  const paths = Array.isArray(filePath) ? filePath : [filePath];
  const existingCandidate = getCandidate(paths);
  if (!existingCandidate) {
    return null;
  }
  return existingCandidate.path;
}

// src/utils/validate-configuration-files.ts
import { dedent } from "ts-dedent";
import deprecate from "util-deprecate";
import glob from "glob";
import path from "path";
var warnLegacyConfigurationFiles = deprecate(
  () => {
  },
  dedent`
    Configuration files such as "config", "presets" and "addons" are deprecated and will be removed in Storybook 7.0.
    Read more about it in the migration guide: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#to-mainjs-configuration
  `
);
var errorMixingConfigFiles = (first, second, configDir) => {
  const firstPath = path.resolve(configDir, first);
  const secondPath = path.resolve(configDir, second);
  throw new Error(dedent`
    You have mixing configuration files:
    ${firstPath}
    ${secondPath}
    "${first}" and "${second}" cannot coexist.
    Please check the documentation for migration steps: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#to-mainjs-configuration
  `);
};
function validateConfigurationFiles(configDir) {
  const extensionsPattern = `{${Array.from(boost).join(",")}}`;
  const exists = (file) => !!glob.sync(path.resolve(configDir, `${file}${extensionsPattern}`)).length;
  const main = exists("main");
  const config = exists("config");
  if (!main && !config) {
    throw new Error(dedent`
      No configuration files have been found in your configDir (${path.resolve(configDir)}).
      Storybook needs either a "main" or "config" file.
    `);
  }
  if (main && config) {
    throw new Error(dedent`
      You have both a "main" and a "config". Please remove the "config" file from your configDir (${path.resolve(
      configDir,
      "config"
    )})`);
  }
  const presets = exists("presets");
  if (main && presets) {
    errorMixingConfigFiles("main", "presets", configDir);
  }
  const preview = exists("preview");
  if (preview && config) {
    errorMixingConfigFiles("preview", "config", configDir);
  }
  const addons = exists("addons");
  const manager = exists("manager");
  if (manager && addons) {
    errorMixingConfigFiles("manager", "addons", configDir);
  }
  if (presets || config || addons) {
    warnLegacyConfigurationFiles();
  }
}

// src/utils/load-custom-presets.ts
function loadCustomPresets({ configDir }) {
  validateConfigurationFiles(configDir);
  const presets = serverRequire(path2.resolve(configDir, "presets"));
  const main = serverRequire(path2.resolve(configDir, "main"));
  if (main) {
    const resolved = serverResolve(path2.resolve(configDir, "main"));
    if (resolved) {
      return [resolved];
    }
  }
  return presets || [];
}

// src/utils/safeResolve.ts
import resolveFrom from "resolve-from";
var safeResolveFrom = (path12, file) => {
  try {
    return resolveFrom(path12, file);
  } catch (e) {
    return void 0;
  }
};
var safeResolve = (file) => {
  try {
    return __require.resolve(file);
  } catch (e) {
    return void 0;
  }
};

// src/presets.ts
var isObject = (val) => val != null && typeof val === "object" && Array.isArray(val) === false;
var isFunction = (val) => typeof val === "function";
function filterPresetsConfig(presetsConfig) {
  return presetsConfig.filter((preset) => {
    const presetName = typeof preset === "string" ? preset : preset.name;
    return !/@storybook[\\\\/]preset-typescript/.test(presetName);
  });
}
function resolvePresetFunction(input, presetOptions, storybookOptions) {
  if (isFunction(input)) {
    return [...input({ ...storybookOptions, ...presetOptions })];
  }
  if (Array.isArray(input)) {
    return [...input];
  }
  return [];
}
var resolveAddonName = (configDir, name, options) => {
  const resolve = name.startsWith("/") ? safeResolve : safeResolveFrom.bind(null, configDir);
  const resolved = resolve(name);
  if (resolved) {
    if (name.match(/\/(manager|register(-panel)?)(\.(js|ts|tsx|jsx))?$/)) {
      return {
        type: "virtual",
        name,
        managerEntries: [resolved]
      };
    }
    if (name.match(/\/(preset)(\.(js|ts|tsx|jsx))?$/)) {
      return {
        type: "presets",
        name: resolved
      };
    }
  }
  const absolutePackageJson = resolved && resolve(`${name}/package.json`);
  const absoluteDir = absolutePackageJson && dirname(absolutePackageJson);
  const absolutizeExport = (exportName) => {
    if (resolve(`${name}${exportName}`))
      return `${absoluteDir}${exportName}`;
    return void 0;
  };
  const path12 = name;
  const managerFile = absolutizeExport(`/manager`);
  const registerFile = absolutizeExport(`/register`) || absolutizeExport(`/register-panel`);
  const previewFile = absolutizeExport(`/preview`);
  const presetFile = resolve(`${path12}/preset`);
  if (!(managerFile || previewFile) && presetFile) {
    return {
      type: "presets",
      name: presetFile
    };
  }
  if (managerFile || registerFile || previewFile || presetFile) {
    const managerEntries = [];
    if (managerFile) {
      managerEntries.push(managerFile);
    }
    if (!managerFile && registerFile && !presetFile) {
      managerEntries.push(registerFile);
    }
    return {
      type: "virtual",
      name: path12,
      ...managerEntries.length ? { managerEntries } : {},
      ...previewFile ? { previewAnnotations: [previewFile] } : {},
      ...presetFile ? { presets: [{ name: presetFile, options }] } : {}
    };
  }
  if (resolved) {
    return {
      type: "presets",
      name: resolved
    };
  }
  return void 0;
};
var map = ({ configDir }) => (item) => {
  const options = isObject(item) ? item.options || void 0 : void 0;
  const name = isObject(item) ? item.name : item;
  try {
    const resolved = resolveAddonName(configDir, name, options);
    return {
      ...options ? { options } : {},
      ...resolved
    };
  } catch (err) {
    logger.error(
      `Addon value should end in /manager or /preview or /register OR it should be a valid preset https://storybook.js.org/docs/react/addons/writing-presets/
${item}`
    );
  }
  return void 0;
};
async function getContent(input) {
  if (input.type === "virtual") {
    const { type, name: name2, ...rest } = input;
    return rest;
  }
  const name = input.name ? input.name : input;
  return interopRequireDefault(name);
}
async function loadPreset(input, level, storybookOptions) {
  try {
    const name = input.name ? input.name : input;
    const presetOptions = input.options ? input.options : {};
    let contents = await getContent(input);
    if (typeof contents === "function") {
      contents = contents(storybookOptions, presetOptions);
    }
    if (Array.isArray(contents)) {
      const subPresets = contents;
      return loadPresets(subPresets, level + 1, storybookOptions);
    }
    if (isObject(contents)) {
      const { addons: addonsInput, presets: presetsInput, ...rest } = contents;
      const subPresets = resolvePresetFunction(presetsInput, presetOptions, storybookOptions);
      const subAddons = resolvePresetFunction(addonsInput, presetOptions, storybookOptions);
      return [
        ...await loadPresets([...subPresets], level + 1, storybookOptions),
        ...await loadPresets(
          [...subAddons.map(map(storybookOptions))].filter(Boolean),
          level + 1,
          storybookOptions
        ),
        {
          name,
          preset: rest,
          options: presetOptions
        }
      ];
    }
    throw new Error(dedent2`
      ${input} is not a valid preset
    `);
  } catch (e) {
    const warning = level > 0 ? `  Failed to load preset: ${JSON.stringify(input)} on level ${level}` : `  Failed to load preset: ${JSON.stringify(input)}`;
    logger.warn(warning);
    logger.error(e);
    return [];
  }
}
async function loadPresets(presets, level, storybookOptions) {
  if (!presets || !Array.isArray(presets) || !presets.length) {
    return [];
  }
  if (!level) {
    logger.info("=> Loading presets");
  }
  return (await Promise.all(presets.map(async (preset) => loadPreset(preset, level, storybookOptions)))).reduce((acc, loaded) => {
    return acc.concat(loaded);
  }, []);
}
function applyPresets(presets, extension, config, args, storybookOptions) {
  const presetResult = new Promise((res) => res(config));
  if (!presets.length) {
    return presetResult;
  }
  return presets.reduce((accumulationPromise, { preset, options }) => {
    const change = preset[extension];
    if (!change) {
      return accumulationPromise;
    }
    if (typeof change === "function") {
      const extensionFn = change;
      const context = {
        preset,
        combinedOptions: {
          ...storybookOptions,
          ...args,
          ...options,
          presetsList: presets,
          presets: {
            apply: async (ext, c, a = {}) => applyPresets(presets, ext, c, a, storybookOptions)
          }
        }
      };
      return accumulationPromise.then(
        (newConfig) => extensionFn.call(context.preset, newConfig, context.combinedOptions)
      );
    }
    return accumulationPromise.then((newConfig) => {
      if (Array.isArray(newConfig) && Array.isArray(change)) {
        return [...newConfig, ...change];
      }
      if (isObject(newConfig) && isObject(change)) {
        return { ...newConfig, ...change };
      }
      return change;
    });
  }, presetResult);
}
async function getPresets(presets, storybookOptions) {
  const loadedPresets = await loadPresets(presets, 0, storybookOptions);
  return {
    apply: async (extension, config, args = {}) => applyPresets(loadedPresets, extension, config, args, storybookOptions)
  };
}
async function loadAllPresets(options) {
  const { corePresets = [], overridePresets = [], ...restOptions } = options;
  const presetsConfig = [
    ...corePresets,
    ...loadCustomPresets(options),
    ...overridePresets
  ];
  const filteredPresetConfig = filterPresetsConfig(presetsConfig);
  if (filteredPresetConfig.length < presetsConfig.length) {
    logger.warn(
      "Storybook now supports TypeScript natively. You can safely remove `@storybook/preset-typescript`."
    );
  }
  return getPresets(filteredPresetConfig, restOptions);
}

// src/utils/check-addon-order.ts
var { logger: logger2 } = __require("@storybook/node-logger");
var predicateFor = (addon) => (entry) => {
  const name = entry.name || entry;
  return name && name.includes(addon);
};
var isCorrectOrder = (addons, before, after) => {
  const essentialsIndex = addons.findIndex(predicateFor("@storybook/addon-essentials"));
  let beforeIndex = addons.findIndex(predicateFor(before.name));
  let afterIndex = addons.findIndex(predicateFor(after.name));
  if (beforeIndex === -1 && before.inEssentials)
    beforeIndex = essentialsIndex;
  if (afterIndex === -1 && after.inEssentials)
    afterIndex = essentialsIndex;
  return beforeIndex !== -1 && afterIndex !== -1 && beforeIndex <= afterIndex;
};
var checkAddonOrder = async ({ before, after, configFile, getConfig }) => {
  try {
    const config = await getConfig(configFile);
    if (!config?.addons) {
      logger2.warn(`Unable to find 'addons' config in main Storybook config`);
      return;
    }
    if (!isCorrectOrder(config.addons, before, after)) {
      const orEssentials = " (or '@storybook/addon-essentials')";
      const beforeText = `'${before.name}'${before.inEssentials ? orEssentials : ""}`;
      const afterText = `'${after.name}'${after.inEssentials ? orEssentials : ""}`;
      logger2.warn(
        `Expected ${beforeText} to be listed before ${afterText} in main Storybook config.`
      );
    }
  } catch (e) {
    logger2.warn(`Unable to load config file: ${configFile}`);
  }
};

// src/utils/envs.ts
import { getEnvironment } from "lazy-universal-dotenv";

// src/utils/paths.ts
import path3 from "path";
import findUp from "find-up";
var getProjectRoot = () => {
  let result;
  try {
    const found = findUp.sync(".git", { type: "directory" });
    if (found) {
      result = result || path3.join(found, "..");
    }
  } catch (e) {
  }
  try {
    const found = findUp.sync(".svn", { type: "directory" });
    if (found) {
      result = result || path3.join(found, "..");
    }
  } catch (e) {
  }
  try {
    result = result || __dirname.split("node_modules")[0];
  } catch (e) {
  }
  return result || process.cwd();
};
var nodePathsToArray = (nodePath) => nodePath.split(process.platform === "win32" ? ";" : ":").filter(Boolean).map((p) => path3.resolve("./", p));
var relativePattern = /^\.{1,2}([/\\]|$)/;
function normalizeStoryPath(filename) {
  if (relativePattern.test(filename))
    return filename;
  return `.${path3.sep}${filename}`;
}

// src/utils/envs.ts
function loadEnvs(options = {}) {
  const defaultNodeEnv = options.production ? "production" : "development";
  const env = {
    NODE_ENV: "development",
    NODE_PATH: define_process_env_default.NODE_PATH || "",
    STORYBOOK: define_process_env_default.STORYBOOK || "true",
    PUBLIC_URL: options.production ? "." : ""
  };
  Object.keys(define_process_env_default).filter((name) => /^STORYBOOK_/.test(name)).forEach((name) => {
    env[name] = define_process_env_default[name];
  });
  const base = Object.entries(env).reduce(
    (acc, [k, v]) => Object.assign(acc, { [k]: JSON.stringify(v) }),
    {}
  );
  const { stringified, raw } = getEnvironment({ nodeEnv: env.NODE_ENV });
  const fullRaw = { ...env, ...raw };
  fullRaw.NODE_PATH = nodePathsToArray(fullRaw.NODE_PATH || "");
  return {
    stringified: { ...base, ...stringified },
    raw: fullRaw
  };
}
var stringifyEnvs = (raw) => Object.entries(raw).reduce((acc, [key, value]) => {
  acc[key] = JSON.stringify(value);
  return acc;
}, {});
var stringifyProcessEnvs = (raw) => {
  const envs = Object.entries(raw).reduce(
    (acc, [key, value]) => {
      acc[`process.env.${key}`] = JSON.stringify(value);
      return acc;
    },
    {
      "process.env.XSTORYBOOK_EXAMPLE_APP": '""'
    }
  );
  return envs;
};

// src/utils/handlebars.ts
import Handlebars from "handlebars";
function handlebars(source, data) {
  const template = Handlebars.compile(source);
  return template(data);
}

// src/utils/load-main-config.ts
import path4 from "path";
function loadMainConfig({ configDir }) {
  validateConfigurationFiles(configDir);
  return serverRequire(path4.resolve(configDir, "main"));
}

// src/utils/get-framework-name.ts
import { dedent as dedent3 } from "ts-dedent";
async function getFrameworkName(options) {
  const framework = await options.presets.apply("framework", "", options);
  if (!framework) {
    throw new Error(dedent3`
      You must specify a framework in '.storybook/main.js' config.

      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#framework-field-mandatory
    `);
  }
  return typeof framework === "object" ? framework.name : framework;
}

// src/utils/get-storybook-configuration.ts
function getStorybookConfiguration(storybookScript, shortName, longName) {
  if (!storybookScript) {
    return null;
  }
  const parts = storybookScript.split(/[\s='"]+/);
  let index = parts.indexOf(longName);
  if (index === -1) {
    index = parts.indexOf(shortName);
  }
  if (index === -1) {
    return null;
  }
  return parts[index + 1];
}

// src/utils/get-storybook-info.ts
import path5 from "path";
import fse from "fs-extra";
var rendererPackages = {
  "@storybook/react": "react",
  "@storybook/vue": "vue",
  "@storybook/vue3": "vue3",
  "@storybook/angular": "angular",
  "@storybook/html": "html",
  "@storybook/web-components": "web-components",
  "@storybook/polymer": "polymer",
  "@storybook/ember": "ember",
  "@storybook/marko": "marko",
  "@storybook/mithril": "mithril",
  "@storybook/riot": "riot",
  "@storybook/svelte": "svelte",
  "@storybook/preact": "preact",
  "@storybook/rax": "rax",
  "@storybook/server": "server"
};
var logger3 = console;
var findDependency = ({ dependencies, devDependencies, peerDependencies }, predicate) => [
  Object.entries(dependencies || {}).find(predicate),
  Object.entries(devDependencies || {}).find(predicate),
  Object.entries(peerDependencies || {}).find(predicate)
];
var getRendererInfo = (packageJson) => {
  const [dep, devDep, peerDep] = findDependency(packageJson, ([key]) => rendererPackages[key]);
  const [pkg, version] = dep || devDep || peerDep || [];
  const renderer = pkg ? rendererPackages[pkg] : void 0;
  if (dep && devDep && dep[0] === devDep[0]) {
    logger3.warn(
      `Found "${dep[0]}" in both "dependencies" and "devDependencies". This is probably a mistake.`
    );
  }
  if (dep && peerDep && dep[0] === peerDep[0]) {
    logger3.warn(
      `Found "${dep[0]}" in both "dependencies" and "peerDependencies". This is probably a mistake.`
    );
  }
  return {
    version,
    framework: renderer,
    frameworkPackage: pkg,
    renderer,
    rendererPackage: pkg
  };
};
var validConfigExtensions = ["ts", "js", "tsx", "jsx", "mjs", "cjs"];
var findConfigFile = (prefix, configDir) => {
  const filePrefix = path5.join(configDir, prefix);
  const extension = validConfigExtensions.find(
    (ext) => fse.existsSync(`${filePrefix}.${ext}`)
  );
  return extension ? `${filePrefix}.${extension}` : null;
};
var getConfigInfo = (packageJson) => {
  let configDir = ".storybook";
  const storybookScript = packageJson.scripts?.storybook;
  if (storybookScript) {
    const configParam = getStorybookConfiguration(storybookScript, "-c", "--config-dir");
    if (configParam)
      configDir = configParam;
  }
  return {
    configDir,
    mainConfig: findConfigFile("main", configDir),
    previewConfig: findConfigFile("preview", configDir),
    managerConfig: findConfigFile("manager", configDir)
  };
};
var getStorybookInfo = (packageJson) => {
  const rendererInfo = getRendererInfo(packageJson);
  const configInfo = getConfigInfo(packageJson);
  return {
    ...rendererInfo,
    ...configInfo
  };
};

// src/utils/get-storybook-refs.ts
import { readJSON } from "fs-extra";
import { dirname as dirname2, join } from "path";
import findUp2 from "find-up";
import resolveFrom2 from "resolve-from";
import { logger as logger4 } from "@storybook/node-logger";
var getAutoRefs = async (options) => {
  const location = await findUp2("package.json", { cwd: options.configDir });
  if (!location) {
    return {};
  }
  const directory = dirname2(location);
  const { dependencies = [], devDependencies = [] } = await readJSON(location) || {};
  const deps = Object.keys({ ...dependencies, ...devDependencies });
  const list = await Promise.all(
    deps.map(async (d) => {
      try {
        const l = resolveFrom2(directory, join(d, "package.json"));
        const { storybook, name, version } = await readJSON(l) || {};
        if (storybook?.url) {
          return { id: name, ...storybook, version };
        }
      } catch {
        logger4.warn(`unable to find package.json for ${d}`);
        return void 0;
      }
      return void 0;
    })
  );
  return list.filter(Boolean).reduce(
    (acc, cur) => ({
      ...acc,
      [cur.id]: {
        id: cur.id.toLowerCase(),
        url: stripTrailingSlash(cur.url),
        title: cur.title,
        version: cur.version
      }
    }),
    {}
  );
};
var checkRef = (url) => fetch(`${url}/iframe.html`).then(
  async ({ ok, status }) => {
    if (ok) {
      if (status !== 200) {
        return false;
      }
      const data = await fetch(`${url}/iframe.html`, {
        headers: { Accept: "application/json" }
      });
      if (data.ok && (await data.json().catch((e) => ({}))).loginUrl) {
        return false;
      }
    }
    return ok;
  },
  () => false
);
var stripTrailingSlash = (url) => url.replace(/\/$/, "");
var toTitle = (input) => {
  const result = input.replace(/[A-Z]/g, (f) => ` ${f}`).replace(/[-_][A-Z]/gi, (f) => ` ${f.toUpperCase()}`).replace(/-/g, " ").replace(/_/g, " ");
  return `${result.substring(0, 1).toUpperCase()}${result.substring(1)}`.trim();
};
async function getRefs(options) {
  const refs = await options.presets.apply("refs", await getAutoRefs(options));
  Object.entries(refs).forEach(([key, value]) => {
    if (value.disable) {
      delete refs[key];
      return;
    }
    refs[key.toLowerCase()] = {
      ...value,
      id: key.toLowerCase(),
      title: value.title || toTitle(value.id || key),
      url: stripTrailingSlash(value.url)
    };
  });
  await Promise.all(
    Object.entries(refs).map(async ([k, value]) => {
      const ok = await checkRef(value.url);
      refs[k] = { ...value, type: ok ? "server-checked" : "unknown" };
    })
  );
  return refs;
}

// src/utils/load-manager-or-addons-file.ts
import path6 from "path";
import { logger as logger5 } from "@storybook/node-logger";
import { dedent as dedent4 } from "ts-dedent";
function loadManagerOrAddonsFile({ configDir }) {
  const storybookCustomAddonsPath = getInterpretedFile(path6.resolve(configDir, "addons"));
  const storybookCustomManagerPath = getInterpretedFile(path6.resolve(configDir, "manager"));
  if (storybookCustomAddonsPath || storybookCustomManagerPath) {
    logger5.info("=> Loading custom manager config");
  }
  if (storybookCustomAddonsPath && storybookCustomManagerPath) {
    throw new Error(dedent4`
      You have both a "addons.js" and a "manager.js", remove the "addons.js" file from your configDir (${path6.resolve(
      configDir,
      "addons"
    )})`);
  }
  return storybookCustomManagerPath || storybookCustomAddonsPath;
}

// src/utils/load-preview-or-config-file.ts
import path7 from "path";
import { dedent as dedent5 } from "ts-dedent";
function loadPreviewOrConfigFile({ configDir }) {
  const storybookConfigPath = getInterpretedFile(path7.resolve(configDir, "config"));
  const storybookPreviewPath = getInterpretedFile(path7.resolve(configDir, "preview"));
  if (storybookConfigPath && storybookPreviewPath) {
    throw new Error(dedent5`
      You have both a "config.js" and a "preview.js", remove the "config.js" file from your configDir (${path7.resolve(
      configDir,
      "config"
    )})`);
  }
  return storybookPreviewPath || storybookConfigPath;
}

// src/utils/log-config.ts
import chalk from "chalk";
function logConfig(caption, config) {
  console.log(chalk.cyan(caption));
  console.dir(config, { depth: null });
}

// src/utils/print-duration.ts
import prettyTime from "pretty-hrtime";
var printDuration = (startTime) => prettyTime(process.hrtime(startTime)).replace(" ms", " milliseconds").replace(" s", " seconds").replace(" m", " minutes");

// src/utils/progress-reporting.ts
var useProgressReporting = async (router, startTime, options) => {
  let value = 0;
  let totalModules;
  let reportProgress = () => {
  };
  router.get("/progress", (request, response) => {
    let closed = false;
    const close = () => {
      closed = true;
      response.end();
    };
    response.on("close", close);
    if (closed || response.writableEnded)
      return;
    response.setHeader("Cache-Control", "no-cache");
    response.setHeader("Content-Type", "text/event-stream");
    response.setHeader("Connection", "keep-alive");
    response.flushHeaders();
    reportProgress = (progress) => {
      if (closed || response.writableEnded)
        return;
      response.write(`data: ${JSON.stringify(progress)}

`);
      response.flush();
      if (progress.value === 1)
        close();
    };
  });
  const handler = (newValue, message, arg3) => {
    value = Math.max(newValue, value);
    const progress = { value, message: message.charAt(0).toUpperCase() + message.slice(1) };
    if (message === "building") {
      const counts = arg3 && arg3.match(/(\d+)\/(\d+)/) || [];
      const complete = parseInt(counts[1], 10);
      const total = parseInt(counts[2], 10);
      if (!Number.isNaN(complete) && !Number.isNaN(total)) {
        progress.modules = { complete, total };
        totalModules = total;
      }
    }
    if (value === 1) {
      if (options.cache) {
        options.cache.set("modulesCount", totalModules);
      }
      if (!progress.message) {
        progress.message = `Completed in ${printDuration(startTime)}.`;
      }
    }
    reportProgress(progress);
  };
  const modulesCount = await options.cache?.get("modulesCount").catch(() => {
  }) || 1e3;
  return { handler, modulesCount };
};

// src/utils/resolve-path-in-sb-cache.ts
import path8 from "path";
import pkgDir from "pkg-dir";
function resolvePathInStorybookCache(fileOrDirectoryName) {
  const cwd = process.cwd();
  const projectDir = pkgDir.sync(cwd);
  let cacheDirectory;
  if (!projectDir) {
    cacheDirectory = path8.resolve(cwd, ".cache/storybook");
  } else {
    cacheDirectory = path8.resolve(projectDir, "node_modules/.cache/storybook");
  }
  return path8.join(cacheDirectory, fileOrDirectoryName);
}

// src/utils/file-cache.ts
import Cache from "file-system-cache";
function createFileSystemCache(options) {
  return Cache(options);
}

// src/utils/cache.ts
var cache = createFileSystemCache({
  basePath: resolvePathInStorybookCache("dev-server"),
  ns: "storybook"
});

// src/utils/template.ts
import path9 from "path";
import { sync } from "pkg-dir";
import fs2 from "fs";
var interpolate = (string, data = {}) => Object.entries(data).reduce((acc, [k, v]) => acc.replace(new RegExp(`%${k}%`, "g"), v), string);
function getPreviewBodyTemplate(configDirPath, interpolations) {
  const base = fs2.readFileSync(`${sync(__dirname)}/templates/base-preview-body.html`, "utf8");
  const bodyHtmlPath = path9.resolve(configDirPath, "preview-body.html");
  let result = base;
  if (fs2.existsSync(bodyHtmlPath)) {
    result = fs2.readFileSync(bodyHtmlPath, "utf8") + result;
  }
  return interpolate(result, interpolations);
}
function getPreviewHeadTemplate(configDirPath, interpolations) {
  const base = fs2.readFileSync(`${sync(__dirname)}/templates/base-preview-head.html`, "utf8");
  const headHtmlPath = path9.resolve(configDirPath, "preview-head.html");
  let result = base;
  if (fs2.existsSync(headHtmlPath)) {
    result += fs2.readFileSync(headHtmlPath, "utf8");
  }
  return interpolate(result, interpolations);
}
function getPreviewMainTemplate() {
  return `${sync(__dirname)}/templates/preview.ejs`;
}

// src/utils/interpolate.ts
var interpolate2 = (template, bindings) => {
  return Object.entries(bindings).reduce((acc, [k, v]) => {
    const escapedString = v.replace(/\\/g, "/").replace(/\$/g, "$$$");
    return acc.replace(new RegExp(`{{${k}}}`, "g"), escapedString);
  }, template);
};

// src/utils/glob-to-regexp.ts
import { makeRe } from "picomatch";
function globToRegexp(glob2) {
  const regex = makeRe(glob2, {
    fastpaths: false,
    noglobstar: false,
    bash: false
  });
  if (!regex.source.startsWith("^")) {
    throw new Error(`Invalid glob: >> ${glob2} >> ${regex}`);
  }
  if (!glob2.startsWith("./")) {
    return regex;
  }
  return new RegExp(
    ["^\\.", glob2.startsWith("./**") ? "" : "[\\\\/]", regex.source.substring(1)].join("")
  );
}

// src/utils/normalize-stories.ts
import fs3 from "fs";
import path10 from "path";
import deprecate2 from "util-deprecate";
import { dedent as dedent6 } from "ts-dedent";
import { scan } from "picomatch";
import slash from "slash";
var DEFAULT_TITLE_PREFIX = "";
var DEFAULT_FILES = "**/*.@(mdx|stories.mdx|stories.tsx|stories.ts|stories.jsx|stories.js)";
var fixBadGlob = deprecate2(
  (match) => {
    return match.input.replace(match[1], `@${match[1]}`);
  },
  dedent6`
    You have specified an invalid glob, we've attempted to fix it, please ensure that the glob you specify is valid. See: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#correct-globs-in-mainjs
  `
);
var detectBadGlob = (val) => {
  const match = val.match(/\.(\([^)]+\))/);
  if (match) {
    return fixBadGlob(match);
  }
  return val;
};
var isDirectory = (configDir, entry) => {
  try {
    return fs3.lstatSync(path10.resolve(configDir, entry)).isDirectory();
  } catch (err) {
    return false;
  }
};
var getDirectoryFromWorkingDir = ({
  configDir,
  workingDir,
  directory
}) => {
  const directoryFromConfig = path10.resolve(configDir, directory);
  const directoryFromWorking = path10.relative(workingDir, directoryFromConfig);
  return normalizeStoryPath(directoryFromWorking);
};
var normalizeStoriesEntry = (entry, { configDir, workingDir }) => {
  let specifierWithoutMatcher;
  if (typeof entry === "string") {
    const fixedEntry = detectBadGlob(entry);
    const globResult = scan(fixedEntry);
    if (globResult.isGlob) {
      const directory2 = globResult.prefix + globResult.base;
      const files2 = globResult.glob;
      specifierWithoutMatcher = {
        titlePrefix: DEFAULT_TITLE_PREFIX,
        directory: directory2,
        files: files2
      };
    } else if (isDirectory(configDir, entry)) {
      specifierWithoutMatcher = {
        titlePrefix: DEFAULT_TITLE_PREFIX,
        directory: entry,
        files: DEFAULT_FILES
      };
    } else {
      specifierWithoutMatcher = {
        titlePrefix: DEFAULT_TITLE_PREFIX,
        directory: path10.dirname(entry),
        files: path10.basename(entry)
      };
    }
  } else {
    specifierWithoutMatcher = {
      titlePrefix: DEFAULT_TITLE_PREFIX,
      files: DEFAULT_FILES,
      ...entry
    };
  }
  const files = slash(specifierWithoutMatcher.files);
  const { directory: directoryRelativeToConfig } = specifierWithoutMatcher;
  const directory = slash(
    getDirectoryFromWorkingDir({
      configDir,
      workingDir,
      directory: directoryRelativeToConfig
    })
  ).replace(/\/$/, "");
  const importPathMatcher = globToRegexp(`${directory}/${files}`);
  return {
    ...specifierWithoutMatcher,
    directory,
    importPathMatcher
  };
};
var normalizeStories = (entries, options) => entries.map((entry) => normalizeStoriesEntry(entry, options));

// src/utils/readTemplate.ts
import fse2 from "fs-extra";
async function readTemplate(filename) {
  return fse2.readFile(filename, {
    encoding: "utf8"
  });
}

// src/utils/findDistEsm.ts
import path11 from "path";
import { sync as findUpSync } from "find-up";
var findDistEsm = (cwd, relativePath) => {
  const nearestPackageJson = findUpSync("package.json", { cwd });
  if (!nearestPackageJson) {
    throw new Error(`Could not find package.json in: ${cwd}`);
  }
  const packageDir = path11.dirname(nearestPackageJson);
  return path11.join(packageDir, "dist", "esm", relativePath);
};

// src/utils/symlinks.ts
function isPreservingSymlinks() {
  const { NODE_OPTIONS, NODE_PRESERVE_SYMLINKS } = define_process_env_default;
  return !!NODE_PRESERVE_SYMLINKS || NODE_OPTIONS?.includes("--preserve-symlinks");
}
export {
  boost,
  cache,
  checkAddonOrder,
  createFileSystemCache,
  filterPresetsConfig,
  findDistEsm,
  getAutoRefs,
  getDirectoryFromWorkingDir,
  getFrameworkName,
  getInterpretedFile,
  getInterpretedFileWithExt,
  getPresets,
  getPreviewBodyTemplate,
  getPreviewHeadTemplate,
  getPreviewMainTemplate,
  getProjectRoot,
  getRefs,
  getStorybookConfiguration,
  getStorybookInfo,
  globToRegexp,
  handlebars,
  interopRequireDefault,
  interpolate2 as interpolate,
  isPreservingSymlinks,
  loadAllPresets,
  loadCustomPresets,
  loadEnvs,
  loadMainConfig,
  loadManagerOrAddonsFile,
  loadPreset,
  loadPreviewOrConfigFile,
  logConfig,
  nodePathsToArray,
  normalizeStories,
  normalizeStoriesEntry,
  normalizeStoryPath,
  readTemplate,
  resolveAddonName,
  resolvePathInStorybookCache,
  serverRequire,
  serverResolve,
  stringifyEnvs,
  stringifyProcessEnvs,
  useProgressReporting,
  validateConfigurationFiles
};
