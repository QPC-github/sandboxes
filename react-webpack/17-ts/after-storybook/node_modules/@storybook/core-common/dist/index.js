"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  boost: () => boost,
  cache: () => cache,
  checkAddonOrder: () => checkAddonOrder,
  createFileSystemCache: () => createFileSystemCache,
  filterPresetsConfig: () => filterPresetsConfig,
  findDistEsm: () => findDistEsm,
  getAutoRefs: () => getAutoRefs,
  getDirectoryFromWorkingDir: () => getDirectoryFromWorkingDir,
  getFrameworkName: () => getFrameworkName,
  getInterpretedFile: () => getInterpretedFile,
  getInterpretedFileWithExt: () => getInterpretedFileWithExt,
  getPresets: () => getPresets,
  getPreviewBodyTemplate: () => getPreviewBodyTemplate,
  getPreviewHeadTemplate: () => getPreviewHeadTemplate,
  getPreviewMainTemplate: () => getPreviewMainTemplate,
  getProjectRoot: () => getProjectRoot,
  getRefs: () => getRefs,
  getStorybookConfiguration: () => getStorybookConfiguration,
  getStorybookInfo: () => getStorybookInfo,
  globToRegexp: () => globToRegexp,
  handlebars: () => handlebars,
  interopRequireDefault: () => interopRequireDefault,
  interpolate: () => interpolate2,
  isPreservingSymlinks: () => isPreservingSymlinks,
  loadAllPresets: () => loadAllPresets,
  loadCustomPresets: () => loadCustomPresets,
  loadEnvs: () => loadEnvs,
  loadMainConfig: () => loadMainConfig,
  loadManagerOrAddonsFile: () => loadManagerOrAddonsFile,
  loadPreset: () => loadPreset,
  loadPreviewOrConfigFile: () => loadPreviewOrConfigFile,
  logConfig: () => logConfig,
  nodePathsToArray: () => nodePathsToArray,
  normalizeStories: () => normalizeStories,
  normalizeStoriesEntry: () => normalizeStoriesEntry,
  normalizeStoryPath: () => normalizeStoryPath,
  readTemplate: () => readTemplate,
  resolveAddonName: () => resolveAddonName,
  resolvePathInStorybookCache: () => resolvePathInStorybookCache,
  serverRequire: () => serverRequire,
  serverResolve: () => serverResolve,
  stringifyEnvs: () => stringifyEnvs,
  stringifyProcessEnvs: () => stringifyProcessEnvs,
  useProgressReporting: () => useProgressReporting,
  validateConfigurationFiles: () => validateConfigurationFiles
});
module.exports = __toCommonJS(src_exports);

// src/presets.ts
var import_ts_dedent2 = require("ts-dedent");
var import_node_logger = require("@storybook/node-logger");
var import_path3 = require("path");

// src/utils/load-custom-presets.ts
var import_path2 = __toESM(require("path"));

// src/utils/interpret-files.ts
var import_fs = __toESM(require("fs"));
var boost = /* @__PURE__ */ new Set([".js", ".jsx", ".ts", ".tsx", ".cjs", ".mjs"]);
function sortExtensions() {
  return [...Array.from(boost)];
}
var possibleExtensions = sortExtensions();
function getInterpretedFile(pathToFile) {
  return possibleExtensions.map((ext) => pathToFile.endsWith(ext) ? pathToFile : `${pathToFile}${ext}`).find((candidate) => import_fs.default.existsSync(candidate));
}
function getInterpretedFileWithExt(pathToFile) {
  return possibleExtensions.map((ext) => ({ path: pathToFile.endsWith(ext) ? pathToFile : `${pathToFile}${ext}`, ext })).find((candidate) => import_fs.default.existsSync(candidate.path));
}

// src/utils/interpret-require.ts
var registered = false;
function interopRequireDefault(filePath) {
  if (registered === false) {
    const { register } = require("esbuild-register/dist/node");
    registered = true;
    register({
      target: `node${process.version.slice(1)}`,
      format: "cjs",
      hookIgnoreNodeModules: false,
      tsconfigRaw: `{
      "compilerOptions": {
        "strict": false,
        "skipLibCheck": true,
      },
    }`
    });
  }
  const result = require(filePath);
  const isES6DefaultExported = typeof result === "object" && result !== null && typeof result.default !== "undefined";
  return isES6DefaultExported ? result.default : result;
}
function getCandidate(paths) {
  for (let i = 0; i < paths.length; i += 1) {
    const candidate = getInterpretedFileWithExt(paths[i]);
    if (candidate) {
      return candidate;
    }
  }
  return void 0;
}
function serverRequire(filePath) {
  const candidatePath = serverResolve(filePath);
  if (!candidatePath) {
    return null;
  }
  return interopRequireDefault(candidatePath);
}
function serverResolve(filePath) {
  const paths = Array.isArray(filePath) ? filePath : [filePath];
  const existingCandidate = getCandidate(paths);
  if (!existingCandidate) {
    return null;
  }
  return existingCandidate.path;
}

// src/utils/validate-configuration-files.ts
var import_ts_dedent = require("ts-dedent");
var import_util_deprecate = __toESM(require("util-deprecate"));
var import_glob = __toESM(require("glob"));
var import_path = __toESM(require("path"));
var warnLegacyConfigurationFiles = (0, import_util_deprecate.default)(
  () => {
  },
  import_ts_dedent.dedent`
    Configuration files such as "config", "presets" and "addons" are deprecated and will be removed in Storybook 7.0.
    Read more about it in the migration guide: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#to-mainjs-configuration
  `
);
var errorMixingConfigFiles = (first, second, configDir) => {
  const firstPath = import_path.default.resolve(configDir, first);
  const secondPath = import_path.default.resolve(configDir, second);
  throw new Error(import_ts_dedent.dedent`
    You have mixing configuration files:
    ${firstPath}
    ${secondPath}
    "${first}" and "${second}" cannot coexist.
    Please check the documentation for migration steps: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#to-mainjs-configuration
  `);
};
function validateConfigurationFiles(configDir) {
  const extensionsPattern = `{${Array.from(boost).join(",")}}`;
  const exists = (file) => !!import_glob.default.sync(import_path.default.resolve(configDir, `${file}${extensionsPattern}`)).length;
  const main = exists("main");
  const config = exists("config");
  if (!main && !config) {
    throw new Error(import_ts_dedent.dedent`
      No configuration files have been found in your configDir (${import_path.default.resolve(configDir)}).
      Storybook needs either a "main" or "config" file.
    `);
  }
  if (main && config) {
    throw new Error(import_ts_dedent.dedent`
      You have both a "main" and a "config". Please remove the "config" file from your configDir (${import_path.default.resolve(
      configDir,
      "config"
    )})`);
  }
  const presets = exists("presets");
  if (main && presets) {
    errorMixingConfigFiles("main", "presets", configDir);
  }
  const preview = exists("preview");
  if (preview && config) {
    errorMixingConfigFiles("preview", "config", configDir);
  }
  const addons = exists("addons");
  const manager = exists("manager");
  if (manager && addons) {
    errorMixingConfigFiles("manager", "addons", configDir);
  }
  if (presets || config || addons) {
    warnLegacyConfigurationFiles();
  }
}

// src/utils/load-custom-presets.ts
function loadCustomPresets({ configDir }) {
  validateConfigurationFiles(configDir);
  const presets = serverRequire(import_path2.default.resolve(configDir, "presets"));
  const main = serverRequire(import_path2.default.resolve(configDir, "main"));
  if (main) {
    const resolved = serverResolve(import_path2.default.resolve(configDir, "main"));
    if (resolved) {
      return [resolved];
    }
  }
  return presets || [];
}

// src/utils/safeResolve.ts
var import_resolve_from = __toESM(require("resolve-from"));
var safeResolveFrom = (path12, file) => {
  try {
    return (0, import_resolve_from.default)(path12, file);
  } catch (e) {
    return void 0;
  }
};
var safeResolve = (file) => {
  try {
    return require.resolve(file);
  } catch (e) {
    return void 0;
  }
};

// src/presets.ts
var isObject = (val) => val != null && typeof val === "object" && Array.isArray(val) === false;
var isFunction = (val) => typeof val === "function";
function filterPresetsConfig(presetsConfig) {
  return presetsConfig.filter((preset) => {
    const presetName = typeof preset === "string" ? preset : preset.name;
    return !/@storybook[\\\\/]preset-typescript/.test(presetName);
  });
}
function resolvePresetFunction(input, presetOptions, storybookOptions) {
  if (isFunction(input)) {
    return [...input({ ...storybookOptions, ...presetOptions })];
  }
  if (Array.isArray(input)) {
    return [...input];
  }
  return [];
}
var resolveAddonName = (configDir, name, options) => {
  const resolve = name.startsWith("/") ? safeResolve : safeResolveFrom.bind(null, configDir);
  const resolved = resolve(name);
  if (resolved) {
    if (name.match(/\/(manager|register(-panel)?)(\.(js|ts|tsx|jsx))?$/)) {
      return {
        type: "virtual",
        name,
        managerEntries: [resolved]
      };
    }
    if (name.match(/\/(preset)(\.(js|ts|tsx|jsx))?$/)) {
      return {
        type: "presets",
        name: resolved
      };
    }
  }
  const absolutePackageJson = resolved && resolve(`${name}/package.json`);
  const absoluteDir = absolutePackageJson && (0, import_path3.dirname)(absolutePackageJson);
  const absolutizeExport = (exportName) => {
    if (resolve(`${name}${exportName}`))
      return `${absoluteDir}${exportName}`;
    return void 0;
  };
  const path12 = name;
  const managerFile = absolutizeExport(`/manager`);
  const registerFile = absolutizeExport(`/register`) || absolutizeExport(`/register-panel`);
  const previewFile = absolutizeExport(`/preview`);
  const presetFile = resolve(`${path12}/preset`);
  if (!(managerFile || previewFile) && presetFile) {
    return {
      type: "presets",
      name: presetFile
    };
  }
  if (managerFile || registerFile || previewFile || presetFile) {
    const managerEntries = [];
    if (managerFile) {
      managerEntries.push(managerFile);
    }
    if (!managerFile && registerFile && !presetFile) {
      managerEntries.push(registerFile);
    }
    return {
      type: "virtual",
      name: path12,
      ...managerEntries.length ? { managerEntries } : {},
      ...previewFile ? { previewAnnotations: [previewFile] } : {},
      ...presetFile ? { presets: [{ name: presetFile, options }] } : {}
    };
  }
  if (resolved) {
    return {
      type: "presets",
      name: resolved
    };
  }
  return void 0;
};
var map = ({ configDir }) => (item) => {
  const options = isObject(item) ? item.options || void 0 : void 0;
  const name = isObject(item) ? item.name : item;
  try {
    const resolved = resolveAddonName(configDir, name, options);
    return {
      ...options ? { options } : {},
      ...resolved
    };
  } catch (err) {
    import_node_logger.logger.error(
      `Addon value should end in /manager or /preview or /register OR it should be a valid preset https://storybook.js.org/docs/react/addons/writing-presets/
${item}`
    );
  }
  return void 0;
};
async function getContent(input) {
  if (input.type === "virtual") {
    const { type, name: name2, ...rest } = input;
    return rest;
  }
  const name = input.name ? input.name : input;
  return interopRequireDefault(name);
}
async function loadPreset(input, level, storybookOptions) {
  try {
    const name = input.name ? input.name : input;
    const presetOptions = input.options ? input.options : {};
    let contents = await getContent(input);
    if (typeof contents === "function") {
      contents = contents(storybookOptions, presetOptions);
    }
    if (Array.isArray(contents)) {
      const subPresets = contents;
      return loadPresets(subPresets, level + 1, storybookOptions);
    }
    if (isObject(contents)) {
      const { addons: addonsInput, presets: presetsInput, ...rest } = contents;
      const subPresets = resolvePresetFunction(presetsInput, presetOptions, storybookOptions);
      const subAddons = resolvePresetFunction(addonsInput, presetOptions, storybookOptions);
      return [
        ...await loadPresets([...subPresets], level + 1, storybookOptions),
        ...await loadPresets(
          [...subAddons.map(map(storybookOptions))].filter(Boolean),
          level + 1,
          storybookOptions
        ),
        {
          name,
          preset: rest,
          options: presetOptions
        }
      ];
    }
    throw new Error(import_ts_dedent2.dedent`
      ${input} is not a valid preset
    `);
  } catch (e) {
    const warning = level > 0 ? `  Failed to load preset: ${JSON.stringify(input)} on level ${level}` : `  Failed to load preset: ${JSON.stringify(input)}`;
    import_node_logger.logger.warn(warning);
    import_node_logger.logger.error(e);
    return [];
  }
}
async function loadPresets(presets, level, storybookOptions) {
  if (!presets || !Array.isArray(presets) || !presets.length) {
    return [];
  }
  if (!level) {
    import_node_logger.logger.info("=> Loading presets");
  }
  return (await Promise.all(presets.map(async (preset) => loadPreset(preset, level, storybookOptions)))).reduce((acc, loaded) => {
    return acc.concat(loaded);
  }, []);
}
function applyPresets(presets, extension, config, args, storybookOptions) {
  const presetResult = new Promise((res) => res(config));
  if (!presets.length) {
    return presetResult;
  }
  return presets.reduce((accumulationPromise, { preset, options }) => {
    const change = preset[extension];
    if (!change) {
      return accumulationPromise;
    }
    if (typeof change === "function") {
      const extensionFn = change;
      const context = {
        preset,
        combinedOptions: {
          ...storybookOptions,
          ...args,
          ...options,
          presetsList: presets,
          presets: {
            apply: async (ext, c, a = {}) => applyPresets(presets, ext, c, a, storybookOptions)
          }
        }
      };
      return accumulationPromise.then(
        (newConfig) => extensionFn.call(context.preset, newConfig, context.combinedOptions)
      );
    }
    return accumulationPromise.then((newConfig) => {
      if (Array.isArray(newConfig) && Array.isArray(change)) {
        return [...newConfig, ...change];
      }
      if (isObject(newConfig) && isObject(change)) {
        return { ...newConfig, ...change };
      }
      return change;
    });
  }, presetResult);
}
async function getPresets(presets, storybookOptions) {
  const loadedPresets = await loadPresets(presets, 0, storybookOptions);
  return {
    apply: async (extension, config, args = {}) => applyPresets(loadedPresets, extension, config, args, storybookOptions)
  };
}
async function loadAllPresets(options) {
  const { corePresets = [], overridePresets = [], ...restOptions } = options;
  const presetsConfig = [
    ...corePresets,
    ...loadCustomPresets(options),
    ...overridePresets
  ];
  const filteredPresetConfig = filterPresetsConfig(presetsConfig);
  if (filteredPresetConfig.length < presetsConfig.length) {
    import_node_logger.logger.warn(
      "Storybook now supports TypeScript natively. You can safely remove `@storybook/preset-typescript`."
    );
  }
  return getPresets(filteredPresetConfig, restOptions);
}

// src/utils/check-addon-order.ts
var { logger: logger2 } = require("@storybook/node-logger");
var predicateFor = (addon) => (entry) => {
  const name = entry.name || entry;
  return name && name.includes(addon);
};
var isCorrectOrder = (addons, before, after) => {
  const essentialsIndex = addons.findIndex(predicateFor("@storybook/addon-essentials"));
  let beforeIndex = addons.findIndex(predicateFor(before.name));
  let afterIndex = addons.findIndex(predicateFor(after.name));
  if (beforeIndex === -1 && before.inEssentials)
    beforeIndex = essentialsIndex;
  if (afterIndex === -1 && after.inEssentials)
    afterIndex = essentialsIndex;
  return beforeIndex !== -1 && afterIndex !== -1 && beforeIndex <= afterIndex;
};
var checkAddonOrder = async ({ before, after, configFile, getConfig }) => {
  try {
    const config = await getConfig(configFile);
    if (!(config == null ? void 0 : config.addons)) {
      logger2.warn(`Unable to find 'addons' config in main Storybook config`);
      return;
    }
    if (!isCorrectOrder(config.addons, before, after)) {
      const orEssentials = " (or '@storybook/addon-essentials')";
      const beforeText = `'${before.name}'${before.inEssentials ? orEssentials : ""}`;
      const afterText = `'${after.name}'${after.inEssentials ? orEssentials : ""}`;
      logger2.warn(
        `Expected ${beforeText} to be listed before ${afterText} in main Storybook config.`
      );
    }
  } catch (e) {
    logger2.warn(`Unable to load config file: ${configFile}`);
  }
};

// src/utils/envs.ts
var import_lazy_universal_dotenv = require("lazy-universal-dotenv");

// src/utils/paths.ts
var import_path4 = __toESM(require("path"));
var import_find_up = __toESM(require("find-up"));
var getProjectRoot = () => {
  let result;
  try {
    const found = import_find_up.default.sync(".git", { type: "directory" });
    if (found) {
      result = result || import_path4.default.join(found, "..");
    }
  } catch (e) {
  }
  try {
    const found = import_find_up.default.sync(".svn", { type: "directory" });
    if (found) {
      result = result || import_path4.default.join(found, "..");
    }
  } catch (e) {
  }
  try {
    result = result || __dirname.split("node_modules")[0];
  } catch (e) {
  }
  return result || process.cwd();
};
var nodePathsToArray = (nodePath) => nodePath.split(process.platform === "win32" ? ";" : ":").filter(Boolean).map((p) => import_path4.default.resolve("./", p));
var relativePattern = /^\.{1,2}([/\\]|$)/;
function normalizeStoryPath(filename) {
  if (relativePattern.test(filename))
    return filename;
  return `.${import_path4.default.sep}${filename}`;
}

// src/utils/envs.ts
function loadEnvs(options = {}) {
  const defaultNodeEnv = options.production ? "production" : "development";
  const env = {
    NODE_ENV: process.env.NODE_ENV || defaultNodeEnv,
    NODE_PATH: process.env.NODE_PATH || "",
    STORYBOOK: process.env.STORYBOOK || "true",
    PUBLIC_URL: options.production ? "." : ""
  };
  Object.keys(process.env).filter((name) => /^STORYBOOK_/.test(name)).forEach((name) => {
    env[name] = process.env[name];
  });
  const base = Object.entries(env).reduce(
    (acc, [k, v]) => Object.assign(acc, { [k]: JSON.stringify(v) }),
    {}
  );
  const { stringified, raw } = (0, import_lazy_universal_dotenv.getEnvironment)({ nodeEnv: env.NODE_ENV });
  const fullRaw = { ...env, ...raw };
  fullRaw.NODE_PATH = nodePathsToArray(fullRaw.NODE_PATH || "");
  return {
    stringified: { ...base, ...stringified },
    raw: fullRaw
  };
}
var stringifyEnvs = (raw) => Object.entries(raw).reduce((acc, [key, value]) => {
  acc[key] = JSON.stringify(value);
  return acc;
}, {});
var stringifyProcessEnvs = (raw) => {
  const envs = Object.entries(raw).reduce(
    (acc, [key, value]) => {
      acc[`process.env.${key}`] = JSON.stringify(value);
      return acc;
    },
    {
      "process.env.XSTORYBOOK_EXAMPLE_APP": '""'
    }
  );
  return envs;
};

// src/utils/handlebars.ts
var import_handlebars = __toESM(require("handlebars"));
function handlebars(source, data) {
  const template = import_handlebars.default.compile(source);
  return template(data);
}

// src/utils/load-main-config.ts
var import_path5 = __toESM(require("path"));
function loadMainConfig({ configDir }) {
  validateConfigurationFiles(configDir);
  return serverRequire(import_path5.default.resolve(configDir, "main"));
}

// src/utils/get-framework-name.ts
var import_ts_dedent3 = require("ts-dedent");
async function getFrameworkName(options) {
  const framework = await options.presets.apply("framework", "", options);
  if (!framework) {
    throw new Error(import_ts_dedent3.dedent`
      You must specify a framework in '.storybook/main.js' config.

      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#framework-field-mandatory
    `);
  }
  return typeof framework === "object" ? framework.name : framework;
}

// src/utils/get-storybook-configuration.ts
function getStorybookConfiguration(storybookScript, shortName, longName) {
  if (!storybookScript) {
    return null;
  }
  const parts = storybookScript.split(/[\s='"]+/);
  let index = parts.indexOf(longName);
  if (index === -1) {
    index = parts.indexOf(shortName);
  }
  if (index === -1) {
    return null;
  }
  return parts[index + 1];
}

// src/utils/get-storybook-info.ts
var import_path6 = __toESM(require("path"));
var import_fs_extra = __toESM(require("fs-extra"));
var rendererPackages = {
  "@storybook/react": "react",
  "@storybook/vue": "vue",
  "@storybook/vue3": "vue3",
  "@storybook/angular": "angular",
  "@storybook/html": "html",
  "@storybook/web-components": "web-components",
  "@storybook/polymer": "polymer",
  "@storybook/ember": "ember",
  "@storybook/marko": "marko",
  "@storybook/mithril": "mithril",
  "@storybook/riot": "riot",
  "@storybook/svelte": "svelte",
  "@storybook/preact": "preact",
  "@storybook/rax": "rax",
  "@storybook/server": "server"
};
var logger3 = console;
var findDependency = ({ dependencies, devDependencies, peerDependencies }, predicate) => [
  Object.entries(dependencies || {}).find(predicate),
  Object.entries(devDependencies || {}).find(predicate),
  Object.entries(peerDependencies || {}).find(predicate)
];
var getRendererInfo = (packageJson) => {
  const [dep, devDep, peerDep] = findDependency(packageJson, ([key]) => rendererPackages[key]);
  const [pkg, version] = dep || devDep || peerDep || [];
  const renderer = pkg ? rendererPackages[pkg] : void 0;
  if (dep && devDep && dep[0] === devDep[0]) {
    logger3.warn(
      `Found "${dep[0]}" in both "dependencies" and "devDependencies". This is probably a mistake.`
    );
  }
  if (dep && peerDep && dep[0] === peerDep[0]) {
    logger3.warn(
      `Found "${dep[0]}" in both "dependencies" and "peerDependencies". This is probably a mistake.`
    );
  }
  return {
    version,
    framework: renderer,
    frameworkPackage: pkg,
    renderer,
    rendererPackage: pkg
  };
};
var validConfigExtensions = ["ts", "js", "tsx", "jsx", "mjs", "cjs"];
var findConfigFile = (prefix, configDir) => {
  const filePrefix = import_path6.default.join(configDir, prefix);
  const extension = validConfigExtensions.find(
    (ext) => import_fs_extra.default.existsSync(`${filePrefix}.${ext}`)
  );
  return extension ? `${filePrefix}.${extension}` : null;
};
var getConfigInfo = (packageJson) => {
  var _a;
  let configDir = ".storybook";
  const storybookScript = (_a = packageJson.scripts) == null ? void 0 : _a.storybook;
  if (storybookScript) {
    const configParam = getStorybookConfiguration(storybookScript, "-c", "--config-dir");
    if (configParam)
      configDir = configParam;
  }
  return {
    configDir,
    mainConfig: findConfigFile("main", configDir),
    previewConfig: findConfigFile("preview", configDir),
    managerConfig: findConfigFile("manager", configDir)
  };
};
var getStorybookInfo = (packageJson) => {
  const rendererInfo = getRendererInfo(packageJson);
  const configInfo = getConfigInfo(packageJson);
  return {
    ...rendererInfo,
    ...configInfo
  };
};

// src/utils/get-storybook-refs.ts
var import_fs_extra2 = require("fs-extra");
var import_path7 = require("path");
var import_find_up2 = __toESM(require("find-up"));
var import_resolve_from2 = __toESM(require("resolve-from"));
var import_node_logger2 = require("@storybook/node-logger");
var getAutoRefs = async (options) => {
  const location = await (0, import_find_up2.default)("package.json", { cwd: options.configDir });
  if (!location) {
    return {};
  }
  const directory = (0, import_path7.dirname)(location);
  const { dependencies = [], devDependencies = [] } = await (0, import_fs_extra2.readJSON)(location) || {};
  const deps = Object.keys({ ...dependencies, ...devDependencies });
  const list = await Promise.all(
    deps.map(async (d) => {
      try {
        const l = (0, import_resolve_from2.default)(directory, (0, import_path7.join)(d, "package.json"));
        const { storybook, name, version } = await (0, import_fs_extra2.readJSON)(l) || {};
        if (storybook == null ? void 0 : storybook.url) {
          return { id: name, ...storybook, version };
        }
      } catch {
        import_node_logger2.logger.warn(`unable to find package.json for ${d}`);
        return void 0;
      }
      return void 0;
    })
  );
  return list.filter(Boolean).reduce(
    (acc, cur) => ({
      ...acc,
      [cur.id]: {
        id: cur.id.toLowerCase(),
        url: stripTrailingSlash(cur.url),
        title: cur.title,
        version: cur.version
      }
    }),
    {}
  );
};
var checkRef = (url) => fetch(`${url}/iframe.html`).then(
  async ({ ok, status }) => {
    if (ok) {
      if (status !== 200) {
        return false;
      }
      const data = await fetch(`${url}/iframe.html`, {
        headers: { Accept: "application/json" }
      });
      if (data.ok && (await data.json().catch((e) => ({}))).loginUrl) {
        return false;
      }
    }
    return ok;
  },
  () => false
);
var stripTrailingSlash = (url) => url.replace(/\/$/, "");
var toTitle = (input) => {
  const result = input.replace(/[A-Z]/g, (f) => ` ${f}`).replace(/[-_][A-Z]/gi, (f) => ` ${f.toUpperCase()}`).replace(/-/g, " ").replace(/_/g, " ");
  return `${result.substring(0, 1).toUpperCase()}${result.substring(1)}`.trim();
};
async function getRefs(options) {
  const refs = await options.presets.apply("refs", await getAutoRefs(options));
  Object.entries(refs).forEach(([key, value]) => {
    if (value.disable) {
      delete refs[key];
      return;
    }
    refs[key.toLowerCase()] = {
      ...value,
      id: key.toLowerCase(),
      title: value.title || toTitle(value.id || key),
      url: stripTrailingSlash(value.url)
    };
  });
  await Promise.all(
    Object.entries(refs).map(async ([k, value]) => {
      const ok = await checkRef(value.url);
      refs[k] = { ...value, type: ok ? "server-checked" : "unknown" };
    })
  );
  return refs;
}

// src/utils/load-manager-or-addons-file.ts
var import_path8 = __toESM(require("path"));
var import_node_logger3 = require("@storybook/node-logger");
var import_ts_dedent4 = require("ts-dedent");
function loadManagerOrAddonsFile({ configDir }) {
  const storybookCustomAddonsPath = getInterpretedFile(import_path8.default.resolve(configDir, "addons"));
  const storybookCustomManagerPath = getInterpretedFile(import_path8.default.resolve(configDir, "manager"));
  if (storybookCustomAddonsPath || storybookCustomManagerPath) {
    import_node_logger3.logger.info("=> Loading custom manager config");
  }
  if (storybookCustomAddonsPath && storybookCustomManagerPath) {
    throw new Error(import_ts_dedent4.dedent`
      You have both a "addons.js" and a "manager.js", remove the "addons.js" file from your configDir (${import_path8.default.resolve(
      configDir,
      "addons"
    )})`);
  }
  return storybookCustomManagerPath || storybookCustomAddonsPath;
}

// src/utils/load-preview-or-config-file.ts
var import_path9 = __toESM(require("path"));
var import_ts_dedent5 = require("ts-dedent");
function loadPreviewOrConfigFile({ configDir }) {
  const storybookConfigPath = getInterpretedFile(import_path9.default.resolve(configDir, "config"));
  const storybookPreviewPath = getInterpretedFile(import_path9.default.resolve(configDir, "preview"));
  if (storybookConfigPath && storybookPreviewPath) {
    throw new Error(import_ts_dedent5.dedent`
      You have both a "config.js" and a "preview.js", remove the "config.js" file from your configDir (${import_path9.default.resolve(
      configDir,
      "config"
    )})`);
  }
  return storybookPreviewPath || storybookConfigPath;
}

// src/utils/log-config.ts
var import_chalk = __toESM(require("chalk"));
function logConfig(caption, config) {
  console.log(import_chalk.default.cyan(caption));
  console.dir(config, { depth: null });
}

// src/utils/print-duration.ts
var import_pretty_hrtime = __toESM(require("pretty-hrtime"));
var printDuration = (startTime) => (0, import_pretty_hrtime.default)(process.hrtime(startTime)).replace(" ms", " milliseconds").replace(" s", " seconds").replace(" m", " minutes");

// src/utils/progress-reporting.ts
var useProgressReporting = async (router, startTime, options) => {
  var _a;
  let value = 0;
  let totalModules;
  let reportProgress = () => {
  };
  router.get("/progress", (request, response) => {
    let closed = false;
    const close = () => {
      closed = true;
      response.end();
    };
    response.on("close", close);
    if (closed || response.writableEnded)
      return;
    response.setHeader("Cache-Control", "no-cache");
    response.setHeader("Content-Type", "text/event-stream");
    response.setHeader("Connection", "keep-alive");
    response.flushHeaders();
    reportProgress = (progress) => {
      if (closed || response.writableEnded)
        return;
      response.write(`data: ${JSON.stringify(progress)}

`);
      response.flush();
      if (progress.value === 1)
        close();
    };
  });
  const handler = (newValue, message, arg3) => {
    value = Math.max(newValue, value);
    const progress = { value, message: message.charAt(0).toUpperCase() + message.slice(1) };
    if (message === "building") {
      const counts = arg3 && arg3.match(/(\d+)\/(\d+)/) || [];
      const complete = parseInt(counts[1], 10);
      const total = parseInt(counts[2], 10);
      if (!Number.isNaN(complete) && !Number.isNaN(total)) {
        progress.modules = { complete, total };
        totalModules = total;
      }
    }
    if (value === 1) {
      if (options.cache) {
        options.cache.set("modulesCount", totalModules);
      }
      if (!progress.message) {
        progress.message = `Completed in ${printDuration(startTime)}.`;
      }
    }
    reportProgress(progress);
  };
  const modulesCount = await ((_a = options.cache) == null ? void 0 : _a.get("modulesCount").catch(() => {
  })) || 1e3;
  return { handler, modulesCount };
};

// src/utils/resolve-path-in-sb-cache.ts
var import_path10 = __toESM(require("path"));
var import_pkg_dir = __toESM(require("pkg-dir"));
function resolvePathInStorybookCache(fileOrDirectoryName) {
  const cwd = process.cwd();
  const projectDir = import_pkg_dir.default.sync(cwd);
  let cacheDirectory;
  if (!projectDir) {
    cacheDirectory = import_path10.default.resolve(cwd, ".cache/storybook");
  } else {
    cacheDirectory = import_path10.default.resolve(projectDir, "node_modules/.cache/storybook");
  }
  return import_path10.default.join(cacheDirectory, fileOrDirectoryName);
}

// src/utils/file-cache.ts
var import_file_system_cache = __toESM(require("file-system-cache"));
function createFileSystemCache(options) {
  return (0, import_file_system_cache.default)(options);
}

// src/utils/cache.ts
var cache = createFileSystemCache({
  basePath: resolvePathInStorybookCache("dev-server"),
  ns: "storybook"
});

// src/utils/template.ts
var import_path11 = __toESM(require("path"));
var import_pkg_dir2 = require("pkg-dir");
var import_fs2 = __toESM(require("fs"));
var interpolate = (string, data = {}) => Object.entries(data).reduce((acc, [k, v]) => acc.replace(new RegExp(`%${k}%`, "g"), v), string);
function getPreviewBodyTemplate(configDirPath, interpolations) {
  const base = import_fs2.default.readFileSync(`${(0, import_pkg_dir2.sync)(__dirname)}/templates/base-preview-body.html`, "utf8");
  const bodyHtmlPath = import_path11.default.resolve(configDirPath, "preview-body.html");
  let result = base;
  if (import_fs2.default.existsSync(bodyHtmlPath)) {
    result = import_fs2.default.readFileSync(bodyHtmlPath, "utf8") + result;
  }
  return interpolate(result, interpolations);
}
function getPreviewHeadTemplate(configDirPath, interpolations) {
  const base = import_fs2.default.readFileSync(`${(0, import_pkg_dir2.sync)(__dirname)}/templates/base-preview-head.html`, "utf8");
  const headHtmlPath = import_path11.default.resolve(configDirPath, "preview-head.html");
  let result = base;
  if (import_fs2.default.existsSync(headHtmlPath)) {
    result += import_fs2.default.readFileSync(headHtmlPath, "utf8");
  }
  return interpolate(result, interpolations);
}
function getPreviewMainTemplate() {
  return `${(0, import_pkg_dir2.sync)(__dirname)}/templates/preview.ejs`;
}

// src/utils/interpolate.ts
var interpolate2 = (template, bindings) => {
  return Object.entries(bindings).reduce((acc, [k, v]) => {
    const escapedString = v.replace(/\\/g, "/").replace(/\$/g, "$$$");
    return acc.replace(new RegExp(`{{${k}}}`, "g"), escapedString);
  }, template);
};

// src/utils/glob-to-regexp.ts
var import_picomatch = require("picomatch");
function globToRegexp(glob2) {
  const regex = (0, import_picomatch.makeRe)(glob2, {
    fastpaths: false,
    noglobstar: false,
    bash: false
  });
  if (!regex.source.startsWith("^")) {
    throw new Error(`Invalid glob: >> ${glob2} >> ${regex}`);
  }
  if (!glob2.startsWith("./")) {
    return regex;
  }
  return new RegExp(
    ["^\\.", glob2.startsWith("./**") ? "" : "[\\\\/]", regex.source.substring(1)].join("")
  );
}

// src/utils/normalize-stories.ts
var import_fs3 = __toESM(require("fs"));
var import_path12 = __toESM(require("path"));
var import_util_deprecate2 = __toESM(require("util-deprecate"));
var import_ts_dedent6 = require("ts-dedent");
var import_picomatch2 = require("picomatch");
var import_slash = __toESM(require("slash"));
var DEFAULT_TITLE_PREFIX = "";
var DEFAULT_FILES = "**/*.@(mdx|stories.mdx|stories.tsx|stories.ts|stories.jsx|stories.js)";
var fixBadGlob = (0, import_util_deprecate2.default)(
  (match) => {
    return match.input.replace(match[1], `@${match[1]}`);
  },
  import_ts_dedent6.dedent`
    You have specified an invalid glob, we've attempted to fix it, please ensure that the glob you specify is valid. See: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#correct-globs-in-mainjs
  `
);
var detectBadGlob = (val) => {
  const match = val.match(/\.(\([^)]+\))/);
  if (match) {
    return fixBadGlob(match);
  }
  return val;
};
var isDirectory = (configDir, entry) => {
  try {
    return import_fs3.default.lstatSync(import_path12.default.resolve(configDir, entry)).isDirectory();
  } catch (err) {
    return false;
  }
};
var getDirectoryFromWorkingDir = ({
  configDir,
  workingDir,
  directory
}) => {
  const directoryFromConfig = import_path12.default.resolve(configDir, directory);
  const directoryFromWorking = import_path12.default.relative(workingDir, directoryFromConfig);
  return normalizeStoryPath(directoryFromWorking);
};
var normalizeStoriesEntry = (entry, { configDir, workingDir }) => {
  let specifierWithoutMatcher;
  if (typeof entry === "string") {
    const fixedEntry = detectBadGlob(entry);
    const globResult = (0, import_picomatch2.scan)(fixedEntry);
    if (globResult.isGlob) {
      const directory2 = globResult.prefix + globResult.base;
      const files2 = globResult.glob;
      specifierWithoutMatcher = {
        titlePrefix: DEFAULT_TITLE_PREFIX,
        directory: directory2,
        files: files2
      };
    } else if (isDirectory(configDir, entry)) {
      specifierWithoutMatcher = {
        titlePrefix: DEFAULT_TITLE_PREFIX,
        directory: entry,
        files: DEFAULT_FILES
      };
    } else {
      specifierWithoutMatcher = {
        titlePrefix: DEFAULT_TITLE_PREFIX,
        directory: import_path12.default.dirname(entry),
        files: import_path12.default.basename(entry)
      };
    }
  } else {
    specifierWithoutMatcher = {
      titlePrefix: DEFAULT_TITLE_PREFIX,
      files: DEFAULT_FILES,
      ...entry
    };
  }
  const files = (0, import_slash.default)(specifierWithoutMatcher.files);
  const { directory: directoryRelativeToConfig } = specifierWithoutMatcher;
  const directory = (0, import_slash.default)(
    getDirectoryFromWorkingDir({
      configDir,
      workingDir,
      directory: directoryRelativeToConfig
    })
  ).replace(/\/$/, "");
  const importPathMatcher = globToRegexp(`${directory}/${files}`);
  return {
    ...specifierWithoutMatcher,
    directory,
    importPathMatcher
  };
};
var normalizeStories = (entries, options) => entries.map((entry) => normalizeStoriesEntry(entry, options));

// src/utils/readTemplate.ts
var import_fs_extra3 = __toESM(require("fs-extra"));
async function readTemplate(filename) {
  return import_fs_extra3.default.readFile(filename, {
    encoding: "utf8"
  });
}

// src/utils/findDistEsm.ts
var import_path13 = __toESM(require("path"));
var import_find_up3 = require("find-up");
var findDistEsm = (cwd, relativePath) => {
  const nearestPackageJson = (0, import_find_up3.sync)("package.json", { cwd });
  if (!nearestPackageJson) {
    throw new Error(`Could not find package.json in: ${cwd}`);
  }
  const packageDir = import_path13.default.dirname(nearestPackageJson);
  return import_path13.default.join(packageDir, "dist", "esm", relativePath);
};

// src/utils/symlinks.ts
function isPreservingSymlinks() {
  const { NODE_OPTIONS, NODE_PRESERVE_SYMLINKS } = process.env;
  return !!NODE_PRESERVE_SYMLINKS || (NODE_OPTIONS == null ? void 0 : NODE_OPTIONS.includes("--preserve-symlinks"));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  boost,
  cache,
  checkAddonOrder,
  createFileSystemCache,
  filterPresetsConfig,
  findDistEsm,
  getAutoRefs,
  getDirectoryFromWorkingDir,
  getFrameworkName,
  getInterpretedFile,
  getInterpretedFileWithExt,
  getPresets,
  getPreviewBodyTemplate,
  getPreviewHeadTemplate,
  getPreviewMainTemplate,
  getProjectRoot,
  getRefs,
  getStorybookConfiguration,
  getStorybookInfo,
  globToRegexp,
  handlebars,
  interopRequireDefault,
  interpolate,
  isPreservingSymlinks,
  loadAllPresets,
  loadCustomPresets,
  loadEnvs,
  loadMainConfig,
  loadManagerOrAddonsFile,
  loadPreset,
  loadPreviewOrConfigFile,
  logConfig,
  nodePathsToArray,
  normalizeStories,
  normalizeStoriesEntry,
  normalizeStoryPath,
  readTemplate,
  resolveAddonName,
  resolvePathInStorybookCache,
  serverRequire,
  serverResolve,
  stringifyEnvs,
  stringifyProcessEnvs,
  useProgressReporting,
  validateConfigurationFiles
});
