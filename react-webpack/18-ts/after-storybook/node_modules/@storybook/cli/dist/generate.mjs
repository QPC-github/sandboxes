var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));

// <define:process.env>
var define_process_env_default = {};

// src/generate.ts
import program from "commander";
import path14 from "path";
import chalk19 from "chalk";
import envinfo from "envinfo";
import leven from "leven";
import { sync as readUpSync3 } from "read-pkg-up";
import { logger as logger22 } from "@storybook/node-logger";

// src/initiate.ts
import { UpdateNotifier } from "update-notifier";
import chalk15 from "chalk";
import prompts3 from "prompts";
import { telemetry } from "@storybook/telemetry";

// src/project_types.ts
import { validRange, minVersion } from "@storybook/semver";
function ltMajor(versionRange, major) {
  return validRange(versionRange) && minVersion(versionRange).major < major;
}
function eqMajor(versionRange, major) {
  return validRange(versionRange) && minVersion(versionRange).major === major;
}
var SUPPORTED_RENDERERS = [
  "react",
  "react-native",
  "vue",
  "vue3",
  "angular",
  "mithril",
  "riot",
  "ember",
  "marionette",
  "marko",
  "preact",
  "svelte",
  "rax",
  "aurelia"
];
var ProjectType = /* @__PURE__ */ ((ProjectType2) => {
  ProjectType2["UNDETECTED"] = "UNDETECTED";
  ProjectType2["UNSUPPORTED"] = "UNSUPPORTED";
  ProjectType2["REACT_SCRIPTS"] = "REACT_SCRIPTS";
  ProjectType2["REACT"] = "REACT";
  ProjectType2["REACT_NATIVE"] = "REACT_NATIVE";
  ProjectType2["REACT_PROJECT"] = "REACT_PROJECT";
  ProjectType2["WEBPACK_REACT"] = "WEBPACK_REACT";
  ProjectType2["VUE"] = "VUE";
  ProjectType2["VUE3"] = "VUE3";
  ProjectType2["SFC_VUE"] = "SFC_VUE";
  ProjectType2["ANGULAR"] = "ANGULAR";
  ProjectType2["EMBER"] = "EMBER";
  ProjectType2["ALREADY_HAS_STORYBOOK"] = "ALREADY_HAS_STORYBOOK";
  ProjectType2["WEB_COMPONENTS"] = "WEB_COMPONENTS";
  ProjectType2["MITHRIL"] = "MITHRIL";
  ProjectType2["MARIONETTE"] = "MARIONETTE";
  ProjectType2["MARKO"] = "MARKO";
  ProjectType2["HTML"] = "HTML";
  ProjectType2["RIOT"] = "RIOT";
  ProjectType2["PREACT"] = "PREACT";
  ProjectType2["SVELTE"] = "SVELTE";
  ProjectType2["RAX"] = "RAX";
  ProjectType2["AURELIA"] = "AURELIA";
  ProjectType2["SERVER"] = "SERVER";
  return ProjectType2;
})(ProjectType || {});
var supportedTemplates = [
  {
    preset: "SFC_VUE" /* SFC_VUE */,
    dependencies: {
      "vue-loader": (versionRange) => ltMajor(versionRange, 16),
      vuetify: (versionRange) => ltMajor(versionRange, 3)
    },
    matcherFunction: ({ dependencies }) => {
      return dependencies.some(Boolean);
    }
  },
  {
    preset: "VUE" /* VUE */,
    dependencies: {
      vue: (versionRange) => ltMajor(versionRange, 3),
      nuxt: (versionRange) => ltMajor(versionRange, 3)
    },
    matcherFunction: ({ dependencies }) => {
      return dependencies.some(Boolean);
    }
  },
  {
    preset: "VUE3" /* VUE3 */,
    dependencies: {
      vue: (versionRange) => versionRange === "next" || eqMajor(versionRange, 3)
    },
    matcherFunction: ({ dependencies }) => {
      return dependencies.some(Boolean);
    }
  },
  {
    preset: "EMBER" /* EMBER */,
    dependencies: ["ember-cli"],
    matcherFunction: ({ dependencies }) => {
      return dependencies.every(Boolean);
    }
  },
  {
    preset: "REACT_PROJECT" /* REACT_PROJECT */,
    peerDependencies: ["react"],
    matcherFunction: ({ peerDependencies }) => {
      return peerDependencies.every(Boolean);
    }
  },
  {
    preset: "REACT_NATIVE" /* REACT_NATIVE */,
    dependencies: ["react-native", "react-native-scripts"],
    matcherFunction: ({ dependencies }) => {
      return dependencies.some(Boolean);
    }
  },
  {
    preset: "REACT_SCRIPTS" /* REACT_SCRIPTS */,
    files: ["/node_modules/.bin/react-scripts"],
    dependencies: ["react-scripts"],
    matcherFunction: ({ dependencies, files }) => {
      return dependencies.every(Boolean) || files.every(Boolean);
    }
  },
  {
    preset: "WEBPACK_REACT" /* WEBPACK_REACT */,
    dependencies: ["react", "webpack"],
    matcherFunction: ({ dependencies }) => {
      return dependencies.every(Boolean);
    }
  },
  {
    preset: "REACT" /* REACT */,
    dependencies: ["react"],
    matcherFunction: ({ dependencies }) => {
      return dependencies.every(Boolean);
    }
  },
  {
    preset: "ANGULAR" /* ANGULAR */,
    dependencies: ["@angular/core"],
    matcherFunction: ({ dependencies }) => {
      return dependencies.every(Boolean);
    }
  },
  {
    preset: "WEB_COMPONENTS" /* WEB_COMPONENTS */,
    dependencies: ["lit-element", "lit-html", "lit"],
    matcherFunction: ({ dependencies }) => {
      return dependencies.some(Boolean);
    }
  },
  {
    preset: "MITHRIL" /* MITHRIL */,
    dependencies: ["mithril"],
    matcherFunction: ({ dependencies }) => {
      return dependencies.every(Boolean);
    }
  },
  {
    preset: "MARIONETTE" /* MARIONETTE */,
    dependencies: ["backbone.marionette"],
    matcherFunction: ({ dependencies }) => {
      return dependencies.every(Boolean);
    }
  },
  {
    preset: "MARKO" /* MARKO */,
    dependencies: ["marko"],
    matcherFunction: ({ dependencies }) => {
      return dependencies.every(Boolean);
    }
  },
  {
    preset: "RIOT" /* RIOT */,
    dependencies: ["riot"],
    matcherFunction: ({ dependencies }) => {
      return dependencies.every(Boolean);
    }
  },
  {
    preset: "PREACT" /* PREACT */,
    dependencies: ["preact"],
    matcherFunction: ({ dependencies }) => {
      return dependencies.every(Boolean);
    }
  },
  {
    preset: "SVELTE" /* SVELTE */,
    dependencies: ["svelte"],
    matcherFunction: ({ dependencies }) => {
      return dependencies.every(Boolean);
    }
  },
  {
    preset: "RAX" /* RAX */,
    dependencies: ["rax"],
    matcherFunction: ({ dependencies }) => {
      return dependencies.every(Boolean);
    }
  },
  {
    preset: "AURELIA" /* AURELIA */,
    dependencies: ["aurelia-bootstrapper"],
    matcherFunction: ({ dependencies }) => {
      return dependencies.every(Boolean);
    }
  }
];
var unsupportedTemplate = {
  preset: "UNSUPPORTED" /* UNSUPPORTED */,
  dependencies: {
    nuxt: (versionRange) => eqMajor(versionRange, 3)
  },
  matcherFunction: ({ dependencies }) => {
    return dependencies.some(Boolean);
  }
};
var notInstallableProjectTypes = [
  "UNDETECTED" /* UNDETECTED */,
  "UNSUPPORTED" /* UNSUPPORTED */,
  "ALREADY_HAS_STORYBOOK" /* ALREADY_HAS_STORYBOOK */
];
var installableProjectTypes = Object.values(ProjectType).filter((type) => !notInstallableProjectTypes.includes(type)).map((type) => type.toLowerCase());

// src/detect.ts
import path2 from "path";
import fs2 from "fs";
import findUp from "find-up";

// src/helpers.ts
import path, { join } from "path";
import fs from "fs";
import fse from "fs-extra";
import chalk from "chalk";
import { satisfies } from "@storybook/semver";
import stripJsonComments from "strip-json-comments";

// src/dirs.ts
import { dirname } from "path";
function getBaseDir() {
  return dirname(__require.resolve("@storybook/cli/package.json"));
}

// src/versions.ts
var versions_default = {
  "@storybook/addon-a11y": "7.0.0-alpha.35",
  "@storybook/addon-actions": "7.0.0-alpha.35",
  "@storybook/addon-backgrounds": "7.0.0-alpha.35",
  "@storybook/addon-controls": "7.0.0-alpha.35",
  "@storybook/addon-docs": "7.0.0-alpha.35",
  "@storybook/addon-essentials": "7.0.0-alpha.35",
  "@storybook/addon-highlight": "7.0.0-alpha.35",
  "@storybook/addon-interactions": "7.0.0-alpha.35",
  "@storybook/addon-jest": "7.0.0-alpha.35",
  "@storybook/addon-links": "7.0.0-alpha.35",
  "@storybook/addon-measure": "7.0.0-alpha.35",
  "@storybook/addon-outline": "7.0.0-alpha.35",
  "@storybook/addon-storyshots": "7.0.0-alpha.35",
  "@storybook/addon-storyshots-puppeteer": "7.0.0-alpha.35",
  "@storybook/addon-storysource": "7.0.0-alpha.35",
  "@storybook/addon-toolbars": "7.0.0-alpha.35",
  "@storybook/addon-viewport": "7.0.0-alpha.35",
  "@storybook/addons": "7.0.0-alpha.35",
  "@storybook/angular": "7.0.0-alpha.35",
  "@storybook/api": "7.0.0-alpha.35",
  "@storybook/blocks": "7.0.0-alpha.35",
  "@storybook/builder-manager": "7.0.0-alpha.35",
  "@storybook/builder-vite": "7.0.0-alpha.35",
  "@storybook/builder-webpack5": "7.0.0-alpha.35",
  "@storybook/channel-postmessage": "7.0.0-alpha.35",
  "@storybook/channel-websocket": "7.0.0-alpha.35",
  "@storybook/channels": "7.0.0-alpha.35",
  "@storybook/cli": "7.0.0-alpha.35",
  "@storybook/client-api": "7.0.0-alpha.35",
  "@storybook/client-logger": "7.0.0-alpha.35",
  "@storybook/codemod": "7.0.0-alpha.35",
  "@storybook/components": "7.0.0-alpha.35",
  "@storybook/core-client": "7.0.0-alpha.35",
  "@storybook/core-common": "7.0.0-alpha.35",
  "@storybook/core-events": "7.0.0-alpha.35",
  "@storybook/core-server": "7.0.0-alpha.35",
  "@storybook/core-webpack": "7.0.0-alpha.35",
  "@storybook/csf-tools": "7.0.0-alpha.35",
  "@storybook/docs-tools": "7.0.0-alpha.35",
  "@storybook/ember": "7.0.0-alpha.35",
  "@storybook/html": "7.0.0-alpha.35",
  "@storybook/html-webpack5": "7.0.0-alpha.35",
  "@storybook/instrumenter": "7.0.0-alpha.35",
  "@storybook/node-logger": "7.0.0-alpha.35",
  "@storybook/postinstall": "7.0.0-alpha.35",
  "@storybook/preact": "7.0.0-alpha.35",
  "@storybook/preact-webpack5": "7.0.0-alpha.35",
  "@storybook/preset-html-webpack": "7.0.0-alpha.35",
  "@storybook/preset-preact-webpack": "7.0.0-alpha.35",
  "@storybook/preset-react-webpack": "7.0.0-alpha.35",
  "@storybook/preset-server-webpack": "7.0.0-alpha.35",
  "@storybook/preset-svelte-webpack": "7.0.0-alpha.35",
  "@storybook/preset-vue-webpack": "7.0.0-alpha.35",
  "@storybook/preset-vue3-webpack": "7.0.0-alpha.35",
  "@storybook/preset-web-components-webpack": "7.0.0-alpha.35",
  "@storybook/preview-web": "7.0.0-alpha.35",
  "@storybook/react": "7.0.0-alpha.35",
  "@storybook/react-vite": "7.0.0-alpha.35",
  "@storybook/react-webpack5": "7.0.0-alpha.35",
  "@storybook/router": "7.0.0-alpha.35",
  "@storybook/server": "7.0.0-alpha.35",
  "@storybook/server-webpack5": "7.0.0-alpha.35",
  "@storybook/source-loader": "7.0.0-alpha.35",
  "@storybook/store": "7.0.0-alpha.35",
  "@storybook/svelte": "7.0.0-alpha.35",
  "@storybook/svelte-vite": "7.0.0-alpha.35",
  "@storybook/svelte-webpack5": "7.0.0-alpha.35",
  "@storybook/telemetry": "7.0.0-alpha.35",
  "@storybook/theming": "7.0.0-alpha.35",
  "@storybook/ui": "7.0.0-alpha.35",
  "@storybook/vue": "7.0.0-alpha.35",
  "@storybook/vue-vite": "7.0.0-alpha.35",
  "@storybook/vue-webpack5": "7.0.0-alpha.35",
  "@storybook/vue3": "7.0.0-alpha.35",
  "@storybook/vue3-vite": "7.0.0-alpha.35",
  "@storybook/vue3-webpack5": "7.0.0-alpha.35",
  "@storybook/web-components": "7.0.0-alpha.35",
  "@storybook/web-components-webpack5": "7.0.0-alpha.35",
  "@storybook/web-components-vite": "7.0.0-alpha.35",
  sb: "7.0.0-alpha.35",
  storybook: "7.0.0-alpha.35"
};

// src/helpers.ts
var logger = console;
function getBowerJson() {
  const bowerJsonPath = path.resolve("bower.json");
  if (!fs.existsSync(bowerJsonPath)) {
    return false;
  }
  const jsonContent = fs.readFileSync(bowerJsonPath, "utf8");
  return JSON.parse(jsonContent);
}
function readFileAsJson(jsonPath, allowComments) {
  const filePath = path.resolve(jsonPath);
  if (!fs.existsSync(filePath)) {
    return false;
  }
  const fileContent = fs.readFileSync(filePath, "utf8");
  const jsonContent = allowComments ? stripJsonComments(fileContent) : fileContent;
  try {
    return JSON.parse(jsonContent);
  } catch (e) {
    logger.error(chalk.red(`Invalid json in file: ${filePath}`));
    throw e;
  }
}
var writeFileAsJson = (jsonPath, content) => {
  const filePath = path.resolve(jsonPath);
  if (!fs.existsSync(filePath)) {
    return false;
  }
  fs.writeFileSync(filePath, `${JSON.stringify(content, null, 2)}
`);
  return true;
};
var commandLog = (message) => {
  process.stdout.write(chalk.cyan(" \u2022 ") + message);
  return (errorMessage, errorInfo) => {
    if (errorMessage) {
      process.stdout.write(`. ${chalk.red("\u2716")}
`);
      logger.error(`
     ${chalk.red(errorMessage)}`);
      if (!errorInfo) {
        return;
      }
      const newErrorInfo = errorInfo.split("\n").map((line) => `     ${chalk.dim(line)}`).join("\n");
      logger.error(`${newErrorInfo}
`);
      return;
    }
    process.stdout.write(`. ${chalk.green("\u2713")}
`);
  };
};
function paddedLog(message) {
  const newMessage = message.split("\n").map((line) => `    ${line}`).join("\n");
  logger.log(newMessage);
}
function getChars(char, amount) {
  let line = "";
  for (let lc = 0; lc < amount; lc += 1) {
    line += char;
  }
  return line;
}
function codeLog(codeLines, leftPadAmount) {
  let maxLength = 0;
  const newLines = codeLines.map((line) => {
    maxLength = line.length > maxLength ? line.length : maxLength;
    return line;
  });
  const finalResult = newLines.map((line) => {
    const rightPadAmount = maxLength - line.length;
    let newLine = line + getChars(" ", rightPadAmount);
    newLine = getChars(" ", leftPadAmount || 2) + chalk.inverse(` ${newLine} `);
    return newLine;
  }).join("\n");
  logger.log(finalResult);
}
async function getBabelDependencies(packageManager, packageJson) {
  const dependenciesToAdd = [];
  let babelLoaderVersion = "^8.0.0-0";
  const babelCoreVersion = packageJson.dependencies["babel-core"] || packageJson.devDependencies["babel-core"];
  if (!babelCoreVersion) {
    if (!packageJson.dependencies["@babel/core"] && !packageJson.devDependencies["@babel/core"]) {
      const babelCoreInstallVersion = await packageManager.getVersion("@babel/core");
      dependenciesToAdd.push(`@babel/core@${babelCoreInstallVersion}`);
    }
  } else {
    const latestCompatibleBabelVersion = await packageManager.latestVersion(
      "babel-core",
      babelCoreVersion
    );
    if (satisfies(latestCompatibleBabelVersion, "^6.0.0")) {
      babelLoaderVersion = "^7.0.0";
    }
  }
  if (!packageJson.dependencies["babel-loader"] && !packageJson.devDependencies["babel-loader"]) {
    const babelLoaderInstallVersion = await packageManager.getVersion(
      "babel-loader",
      babelLoaderVersion
    );
    dependenciesToAdd.push(`babel-loader@${babelLoaderInstallVersion}`);
  }
  return dependenciesToAdd;
}
function copyTemplate(templateRoot) {
  const templateDir = path.resolve(templateRoot, `template-csf/`);
  if (!fs.existsSync(templateDir)) {
    throw new Error(`Couldn't find template dir`);
  }
  fse.copySync(templateDir, ".", { overwrite: true });
}
async function copyComponents(renderer, language) {
  const languageFolderMapping = {
    javascript: "js",
    typescript: "ts"
  };
  const componentsPath = async () => {
    const baseDir = getBaseDir();
    const assetsRoot = join(baseDir, "rendererAssets");
    const assetsRenderer = join(assetsRoot, renderer);
    const assetsLanguage = join(assetsRenderer, languageFolderMapping[language]);
    if (await fse.pathExists(assetsLanguage)) {
      return assetsLanguage;
    }
    const assetsJS = join(assetsRenderer, languageFolderMapping.javascript);
    if (await fse.pathExists(assetsJS)) {
      return assetsJS;
    }
    if (await fse.pathExists(assetsRenderer)) {
      return assetsRenderer;
    }
    throw new Error(`Unsupported renderer: ${renderer}`);
  };
  const targetPath = async () => {
    if (await fse.pathExists("./src")) {
      return "./src/stories";
    }
    return "./stories";
  };
  const destinationPath = await targetPath();
  await fse.copy(await componentsPath(), destinationPath, { overwrite: true });
  await fse.copy(join(getBaseDir(), "rendererAssets/common"), destinationPath, {
    overwrite: true
  });
}
function getStorybookVersionSpecifier(packageJson) {
  const allDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };
  const storybookPackage = Object.keys(allDeps).find(
    (name) => {
      return versions_default[name];
    }
  );
  if (!storybookPackage) {
    throw new Error(`Couldn't find any official storybook packages in package.json`);
  }
  return allDeps[storybookPackage];
}

// src/detect-nextjs.ts
var regex = /[\s"\n]next.*?(\d+).*/;
var detectNextJS = (packageManager) => {
  try {
    let out = "";
    if (packageManager.type === "npm") {
      try {
        out = packageManager.executeCommand("npm", ["ls", "next"]);
      } catch (e2) {
        out = packageManager.executeCommand("npm", ["why", "next"]);
      }
    } else {
      out = packageManager.executeCommand("yarn", ["why", "next"]);
    }
    const [, version] = out.match(regex);
    return version && parseInt(version, 10) ? parseInt(version, 10) : false;
  } catch (err) {
  }
  return false;
};

// src/detect.ts
var viteConfigFiles = ["vite.config.ts", "vite.config.js", "vite.config.mjs"];
var hasDependency = (packageJson, name, matcher) => {
  const version = packageJson.dependencies?.[name] || packageJson.devDependencies?.[name];
  if (version && typeof matcher === "function") {
    return matcher(version);
  }
  return !!version;
};
var hasPeerDependency = (packageJson, name, matcher) => {
  const version = packageJson.peerDependencies?.[name];
  if (version && typeof matcher === "function") {
    return matcher(version);
  }
  return !!version;
};
var getFrameworkPreset = (packageJson, framework) => {
  const matcher = {
    dependencies: [false],
    peerDependencies: [false],
    files: [false]
  };
  const { preset, files, dependencies, peerDependencies, matcherFunction } = framework;
  let dependencySearches = [];
  if (Array.isArray(dependencies)) {
    dependencySearches = dependencies.map((name) => [name, void 0]);
  } else if (typeof dependencies === "object") {
    dependencySearches = Object.entries(dependencies);
  }
  if (dependencySearches.length > 0) {
    matcher.dependencies = dependencySearches.map(
      ([name, matchFn]) => hasDependency(packageJson, name, matchFn)
    );
  }
  let peerDependencySearches = [];
  if (Array.isArray(peerDependencies)) {
    peerDependencySearches = peerDependencies.map((name) => [name, void 0]);
  } else if (typeof peerDependencies === "object") {
    peerDependencySearches = Object.entries(peerDependencies);
  }
  if (peerDependencySearches.length > 0) {
    matcher.peerDependencies = peerDependencySearches.map(
      ([name, matchFn]) => hasPeerDependency(packageJson, name, matchFn)
    );
  }
  if (Array.isArray(files) && files.length > 0) {
    matcher.files = files.map((name) => fs2.existsSync(path2.join(process.cwd(), name)));
  }
  return matcherFunction(matcher) ? preset : null;
};
function detectFrameworkPreset(packageJson = {}) {
  const result = [...supportedTemplates, unsupportedTemplate].find((framework) => {
    return getFrameworkPreset(packageJson, framework) !== null;
  });
  return result ? result.preset : "UNDETECTED" /* UNDETECTED */;
}
function detectBuilder(packageManager) {
  const viteConfig = findUp.sync(viteConfigFiles);
  if (viteConfig) {
    paddedLog("Detected vite project, setting builder to @storybook/builder-vite");
    return "vite" /* Vite */;
  }
  const nextJSVersion = detectNextJS(packageManager);
  if (nextJSVersion) {
    if (nextJSVersion >= 11) {
      return "webpack5" /* Webpack5 */;
    }
  }
  return "webpack5" /* Webpack5 */;
}
function isStorybookInstalled(dependencies, force) {
  if (!dependencies) {
    return false;
  }
  if (!force && dependencies.devDependencies) {
    if (SUPPORTED_RENDERERS.reduce(
      (storybookPresent, framework) => storybookPresent || !!dependencies.devDependencies[`@storybook/${framework}`],
      false
    )) {
      return "ALREADY_HAS_STORYBOOK" /* ALREADY_HAS_STORYBOOK */;
    }
  }
  return false;
}
function detectLanguage(packageJson) {
  let language = "javascript" /* JAVASCRIPT */;
  const bowerJson = getBowerJson();
  if (!packageJson && !bowerJson) {
    return language;
  }
  if (hasDependency(packageJson || bowerJson, "typescript")) {
    language = "typescript" /* TYPESCRIPT */;
  }
  return language;
}
function detect(packageJson, options = {}) {
  const bowerJson = getBowerJson();
  if (!packageJson && !bowerJson) {
    return "UNDETECTED" /* UNDETECTED */;
  }
  const storyBookInstalled = isStorybookInstalled(packageJson, options.force);
  if (storyBookInstalled) {
    return storyBookInstalled;
  }
  if (options.html) {
    return "HTML" /* HTML */;
  }
  return detectFrameworkPreset(packageJson || bowerJson);
}

// src/generators/ANGULAR/index.ts
import path6, { join as join2 } from "path";
import semver2 from "@storybook/semver";

// src/generators/ANGULAR/angular-helpers.ts
import * as path3 from "path";
import * as fs3 from "fs";
import { pathExists } from "fs-extra";
function getAngularAppTsConfigPath() {
  const angularJson = readFileAsJson("angular.json", true);
  const defaultProject = getDefaultProjectName(angularJson);
  const tsConfigPath = angularJson.projects[defaultProject].architect.build.options.tsConfig;
  if (!tsConfigPath || !fs3.existsSync(path3.resolve(tsConfigPath))) {
    return false;
  }
  return tsConfigPath;
}
function getAngularAppTsConfigJson() {
  const tsConfigPath = getAngularAppTsConfigPath();
  if (!tsConfigPath) {
    return false;
  }
  return readFileAsJson(tsConfigPath, true);
}
function setStorybookTsconfigExtendsPath(tsconfigJson) {
  const angularProjectTsConfigPath = getAngularAppTsConfigPath();
  const newTsconfigJson = { ...tsconfigJson };
  newTsconfigJson.extends = `../${angularProjectTsConfigPath}`;
  return newTsconfigJson;
}
function editStorybookTsConfig(tsconfigPath) {
  let tsConfigJson;
  try {
    tsConfigJson = readFileAsJson(tsconfigPath);
  } catch (e) {
    if (e.name === "SyntaxError" && e.message.indexOf("Unexpected token /") > -1) {
      throw new Error(`Comments are disallowed in ${tsconfigPath}`);
    }
    throw e;
  }
  tsConfigJson = setStorybookTsconfigExtendsPath(tsConfigJson);
  writeFileAsJson(tsconfigPath, tsConfigJson);
}
function getDefaultProjectName(angularJson) {
  const { defaultProject, projects } = angularJson;
  if (projects?.storybook) {
    return "storybook";
  }
  if (defaultProject) {
    return defaultProject;
  }
  const firstProjectName = projects ? Object.keys(projects)[0] : void 0;
  if (firstProjectName) {
    return firstProjectName;
  }
  return void 0;
}
function checkForProjects() {
  const { projects } = readFileAsJson("angular.json", true);
  if (!projects || Object.keys(projects).length === 0) {
    throw new Error(
      "Could not find a project in your Angular workspace. \nAdd a project and re-run the installation"
    );
  }
}
async function getBaseTsConfigName() {
  return await pathExists("./tsconfig.base.json") ? "tsconfig.base.json" : "tsconfig.json";
}

// src/generators/baseGenerator.ts
import fse3 from "fs-extra";
import { dedent as dedent2 } from "ts-dedent";

// src/generators/configure.ts
import fse2 from "fs-extra";
import { dedent } from "ts-dedent";
async function configureMain({
  addons,
  extensions = ["js", "jsx", "ts", "tsx"],
  commonJs = false,
  ...custom
}) {
  const prefix = await fse2.pathExists("./src") ? "../src" : "../stories";
  const config = {
    stories: [`${prefix}/**/*.stories.mdx`, `${prefix}/**/*.stories.@(${extensions.join("|")})`],
    addons,
    ...custom
  };
  const stringified = `module.exports = ${JSON.stringify(config, null, 2).replace(/\\"/g, '"').replace(/['"]%%/g, "").replace(/%%['"]/g, "").replace(/\\n/g, "\r\n")}`;
  await fse2.writeFile(
    `./.storybook/main.${commonJs ? "cjs" : "js"}`,
    dedent`
      const path = require('path');
      ${stringified}
    `,
    { encoding: "utf8" }
  );
}
var frameworkToPreviewParts = {
  angular: {
    prefix: dedent`
      import { setCompodocJson } from "@storybook/addon-docs/angular";
      import docJson from "../documentation.json";
      setCompodocJson(docJson);
      
      `.trimStart(),
    extraParameters: "docs: { inlineStories: true },"
  }
};
async function configurePreview(framework) {
  const { prefix = "", extraParameters = "" } = frameworkToPreviewParts[framework] || {};
  const previewPath = `./.storybook/preview.js`;
  if (await fse2.pathExists(previewPath)) {
    return;
  }
  const preview = dedent`
    ${prefix}
    export const parameters = {
      actions: { argTypesRegex: "^on[A-Z].*" },
      controls: {
        matchers: {
          color: /(background|color)$/i,
          date: /Date$/,
        },
      },
      ${extraParameters}
    }`.replace("  \n", "").trim();
  await fse2.writeFile(previewPath, preview, { encoding: "utf8" });
}

// src/js-package-manager/JsPackageManagerFactory.ts
import { sync as spawnSync2 } from "cross-spawn";
import { sync as findUpSync } from "find-up";

// src/js-package-manager/NPMProxy.ts
import semver from "@storybook/semver";

// src/js-package-manager/JsPackageManager.ts
import chalk2 from "chalk";
import { gt, satisfies as satisfies2 } from "@storybook/semver";
import { sync as spawnSync } from "cross-spawn";
import path4 from "path";
import fs4 from "fs";
var logger2 = console;
function getPackageDetails(pkg2) {
  const idx = pkg2.lastIndexOf("@");
  if (idx <= 0) {
    return [pkg2, void 0];
  }
  const packageName = pkg2.slice(0, idx);
  const packageVersion = pkg2.slice(idx + 1);
  return [packageName, packageVersion];
}
var JsPackageManager = class {
  setRegistryURL(url) {
    if (url) {
      this.executeCommand("npm", ["config", "set", "registry", url]);
    } else {
      this.executeCommand("npm", ["config", "delete", "registry"]);
    }
  }
  getRegistryURL() {
    const url = this.executeCommand("npm", ["config", "get", "registry"]).trim();
    return url === "undefined" ? void 0 : url;
  }
  constructor(options) {
    this.cwd = options?.cwd;
  }
  installDependencies() {
    let done = commandLog("Preparing to install dependencies");
    done();
    logger2.log();
    logger2.log();
    done = commandLog("Installing dependencies");
    try {
      this.runInstall();
    } catch (e) {
      done("An error occurred while installing dependencies.");
      process.exit(1);
    }
    done();
  }
  packageJsonPath() {
    return this.cwd ? path4.resolve(this.cwd, "package.json") : path4.resolve("package.json");
  }
  readPackageJson() {
    const packageJsonPath = this.packageJsonPath();
    if (!fs4.existsSync(packageJsonPath)) {
      throw new Error(`Could not read package.json file at ${packageJsonPath}`);
    }
    const jsonContent = fs4.readFileSync(packageJsonPath, "utf8");
    return JSON.parse(jsonContent);
  }
  writePackageJson(packageJson) {
    const content = `${JSON.stringify(packageJson, null, 2)}
`;
    fs4.writeFileSync(this.packageJsonPath(), content, "utf8");
  }
  retrievePackageJson() {
    let packageJson;
    try {
      packageJson = this.readPackageJson();
    } catch (err) {
      this.initPackageJson();
      packageJson = this.readPackageJson();
    }
    return {
      ...packageJson,
      dependencies: { ...packageJson.dependencies },
      devDependencies: { ...packageJson.devDependencies }
    };
  }
  addDependencies(options, dependencies) {
    const { skipInstall } = options;
    if (skipInstall) {
      const { packageJson } = options;
      const dependenciesMap = dependencies.reduce((acc, dep) => {
        const [packageName, packageVersion] = getPackageDetails(dep);
        return { ...acc, [packageName]: packageVersion };
      }, {});
      if (options.installAsDevDependencies) {
        packageJson.devDependencies = {
          ...packageJson.devDependencies,
          ...dependenciesMap
        };
      } else {
        packageJson.dependencies = {
          ...packageJson.dependencies,
          ...dependenciesMap
        };
      }
      this.writePackageJson(packageJson);
    } else {
      try {
        this.runAddDeps(dependencies, options.installAsDevDependencies);
      } catch (e) {
        logger2.error("An error occurred while installing dependencies.");
        logger2.log(e.message);
        process.exit(1);
      }
    }
  }
  removeDependencies(options, dependencies) {
    const { skipInstall } = options;
    if (skipInstall) {
      const { packageJson } = options;
      dependencies.forEach((dep) => {
        if (packageJson.devDependencies) {
          delete packageJson.devDependencies[dep];
        }
        if (packageJson.dependencies) {
          delete packageJson.dependencies[dep];
        }
      });
      this.writePackageJson(packageJson);
    } else {
      try {
        this.runRemoveDeps(dependencies);
      } catch (e) {
        logger2.error("An error occurred while removing dependencies.");
        logger2.log(e.message);
        process.exit(1);
      }
    }
  }
  getVersionedPackages(packages) {
    return Promise.all(
      packages.map(async (pkg2) => {
        const [packageName, packageVersion] = getPackageDetails(pkg2);
        return `${packageName}@${await this.getVersion(packageName, packageVersion)}`;
      })
    );
  }
  getVersions(...packageNames) {
    return Promise.all(
      packageNames.map((packageName) => {
        return this.getVersion(packageName);
      })
    );
  }
  async getVersion(packageName, constraint) {
    let current;
    if (/(@storybook|^sb$|^storybook$)/.test(packageName)) {
      current = versions_default[packageName];
    }
    let latest;
    try {
      latest = await this.latestVersion(packageName, constraint);
    } catch (e) {
      if (current) {
        logger2.warn(`
     ${chalk2.yellow(e.message)}`);
        return current;
      }
      logger2.error(`
     ${chalk2.red(e.message)}`);
      process.exit(1);
    }
    const versionToUse = current && (!constraint || satisfies2(current, constraint)) && gt(current, latest) ? current : latest;
    return `^${versionToUse}`;
  }
  async latestVersion(packageName, constraint) {
    if (!constraint) {
      return this.runGetVersions(packageName, false);
    }
    const versions = await this.runGetVersions(packageName, true);
    return versions.reverse().find((version) => satisfies2(version, constraint));
  }
  addStorybookCommandInScripts(options) {
    const sbPort = options?.port ?? 6006;
    const storybookCmd = options?.staticFolder ? `npx storybook dev -p ${sbPort} -s ${options.staticFolder}` : `npx storybook dev -p ${sbPort}`;
    const buildStorybookCmd = options?.staticFolder ? `npx storybook build -s ${options.staticFolder}` : `npx storybook build`;
    const preCommand = options?.preCommand ? this.getRunCommand(options.preCommand) : void 0;
    this.addScripts({
      storybook: [preCommand, storybookCmd].filter(Boolean).join(" && "),
      "build-storybook": [preCommand, buildStorybookCmd].filter(Boolean).join(" && ")
    });
  }
  addESLintConfig() {
    const packageJson = this.retrievePackageJson();
    this.writePackageJson({
      ...packageJson,
      eslintConfig: {
        ...packageJson.eslintConfig,
        overrides: [
          ...packageJson.eslintConfig?.overrides || [],
          {
            files: ["**/*.stories.*"],
            rules: {
              "import/no-anonymous-default-export": "off"
            }
          }
        ]
      }
    });
  }
  addScripts(scripts) {
    const packageJson = this.retrievePackageJson();
    this.writePackageJson({
      ...packageJson,
      scripts: {
        ...packageJson.scripts,
        ...scripts
      }
    });
  }
  addPackageResolutions(versions) {
    const packageJson = this.retrievePackageJson();
    const resolutions = this.getResolutions(packageJson, versions);
    this.writePackageJson({ ...packageJson, ...resolutions });
  }
  executeCommand(command2, args, stdio) {
    const commandResult = spawnSync(command2, args, {
      cwd: this.cwd,
      stdio: stdio ?? "pipe",
      encoding: "utf-8",
      shell: true
    });
    if (commandResult.status !== 0) {
      throw new Error(commandResult.stderr ?? "");
    }
    return commandResult.stdout ?? "";
  }
};

// src/js-package-manager/NPMProxy.ts
var NPMProxy = class extends JsPackageManager {
  constructor() {
    super(...arguments);
    this.type = "npm";
  }
  initPackageJson() {
    return this.executeCommand("npm", ["init", "-y"]);
  }
  getRunStorybookCommand() {
    return "npm run storybook";
  }
  getRunCommand(command2) {
    return `npm run ${command2}`;
  }
  getNpmVersion() {
    return this.executeCommand("npm", ["--version"]);
  }
  hasLegacyPeerDeps() {
    const result = this.executeCommand("npm", [
      "config",
      "get",
      "legacy-peer-deps",
      "--location=project"
    ]);
    return result.trim() === "true";
  }
  setLegacyPeerDeps() {
    this.executeCommand("npm", ["config", "set", "legacy-peer-deps=true", "--location=project"]);
  }
  needsLegacyPeerDeps(version) {
    return semver.gte(version, "7.0.0") && !this.hasLegacyPeerDeps();
  }
  getInstallArgs() {
    if (!this.installArgs) {
      this.installArgs = this.needsLegacyPeerDeps(this.getNpmVersion()) ? ["install", "--legacy-peer-deps"] : ["install"];
    }
    return this.installArgs;
  }
  getUninstallArgs() {
    if (!this.uninstallArgs) {
      this.uninstallArgs = this.needsLegacyPeerDeps(this.getNpmVersion()) ? ["uninstall", "--legacy-peer-deps"] : ["uninstall"];
    }
    return this.uninstallArgs;
  }
  getResolutions(packageJson, versions) {
    return {
      overrides: {
        ...packageJson.overrides,
        ...versions
      }
    };
  }
  runInstall() {
    this.executeCommand("npm", this.getInstallArgs(), "inherit");
  }
  runAddDeps(dependencies, installAsDevDependencies) {
    let args = [...dependencies];
    if (installAsDevDependencies) {
      args = ["-D", ...args];
    }
    this.executeCommand("npm", [...this.getInstallArgs(), ...args], "inherit");
  }
  runRemoveDeps(dependencies) {
    const args = [...dependencies];
    this.executeCommand("npm", [...this.getUninstallArgs(), ...args], "inherit");
  }
  runGetVersions(packageName, fetchAllVersions) {
    const args = [fetchAllVersions ? "versions" : "version", "--json"];
    const commandResult = this.executeCommand("npm", ["info", packageName, ...args]);
    try {
      const parsedOutput = JSON.parse(commandResult);
      if (parsedOutput.error) {
        throw new Error(parsedOutput.error.summary);
      } else {
        return parsedOutput;
      }
    } catch (e) {
      throw new Error(`Unable to find versions of ${packageName} using npm`);
    }
  }
};

// src/js-package-manager/Yarn2Proxy.ts
var Yarn2Proxy = class extends JsPackageManager {
  constructor() {
    super(...arguments);
    this.type = "yarn2";
  }
  initPackageJson() {
    return this.executeCommand("yarn", ["init"]);
  }
  getRunStorybookCommand() {
    return "yarn storybook";
  }
  getRunCommand(command2) {
    return `yarn ${command2}`;
  }
  getResolutions(packageJson, versions) {
    return {
      resolutions: {
        ...packageJson.resolutions,
        ...versions
      }
    };
  }
  runInstall() {
    this.executeCommand("yarn", [], "inherit");
  }
  runAddDeps(dependencies, installAsDevDependencies) {
    let args = [...dependencies];
    if (installAsDevDependencies) {
      args = ["-D", ...args];
    }
    this.executeCommand("yarn", ["add", ...args], "inherit");
  }
  runRemoveDeps(dependencies) {
    const args = [...dependencies];
    this.executeCommand("yarn", ["remove", ...args], "inherit");
  }
  runGetVersions(packageName, fetchAllVersions) {
    const field = fetchAllVersions ? "versions" : "version";
    const args = ["--fields", field, "--json"];
    const commandResult = this.executeCommand("yarn", ["npm", "info", packageName, ...args]);
    try {
      const parsedOutput = JSON.parse(commandResult);
      return parsedOutput[field];
    } catch (e) {
      throw new Error(`Unable to find versions of ${packageName} using yarn 2`);
    }
  }
};

// src/js-package-manager/Yarn1Proxy.ts
var Yarn1Proxy = class extends JsPackageManager {
  constructor() {
    super(...arguments);
    this.type = "yarn1";
  }
  initPackageJson() {
    return this.executeCommand("yarn", ["init", "-y"]);
  }
  getRunStorybookCommand() {
    return "yarn storybook";
  }
  getRunCommand(command2) {
    return `yarn ${command2}`;
  }
  getResolutions(packageJson, versions) {
    return {
      resolutions: {
        ...packageJson.resolutions,
        ...versions
      }
    };
  }
  runInstall() {
    this.executeCommand("yarn", [], "inherit");
  }
  runAddDeps(dependencies, installAsDevDependencies) {
    let args = ["--ignore-workspace-root-check", ...dependencies];
    if (installAsDevDependencies) {
      args = ["-D", ...args];
    }
    this.executeCommand("yarn", ["add", ...args], "inherit");
  }
  runRemoveDeps(dependencies) {
    const args = ["--ignore-workspace-root-check", ...dependencies];
    this.executeCommand("yarn", ["remove", ...args], "inherit");
  }
  runGetVersions(packageName, fetchAllVersions) {
    const args = [fetchAllVersions ? "versions" : "version", "--json"];
    const commandResult = this.executeCommand("yarn", ["info", packageName, ...args]);
    try {
      const parsedOutput = JSON.parse(commandResult);
      if (parsedOutput.type === "inspect") {
        return parsedOutput.data;
      }
      throw new Error(`Unable to find versions of ${packageName} using yarn`);
    } catch (e) {
      throw new Error(`Unable to find versions of ${packageName} using yarn`);
    }
  }
};

// src/js-package-manager/JsPackageManagerFactory.ts
var JsPackageManagerFactory = class {
  static getPackageManager(forceNpmUsage = false, cwd) {
    if (forceNpmUsage) {
      return new NPMProxy({ cwd });
    }
    const yarnVersion = getYarnVersion(cwd);
    const hasYarnLockFile = findUpSync("yarn.lock", { cwd });
    const hasNPMCommand = hasNPM(cwd);
    if (yarnVersion && (hasYarnLockFile || !hasNPMCommand)) {
      return yarnVersion === 1 ? new Yarn1Proxy({ cwd }) : new Yarn2Proxy({ cwd });
    }
    if (hasNPMCommand) {
      return new NPMProxy({ cwd });
    }
    throw new Error("Unable to find a usable package manager within NPM, Yarn and Yarn 2");
  }
};
function hasNPM(cwd) {
  const npmVersionCommand = spawnSync2("npm", ["--version"], { cwd, shell: true });
  return npmVersionCommand.status === 0;
}
function getYarnVersion(cwd) {
  const yarnVersionCommand = spawnSync2("yarn", ["--version"], { cwd, shell: true });
  if (yarnVersionCommand.status !== 0) {
    return void 0;
  }
  const yarnVersion = yarnVersionCommand.output.toString().replace(/,/g, "").replace(/"/g, "");
  return /^1\.+/.test(yarnVersion) ? 1 : 2;
}

// src/babel-config.ts
import { writeFile, access } from "fs-extra";
import { logger as logger3 } from "@storybook/node-logger";
import path5 from "path";
import prompts from "prompts";
var generateStorybookBabelConfigInCWD = async () => {
  const target = process.cwd();
  return generateStorybookBabelConfig({ target });
};
var generateStorybookBabelConfig = async ({ target }) => {
  logger3.info(`Generating the storybook default babel config at ${target}`);
  const contents = JSON.stringify(
    {
      sourceType: "unambiguous",
      presets: [],
      plugins: []
    },
    null,
    2
  );
  const fileName = ".babelrc.json";
  const location = path5.join(target, fileName);
  const exists = await access(location).then(
    () => true,
    () => false
  );
  if (exists) {
    const { overwrite } = await prompts({
      type: "confirm",
      initial: true,
      name: "overwrite",
      message: `${fileName} already exists. Would you like overwrite it?`
    });
    if (overwrite === false) {
      logger3.warn(`Cancelled, babel config file was NOT written to file-system.`);
      return;
    }
  }
  logger3.info(`Writing file to ${location}`);
  await writeFile(location, contents);
};

// src/generators/baseGenerator.ts
var defaultOptions = {
  extraPackages: [],
  extraAddons: [],
  staticDir: void 0,
  addScripts: true,
  addComponents: true,
  addBabel: false,
  addESLint: false,
  extraMain: void 0,
  framework: void 0,
  extensions: void 0,
  commonJs: false
};
var getBuilderDetails = (builder) => {
  const map = versions_default;
  if (map[builder]) {
    return builder;
  }
  const builderPackage = `@storybook/${builder}`;
  if (map[builderPackage]) {
    return builderPackage;
  }
  return builder;
};
var wrapForPnp = (packageName) => `%%path.dirname(require.resolve(path.join('${packageName}', 'package.json')))%%`;
var getFrameworkDetails = (renderer, builder, pnp) => {
  const frameworkPackage = `@storybook/${renderer}-${builder}`;
  const frameworkPackagePath = pnp ? wrapForPnp(frameworkPackage) : frameworkPackage;
  const rendererPackage = `@storybook/${renderer}`;
  const rendererPackagePath = pnp ? wrapForPnp(rendererPackage) : rendererPackage;
  const builderPackage = getBuilderDetails(builder);
  const builderPackagePath = pnp ? wrapForPnp(builderPackage) : builderPackage;
  const isKnownFramework = !!versions_default[frameworkPackage];
  const isKnownRenderer = !!versions_default[rendererPackage];
  if (renderer === "angular") {
    return {
      packages: [rendererPackage],
      framework: rendererPackagePath,
      rendererId: "angular",
      type: "framework"
    };
  }
  if (isKnownFramework) {
    return {
      packages: [frameworkPackage],
      framework: frameworkPackagePath,
      rendererId: renderer,
      type: "framework"
    };
  }
  if (isKnownRenderer) {
    return {
      packages: [rendererPackage, builderPackage],
      builder: builderPackagePath,
      renderer: rendererPackagePath,
      rendererId: renderer,
      type: "renderer"
    };
  }
  throw new Error(
    `Could not find the framework (${frameworkPackage}) or renderer (${rendererPackage}) package`
  );
};
var stripVersions = (addons) => addons.map((addon) => getPackageDetails(addon)[0]);
var hasInteractiveStories = (rendererId) => ["react", "angular", "preact", "svelte", "vue", "vue3", "html"].includes(rendererId);
var _a;
async function baseGenerator(packageManager, npmOptions, { language, builder = "webpack5" /* Webpack5 */, pnp, commonJs }, renderer, options = defaultOptions) {
  const {
    extraAddons: extraAddonPackages,
    extraPackages,
    staticDir,
    addScripts,
    addComponents,
    addBabel,
    addESLint,
    extraMain,
    extensions
  } = {
    ...defaultOptions,
    ...options
  };
  const {
    packages: frameworkPackages,
    type,
    renderer: rendererInclude,
    rendererId,
    framework: frameworkInclude,
    builder: builderInclude
  } = getFrameworkDetails(renderer, builder, pnp);
  const addons = [
    "@storybook/addon-links",
    "@storybook/addon-essentials",
    ...stripVersions(extraAddonPackages)
  ];
  const addonPackages = [
    "@storybook/addon-links",
    "@storybook/addon-essentials",
    ...extraAddonPackages
  ];
  if (hasInteractiveStories(rendererId)) {
    addons.push("@storybook/addon-interactions");
    addonPackages.push("@storybook/addon-interactions", "@storybook/testing-library");
  }
  const yarn2ExtraPackages = packageManager.type === "yarn2" ? ["@storybook/addon-docs", "@mdx-js/react@1.x.x"] : [];
  const files = await fse3.readdir(process.cwd());
  const packageJson = packageManager.retrievePackageJson();
  const installedDependencies = new Set(
    Object.keys({ ...packageJson.dependencies, ...packageJson.devDependencies })
  );
  if (type === "renderer") {
    throw new Error(
      dedent2`
        Sorry, for now, you can not do this, please use a framework such as @storybook/react-webpack5

        https://github.com/storybookjs/storybook/issues/18360
      `
    );
  }
  const packages = [
    "storybook",
    `@storybook/${renderer}`,
    ...frameworkPackages,
    ...addonPackages,
    ...extraPackages,
    ...yarn2ExtraPackages
  ].filter(Boolean).filter(
    (packageToInstall) => !installedDependencies.has(getPackageDetails(packageToInstall)[0])
  );
  const versionedPackages = await packageManager.getVersionedPackages(packages);
  await fse3.ensureDir("./.storybook");
  await configureMain({
    framework: { name: frameworkInclude, options: options.framework || {} },
    addons: pnp ? addons.map(wrapForPnp) : addons,
    extensions,
    commonJs,
    ...extraMain,
    ...type !== "framework" ? {
      core: {
        builder: builderInclude
      }
    } : {}
  });
  await configurePreview(renderer);
  if (addComponents) {
    await copyComponents(renderer, language);
  }
  if (frameworkPackages.find((pkg2) => pkg2.match(/^@storybook\/.*-vite$/))) {
    const previewHead = dedent2(_a || (_a = __template(["\n      <script>\n        window.global = window;\n      <\/script>\n    "])));
    await fse3.writeFile(`.storybook/preview-head.html`, previewHead, { encoding: "utf8" });
  }
  const babelDependencies = addBabel && builder !== "vite" /* Vite */ ? await getBabelDependencies(packageManager, packageJson) : [];
  const isNewFolder = !files.some(
    (fname) => fname.startsWith(".babel") || fname.startsWith("babel") || fname === "package.json"
  );
  if (isNewFolder) {
    await generateStorybookBabelConfigInCWD();
  }
  packageManager.addDependencies({ ...npmOptions, packageJson }, [
    ...versionedPackages,
    ...babelDependencies
  ]);
  if (addScripts) {
    packageManager.addStorybookCommandInScripts({
      port: 6006,
      staticFolder: staticDir
    });
  }
  if (addESLint) {
    packageManager.addESLintConfig();
  }
}

// src/generators/ANGULAR/index.ts
function editAngularAppTsConfig() {
  const tsConfigJson = getAngularAppTsConfigJson();
  const glob = "**/*.stories.*";
  if (!tsConfigJson) {
    return;
  }
  const { exclude = [] } = tsConfigJson;
  if (exclude.includes(glob)) {
    return;
  }
  tsConfigJson.exclude = [...exclude, glob];
  writeFileAsJson(getAngularAppTsConfigPath(), tsConfigJson);
}
var generator = async (packageManager, npmOptions, options) => {
  checkForProjects();
  const angularVersion = semver2.coerce(
    packageManager.retrievePackageJson().dependencies["@angular/core"]
  )?.version;
  const isWebpack5 = semver2.gte(angularVersion, "12.0.0");
  const updatedOptions = isWebpack5 ? { ...options, builder: "webpack5" /* Webpack5 */ } : options;
  await baseGenerator(packageManager, npmOptions, updatedOptions, "angular", {
    extraPackages: ["@compodoc/compodoc"],
    addScripts: false
  });
  const templateDir = join2(getBaseDir(), "templates", "angular");
  copyTemplate(templateDir);
  editAngularAppTsConfig();
  editStorybookTsConfig(path6.resolve("./.storybook/tsconfig.json"));
  const tsConfigFile = await getBaseTsConfigName();
  packageManager.addScripts({
    "docs:json": `compodoc -p ./${tsConfigFile} -e json -d .`
  });
  packageManager.addStorybookCommandInScripts({
    port: 6006,
    preCommand: "docs:json"
  });
};
var ANGULAR_default = generator;

// src/generators/AURELIA/index.ts
import { join as join3 } from "path";
function addStorybookExcludeGlobToTsConfig() {
  const tsConfigJson = readFileAsJson("tsconfig.json", true);
  const glob = "**/*.stories.ts";
  if (!tsConfigJson) {
    return;
  }
  const { exclude = [] } = tsConfigJson;
  if (exclude.includes(glob)) {
    return;
  }
  tsConfigJson.exclude = [...exclude, glob];
  writeFileAsJson("tsconfig.json", tsConfigJson);
}
var generator2 = async (packageManager, npmOptions, options) => {
  addStorybookExcludeGlobToTsConfig();
  await baseGenerator(packageManager, npmOptions, options, "aurelia", {
    extraPackages: ["aurelia"]
  });
  const templateDir = join3(getBaseDir(), "templates", "aurelia");
  copyTemplate(templateDir);
};
var AURELIA_default = generator2;

// src/generators/EMBER/index.ts
var generator3 = async (packageManager, npmOptions, options) => {
  await baseGenerator(packageManager, npmOptions, options, "ember", {
    extraPackages: [
      "babel-plugin-ember-modules-api-polyfill",
      "babel-plugin-htmlbars-inline-precompile"
    ],
    staticDir: "dist"
  });
};
var EMBER_default = generator3;

// src/generators/REACT/index.ts
var generator4 = async (packageManager, npmOptions, options) => {
  await baseGenerator(packageManager, npmOptions, options, "react");
};
var REACT_default = generator4;

// src/generators/REACT_NATIVE/index.ts
import { join as join4 } from "path";
import chalk3 from "chalk";
import shell from "shelljs";
var generator5 = async (packageManager, npmOptions, installServer) => {
  const dirname2 = shell.ls("-d", "ios/*.xcodeproj").stdout;
  if (dirname2) {
    const projectName = dirname2.slice("ios/".length, dirname2.length - ".xcodeproj".length - 1);
    if (projectName) {
      shell.sed("-i", "%APP_NAME%", projectName, "storybook/index.js");
    } else {
      paddedLog(
        chalk3.red(
          "ERR: Could not determine project name, to fix: https://github.com/storybookjs/storybook/issues/1277"
        )
      );
    }
  }
  const packageJson = packageManager.retrievePackageJson();
  const missingReactDom = !packageJson.dependencies["react-dom"] && !packageJson.devDependencies["react-dom"];
  const reactVersion = packageJson.dependencies.react;
  const webAddonsV5 = [
    "@storybook/addon-links@^5.3",
    "@storybook/addon-knobs@^5.3",
    "@storybook/addon-actions@^5.3"
  ];
  const nativeAddons = ["@storybook/addon-ondevice-knobs", "@storybook/addon-ondevice-actions"];
  const packagesToResolve = [
    ...nativeAddons,
    "@storybook/react-native",
    installServer && "@storybook/react-native-server"
  ].filter(Boolean);
  const resolvedPackages = await packageManager.getVersionedPackages(packagesToResolve);
  const babelDependencies = await getBabelDependencies(packageManager, packageJson);
  const packages = [
    ...babelDependencies,
    ...resolvedPackages,
    ...webAddonsV5,
    missingReactDom && reactVersion && `react-dom@${reactVersion}`
  ].filter(Boolean);
  packageManager.addDependencies({ ...npmOptions, packageJson }, packages);
  if (installServer) {
    packageManager.addStorybookCommandInScripts({
      port: 7007
    });
  }
  const templateDir = join4(getBaseDir(), "templates", "react-native");
  copyTemplate(templateDir);
};
var REACT_NATIVE_default = generator5;

// src/generators/REACT_SCRIPTS/index.ts
import path7 from "path";
import fs5 from "fs";
import semver3 from "@storybook/semver";
var generator6 = async (packageManager, npmOptions, options) => {
  const monorepoRootPath = path7.join(__dirname, "..", "..", "..", "..", "..", "..");
  const extraMain = options.linkable ? {
    webpackFinal: `%%(config) => {
      // add monorepo root as a valid directory to import modules from
      config.resolve.plugins.forEach((p) => {
        if (Array.isArray(p.appSrcs)) {
          p.appSrcs.push('${monorepoRootPath}');
              }
            });
          return config;
          }
    %%`
  } : {};
  const craVersion = semver3.coerce(
    packageManager.retrievePackageJson().dependencies["react-scripts"]
  )?.version;
  const isCra5 = craVersion && semver3.gte(craVersion, "5.0.0");
  const updatedOptions = isCra5 ? { ...options, builder: "webpack5" /* Webpack5 */ } : options;
  const extraPackages = ["@storybook/node-logger"];
  if (isCra5) {
    extraPackages.push("webpack");
    extraPackages.push("babel-plugin-named-exports-order");
    extraPackages.push("prop-types");
  }
  const extraAddons = [`@storybook/preset-create-react-app${isCra5 ? "" : "@3"}`];
  await baseGenerator(packageManager, npmOptions, updatedOptions, "react", {
    extraAddons,
    extraPackages,
    staticDir: fs5.existsSync(path7.resolve("./public")) ? "public" : void 0,
    addBabel: false,
    addESLint: true,
    extraMain
  });
};
var REACT_SCRIPTS_default = generator6;

// src/generators/SFC_VUE/index.ts
var generator7 = async (packageManager, npmOptions, options) => {
  await baseGenerator(packageManager, npmOptions, options, "vue");
};
var SFC_VUE_default = generator7;

// src/generators/VUE/index.ts
var generator8 = async (packageManager, npmOptions, options) => {
  const extraPackages = options.builder === "webpack5" /* Webpack5 */ ? ["vue-loader@^15.7.0"] : [];
  await baseGenerator(packageManager, npmOptions, options, "vue", {
    extraPackages
  });
};
var VUE_default = generator8;

// src/generators/VUE3/index.ts
var generator9 = async (packageManager, npmOptions, options) => {
  const extraPackages = options.builder === "webpack5" /* Webpack5 */ ? ["vue-loader@^17.0.0", "@vue/compiler-sfc@^3.2.0"] : [];
  await baseGenerator(packageManager, npmOptions, options, "vue3", {
    extraPackages
  });
};
var VUE3_default = generator9;

// src/generators/WEBPACK_REACT/index.ts
var generator10 = async (packageManager, npmOptions, options) => {
  await baseGenerator(packageManager, npmOptions, options, "react");
};
var WEBPACK_REACT_default = generator10;

// src/generators/MITHRIL/index.ts
var generator11 = async (packageManager, npmOptions, options) => {
  await baseGenerator(packageManager, npmOptions, options, "mithril");
};
var MITHRIL_default = generator11;

// src/generators/MARIONETTE/index.ts
var generator12 = async (packageManager, npmOptions, options) => {
  await baseGenerator(packageManager, npmOptions, options, "marionette");
};
var MARIONETTE_default = generator12;

// src/generators/MARKO/index.ts
var generator13 = async (packageManager, npmOptions, options) => {
  await baseGenerator(packageManager, npmOptions, options, "marko");
};
var MARKO_default = generator13;

// src/generators/HTML/index.ts
var generator14 = async (packageManager, npmOptions, options) => {
  await baseGenerator(packageManager, npmOptions, options, "html");
};
var HTML_default = generator14;

// src/generators/WEB-COMPONENTS/index.ts
var generator15 = async (packageManager, npmOptions, options) => {
  return baseGenerator(packageManager, npmOptions, options, "web-components", {
    extraPackages: ["lit-html"]
  });
};
var WEB_COMPONENTS_default = generator15;

// src/generators/RIOT/index.ts
var generator16 = async (packageManager, npmOptions, options) => {
  await baseGenerator(packageManager, npmOptions, options, "riot", {
    extraPackages: ["riot-tag-loader"]
  });
};
var RIOT_default = generator16;

// src/generators/PREACT/index.ts
var generator17 = async (packageManager, npmOptions, options) => {
  await baseGenerator(packageManager, npmOptions, options, "preact");
};
var PREACT_default = generator17;

// src/generators/SVELTE/index.ts
import fse4 from "fs-extra";
import { logger as logger4 } from "@storybook/node-logger";
var generator18 = async (packageManager, npmOptions, options) => {
  let extraMain;
  if (fse4.existsSync("./svelte.config.js")) {
    logger4.info("Configuring preprocessor from 'svelte.config.js'");
    extraMain = {
      svelteOptions: { preprocess: '%%require("../svelte.config.js").preprocess%%' }
    };
  } else if (fse4.existsSync("./svelte.config.cjs")) {
    logger4.info("Configuring preprocessor from 'svelte.config.cjs'");
    extraMain = {
      svelteOptions: { preprocess: '%%require("../svelte.config.cjs").preprocess%%' }
    };
  } else {
    const packageJson = packageManager.retrievePackageJson();
    if (packageJson.devDependencies && packageJson.devDependencies["svelte-preprocess"]) {
      logger4.info("Configuring preprocessor with 'svelte-preprocess'");
      extraMain = {
        svelteOptions: { preprocess: '%%require("svelte-preprocess")()%%' }
      };
    }
  }
  const extraPackages = options.builder === "webpack5" /* Webpack5 */ ? ["svelte", "svelte-loader"] : [];
  await baseGenerator(packageManager, npmOptions, options, "svelte", {
    extraPackages,
    extensions: ["js", "jsx", "ts", "tsx", "svelte"],
    extraMain,
    commonJs: true
  });
};
var SVELTE_default = generator18;

// src/generators/RAX/index.ts
var generator19 = async (packageManager, npmOptions, options) => {
  const [latestRaxVersion] = await packageManager.getVersions("rax");
  const packageJson = packageManager.retrievePackageJson();
  const raxVersion = packageJson.dependencies.rax || latestRaxVersion;
  packageJson.dependencies.rax = packageJson.dependencies.rax || raxVersion;
  packageJson.dependencies["rax-image"] = packageJson.dependencies["rax-image"] || raxVersion;
  packageJson.dependencies["rax-link"] = packageJson.dependencies["rax-link"] || raxVersion;
  packageJson.dependencies["rax-text"] = packageJson.dependencies["rax-text"] || raxVersion;
  packageJson.dependencies["rax-view"] = packageJson.dependencies["rax-view"] || raxVersion;
  packageManager.writePackageJson(packageJson);
  await baseGenerator(packageManager, npmOptions, options, "rax", {
    extraPackages: ["rax"]
  });
};
var RAX_default = generator19;

// src/generators/SERVER/index.ts
import { join as join5 } from "path";
var generator20 = async (packageManager, npmOptions, options) => {
  await baseGenerator(packageManager, npmOptions, options, "server", {
    extensions: ["json"]
  });
  const templateDir = join5(getBaseDir(), "templates", "server");
  copyTemplate(templateDir);
};
var SERVER_default = generator20;

// src/automigrate/index.ts
import prompts2 from "prompts";
import chalk14 from "chalk";
import boxen from "boxen";

// src/automigrate/fixes/cra5.ts
import chalk5 from "chalk";
import { dedent as dedent4 } from "ts-dedent";
import semver5 from "@storybook/semver";

// src/automigrate/fixes/webpack5.ts
import chalk4 from "chalk";
import { dedent as dedent3 } from "ts-dedent";
import semver4 from "@storybook/semver";
import { readConfig, writeConfig } from "@storybook/csf-tools";
import { getStorybookInfo } from "@storybook/core-common";
var logger5 = console;
var webpack5 = {
  id: "webpack5",
  async checkWebpack5Builder(packageJson) {
    const { mainConfig, version: storybookVersion } = getStorybookInfo(packageJson);
    const storybookCoerced = storybookVersion && semver4.coerce(storybookVersion)?.version;
    if (!storybookCoerced) {
      logger5.warn(dedent3`
        ❌ Unable to determine storybook version, skipping ${chalk4.cyan("webpack5")} fix.
        🤔 Are you running automigrate from your project directory?
      `);
      return null;
    }
    if (semver4.lt(storybookCoerced, "6.3.0")) {
      logger5.warn(
        dedent3`
          Detected SB 6.3 or below, please upgrade storybook to use webpack5.

          To upgrade to the latest stable release, run this from your project directory:

          ${chalk4.cyan("npx storybook upgrade")}

          Add the ${chalk4.cyan("--prerelease")} flag to get the latest prerelease.
        `.trim()
      );
      return null;
    }
    if (semver4.gte(storybookCoerced, "7.0.0")) {
      return null;
    }
    if (!mainConfig) {
      logger5.warn("Unable to find storybook main.js config");
      return null;
    }
    const main = await readConfig(mainConfig);
    const builder = main.getFieldValue(["core", "builder"]);
    if (builder && builder !== "webpack4") {
      logger5.info(`Found builder ${builder}, skipping`);
      return null;
    }
    return { storybookVersion, main };
  },
  async check({ packageManager }) {
    const packageJson = packageManager.retrievePackageJson();
    const { dependencies, devDependencies } = packageJson;
    const webpackVersion = dependencies.webpack || devDependencies.webpack;
    const webpackCoerced = semver4.coerce(webpackVersion)?.version;
    if (!webpackCoerced || semver4.lt(webpackCoerced, "5.0.0") || semver4.gte(webpackCoerced, "6.0.0"))
      return null;
    const builderInfo = await this.checkWebpack5Builder(packageJson);
    return builderInfo ? { webpackVersion, ...builderInfo } : null;
  },
  prompt({ webpackVersion }) {
    const webpackFormatted = chalk4.cyan(`webpack ${webpackVersion}`);
    return dedent3`
      We've detected you're running ${webpackFormatted}.
      Your Storybook's main.js files specifies webpack4, which is incompatible.
      
      To run Storybook in webpack5-mode, we can install Storybook's ${chalk4.cyan(
      "@storybook/builder-webpack5"
    )} for you.

      More info: ${chalk4.yellow(
      "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#webpack-5-manager-build"
    )}
    `;
  },
  async run({ result: { main, storybookVersion, webpackVersion }, packageManager, dryRun }) {
    const deps = [`@storybook/builder-webpack5@${storybookVersion}`];
    if (!webpackVersion) {
      deps.push("webpack@5");
    }
    logger5.info(`\u2705 Adding dependencies: ${deps}`);
    if (!dryRun)
      packageManager.addDependencies({ installAsDevDependencies: true }, deps);
    logger5.info("\u2705 Setting `core.builder` to `@storybook/builder-webpack5` in main.js");
    if (!dryRun) {
      main.setFieldValue(["core", "builder"], "@storybook/builder-webpack5");
      await writeConfig(main);
    }
  }
};

// src/automigrate/fixes/cra5.ts
var cra5 = {
  id: "cra5",
  async check({ packageManager }) {
    const packageJson = packageManager.retrievePackageJson();
    const { dependencies, devDependencies } = packageJson;
    const craVersion = dependencies["react-scripts"] || devDependencies["react-scripts"];
    const craCoerced = semver5.coerce(craVersion)?.version;
    if (!craCoerced || semver5.lt(craCoerced, "5.0.0")) {
      return null;
    }
    const builderInfo = await webpack5.checkWebpack5Builder(packageJson);
    return builderInfo ? { craVersion, ...builderInfo } : null;
  },
  prompt({ craVersion, ...rest }) {
    const craFormatted = chalk5.cyan(`Create React App (CRA) ${craVersion}`);
    console.log({ ...rest });
    return dedent4`
      We've detected you are running ${craFormatted} which is powered by webpack5.
      Your Storybook's main.js files specifies webpack4, which is incompatible.

      In order to work with your version of CRA, we need to install Storybook's ${chalk5.cyan(
      "@storybook/builder-webpack5"
    )}.

      More info: ${chalk5.yellow(
      "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#cra5-upgrade"
    )}
    `;
  },
  async run(options) {
    return webpack5.run({
      ...options,
      result: { webpackVersion: null, ...options.result }
    });
  }
};

// src/automigrate/fixes/angular12.ts
import chalk6 from "chalk";
import { dedent as dedent5 } from "ts-dedent";
import semver6 from "@storybook/semver";
var angular12 = {
  id: "angular12",
  async check({ packageManager }) {
    const packageJson = packageManager.retrievePackageJson();
    const { dependencies, devDependencies } = packageJson;
    const angularVersion = dependencies["@angular/core"] || devDependencies["@angular/core"];
    const angularCoerced = semver6.coerce(angularVersion)?.version;
    if (!angularCoerced || semver6.lt(angularCoerced, "12.0.0")) {
      return null;
    }
    const builderInfo = await webpack5.checkWebpack5Builder(packageJson);
    return builderInfo ? { angularVersion, ...builderInfo } : null;
  },
  prompt({ angularVersion }) {
    const angularFormatted = chalk6.cyan(`Angular ${angularVersion}`);
    return dedent5`
      We've detected you are running ${angularFormatted} which is powered by webpack5.
      Your Storybook's main.js files specifies webpack4, which is incompatible.

      In order to work with your version of Angular, we need to install Storybook's ${chalk6.cyan(
      "@storybook/builder-webpack5"
    )}.

      More info: ${chalk6.yellow(
      "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#angular12-upgrade"
    )}
    `;
  },
  async run(options) {
    return webpack5.run({
      ...options,
      result: { webpackVersion: null, ...options.result }
    });
  }
};

// src/automigrate/fixes/vue3.ts
import chalk7 from "chalk";
import { dedent as dedent6 } from "ts-dedent";
import semver7 from "@storybook/semver";
var vue3 = {
  id: "vue3",
  async check({ packageManager }) {
    const packageJson = packageManager.retrievePackageJson();
    const { dependencies, devDependencies } = packageJson;
    const vueVersion = dependencies.vue || devDependencies.vue;
    const vueCoerced = semver7.coerce(vueVersion)?.version;
    if (!vueCoerced || semver7.lt(vueCoerced, "3.0.0")) {
      return null;
    }
    const builderInfo = await webpack5.checkWebpack5Builder(packageJson);
    return builderInfo ? { vueVersion, ...builderInfo } : null;
  },
  prompt({ vueVersion, storybookVersion }) {
    const vueFormatted = chalk7.cyan(`Vue ${vueVersion}`);
    const sbFormatted = chalk7.cyan(`Storybook ${storybookVersion}`);
    return dedent6`
      We've detected you are running ${vueFormatted} with Storybook.
      ${sbFormatted} runs webpack4 by default, which is incompatible.

      In order to work with your version of Vue, we need to install Storybook's ${chalk7.cyan(
      "webpack5 builder"
    )}.

      More info: ${chalk7.yellow(
      "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#vue3-upgrade"
    )}
    `;
  },
  async run(options) {
    return webpack5.run({
      ...options,
      result: { webpackVersion: null, ...options.result }
    });
  }
};

// src/automigrate/fixes/mainjsFramework.ts
import chalk8 from "chalk";
import { dedent as dedent7 } from "ts-dedent";
import semver8 from "@storybook/semver";
import { readConfig as readConfig2, writeConfig as writeConfig2 } from "@storybook/csf-tools";
import { getStorybookInfo as getStorybookInfo2 } from "@storybook/core-common";
var logger6 = console;
var mainjsFramework = {
  id: "mainjsFramework",
  async check({ packageManager }) {
    const packageJson = packageManager.retrievePackageJson();
    const { mainConfig, framework, version: storybookVersion } = getStorybookInfo2(packageJson);
    if (!mainConfig) {
      logger6.warn("Unable to find storybook main.js config, skipping");
      return null;
    }
    const storybookCoerced = storybookVersion && semver8.coerce(storybookVersion)?.version;
    if (!storybookCoerced) {
      logger6.warn(dedent7`
        ❌ Unable to determine storybook version, skipping ${chalk8.cyan("mainjsFramework")} fix.
        🤔 Are you running automigrate from your project directory?
      `);
      return null;
    }
    const main = await readConfig2(mainConfig);
    const currentFramework = main.getFieldValue(["framework"]);
    const features = main.getFieldValue(["features"]);
    if (currentFramework)
      return null;
    return features?.breakingChangesV7 || features?.storyStoreV7 || semver8.gte(storybookCoerced, "7.0.0") ? { main, framework: `@storybook/${framework}` } : null;
  },
  prompt({ framework }) {
    const frameworkFormatted = chalk8.cyan(`framework: '${framework}'`);
    return dedent7`
      We've detected that your main.js configuration file does not specify the
      'framework' field, which is a requirement in SB7.0 and above. We can add one
      for you automatically:

      ${frameworkFormatted}

      More info: ${chalk8.yellow(
      "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field"
    )}
    `;
  },
  async run({ result: { main, framework }, dryRun }) {
    logger6.info(`\u2705 Setting 'framework' to '${framework}' in main.js`);
    if (!dryRun) {
      main.setFieldValue(["framework"], framework);
      await writeConfig2(main);
    }
  }
};

// src/automigrate/fixes/eslint-plugin.ts
import chalk9 from "chalk";
import { dedent as dedent8 } from "ts-dedent";
import { readConfig as readConfig3, writeConfig as writeConfig3 } from "@storybook/csf-tools";
import { getStorybookInfo as getStorybookInfo3 } from "@storybook/core-common";

// src/automigrate/helpers/getEslintInfo.ts
import fse5 from "fs-extra";
var SUPPORTED_ESLINT_EXTENSIONS = ["js", "cjs"];
var UNSUPPORTED_ESLINT_EXTENSIONS = ["yaml", "yml", "json"];
var findEslintFile = () => {
  const filePrefix = ".eslintrc";
  const unsupportedExtension = UNSUPPORTED_ESLINT_EXTENSIONS.find(
    (ext) => fse5.existsSync(`${filePrefix}.${ext}`)
  );
  if (unsupportedExtension) {
    throw new Error(unsupportedExtension);
  }
  const extension = SUPPORTED_ESLINT_EXTENSIONS.find(
    (ext) => fse5.existsSync(`${filePrefix}.${ext}`)
  );
  return extension ? `${filePrefix}.${extension}` : null;
};

// src/automigrate/fixes/eslint-plugin.ts
var logger7 = console;
var eslintPlugin = {
  id: "eslintPlugin",
  async check({ packageManager }) {
    const packageJson = packageManager.retrievePackageJson();
    const { dependencies, devDependencies } = packageJson;
    const eslintPluginStorybook = dependencies["eslint-plugin-storybook"] || devDependencies["eslint-plugin-storybook"];
    const eslintDependency = dependencies.eslint || devDependencies.eslint;
    if (eslintPluginStorybook || !eslintDependency) {
      return null;
    }
    const { mainConfig } = getStorybookInfo3(packageJson);
    if (!mainConfig) {
      logger7.warn("Unable to find storybook main.js config, skipping");
      return null;
    }
    let eslintFile;
    let unsupportedExtension;
    try {
      eslintFile = findEslintFile();
    } catch (err) {
      unsupportedExtension = err.message;
    }
    if (!eslintFile && !unsupportedExtension) {
      logger7.warn("Unable to find .eslintrc config file, skipping");
      return null;
    }
    const main = await readConfig3(mainConfig);
    return { eslintFile, main, unsupportedExtension };
  },
  prompt() {
    return dedent8`
      We've detected you are not using our eslint-plugin.

      In order to have the best experience with Storybook and follow best practices, we advise you to install eslint-plugin-storybook.

      More info: ${chalk9.yellow("https://github.com/storybookjs/eslint-plugin-storybook#readme")}
    `;
  },
  async run({ result: { eslintFile, unsupportedExtension }, packageManager, dryRun }) {
    const deps = [`eslint-plugin-storybook`];
    logger7.info(`\u2705 Adding dependencies: ${deps}`);
    if (!dryRun)
      packageManager.addDependencies({ installAsDevDependencies: true }, deps);
    if (!dryRun && unsupportedExtension) {
      throw new Error(dedent8`
          ⚠️ The plugin was successfuly installed but failed to configure.
          
          Found an .eslintrc config file with an unsupported automigration format: ${unsupportedExtension}.
          Supported formats for automigration are: ${SUPPORTED_ESLINT_EXTENSIONS.join(", ")}.

          Please refer to https://github.com/storybookjs/eslint-plugin-storybook#usage to finish setting up the plugin manually.
      `);
    }
    const eslint = await readConfig3(eslintFile);
    logger7.info(`\u2705 Configuring eslint rules in ${eslint.fileName}`);
    if (!dryRun) {
      logger7.info(`\u2705 Adding Storybook to extends list`);
      const extendsConfig = eslint.getFieldValue(["extends"]) || [];
      const existingConfigValue = Array.isArray(extendsConfig) ? extendsConfig : [extendsConfig];
      eslint.setFieldValue(["extends"], [...existingConfigValue, "plugin:storybook/recommended"]);
      await writeConfig3(eslint);
    }
  }
};

// src/automigrate/fixes/builder-vite.ts
import chalk10 from "chalk";
import { dedent as dedent9 } from "ts-dedent";
import { readConfig as readConfig4, writeConfig as writeConfig4 } from "@storybook/csf-tools";
import { getStorybookInfo as getStorybookInfo4 } from "@storybook/core-common";
var logger8 = console;
var builderVite = {
  id: "builder-vite",
  async check({ packageManager }) {
    const packageJson = packageManager.retrievePackageJson();
    const { mainConfig } = getStorybookInfo4(packageJson);
    if (!mainConfig) {
      logger8.warn("Unable to find storybook main.js config");
      return null;
    }
    const main = await readConfig4(mainConfig);
    const builder = main.getFieldValue(["core", "builder"]);
    const builderName = typeof builder === "string" ? builder : builder?.name;
    if (builderName !== "storybook-builder-vite") {
      return null;
    }
    return { builder, main, packageJson };
  },
  prompt({ builder }) {
    const builderFormatted = chalk10.cyan(JSON.stringify(builder, null, 2));
    return dedent9`
      We've detected you're using the community vite builder: ${builderFormatted}
      
      'storybook-builder-vite' is deprecated and now located at ${chalk10.cyan(
      "@storybook/builder-vite"
    )}.

      We can upgrade your project to use the new builder automatically.
      
      More info: ${chalk10.yellow(
      "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#vite-builder-renamed"
    )}
    `;
  },
  async run({ result: { builder, main, packageJson }, packageManager, dryRun }) {
    const { dependencies = {}, devDependencies = {} } = packageJson;
    logger8.info(`Removing existing 'storybook-builder-vite' dependency`);
    if (!dryRun) {
      delete dependencies["storybook-builder-vite"];
      delete devDependencies["storybook-builder-vite"];
      packageManager.writePackageJson(packageJson);
    }
    logger8.info(`Adding '@storybook/builder-vite' as dev dependency`);
    if (!dryRun) {
      packageManager.addDependencies({ installAsDevDependencies: true }, [
        "@storybook/builder-vite"
      ]);
    }
    logger8.info(`Updating main.js to use vite builder`);
    if (!dryRun) {
      const updatedBuilder = typeof builder === "string" ? "@storybook/builder-vite" : { name: "@storybook/builder-vite", options: builder.options };
      main.setFieldValue(["core", "builder"], updatedBuilder);
      await writeConfig4(main);
    }
  }
};

// src/automigrate/fixes/npm7.ts
import chalk11 from "chalk";
import { dedent as dedent10 } from "ts-dedent";
var npm7 = {
  id: "npm7",
  async check({ packageManager }) {
    if (packageManager.type !== "npm")
      return null;
    const npmVersion = packageManager.getNpmVersion();
    if (packageManager.needsLegacyPeerDeps(npmVersion)) {
      return { npmVersion };
    }
    return null;
  },
  prompt({ npmVersion }) {
    const npmFormatted = chalk11.cyan(`npm ${npmVersion}`);
    return dedent10`
      We've detected you are running ${npmFormatted} which has peer dependency semantics which Storybook is incompatible with.

      In order to work with Storybook's package structure, you'll need to run \`npm\` with the
      \`--legacy-peer-deps=true\` flag. We can generate an \`.npmrc\` which will do that automatically.
      
      More info: ${chalk11.yellow("https://github.com/storybookjs/storybook/issues/18298")}
    `;
  },
  async run({ packageManager }) {
    packageManager.setLegacyPeerDeps();
  }
};

// src/automigrate/fixes/sb-scripts.ts
import chalk12 from "chalk";
import { dedent as dedent11 } from "ts-dedent";
import semver9 from "@storybook/semver";
import { getStorybookInfo as getStorybookInfo5 } from "@storybook/core-common";
var logger9 = console;
var getStorybookScripts = (scripts) => {
  const storybookScripts = {
    custom: {},
    official: {}
  };
  Object.keys(scripts).forEach((key) => {
    if (key === "storybook" || key === "build-storybook") {
      storybookScripts.official[key] = scripts[key];
    } else if (scripts[key].match(/start-storybook/) || scripts[key].match(/build-storybook/)) {
      storybookScripts.custom[key] = scripts[key];
    }
  });
  return storybookScripts;
};
var sbScripts = {
  id: "sb-scripts",
  async check({ packageManager }) {
    const packageJson = packageManager.retrievePackageJson();
    const { scripts = {}, devDependencies, dependencies } = packageJson;
    const { version: storybookVersion } = getStorybookInfo5(packageJson);
    const allDeps = { ...dependencies, ...devDependencies };
    const storybookCoerced = storybookVersion && semver9.coerce(storybookVersion)?.version;
    if (!storybookCoerced) {
      logger9.warn(dedent11`
        ❌ Unable to determine storybook version, skipping ${chalk12.cyan("sb-scripts")} fix.
        🤔 Are you running automigrate from your project directory?
      `);
      return null;
    }
    if (allDeps.sb || allDeps.storybook) {
      return null;
    }
    const storybookScripts = getStorybookScripts(scripts);
    if (Object.keys(storybookScripts.official).length === 0 && Object.keys(storybookScripts.custom).length === 0) {
      return null;
    }
    Object.keys(storybookScripts.official).forEach((key) => {
      storybookScripts.official[key] = storybookScripts.official[key].replace("start-storybook", "storybook dev").replace("build-storybook", "storybook build");
    });
    return semver9.gte(storybookCoerced, "7.0.0") ? { packageJson, storybookScripts, storybookVersion } : null;
  },
  prompt({ storybookVersion }) {
    const sbFormatted = chalk12.cyan(`Storybook ${storybookVersion}`);
    const explanationMessage = [
      `Starting in Storybook 7, the ${chalk12.yellow("start-storybook")} and ${chalk12.yellow(
        "build-storybook"
      )} binaries have changed to ${chalk12.magenta("storybook dev")} and ${chalk12.magenta(
        "storybook build"
      )} respectively.`,
      `In order to work with ${sbFormatted}, Storybook's ${chalk12.magenta(
        "storybook"
      )} binary has to be installed and your storybook scripts have to be adjusted to use the binary. We can install the storybook binary and attempt to adjust your scripts for you.`
    ].join("\n");
    return [
      `We've detected you are using ${sbFormatted} with scripts from previous versions of Storybook.`,
      explanationMessage,
      `More info: ${chalk12.yellow(
        "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#start-storybook--build-storybook-binaries-removed"
      )}`
    ].filter(Boolean).join("\n\n");
  },
  async run({ result: { storybookScripts, packageJson }, packageManager, dryRun }) {
    logger9.log();
    logger9.info(`Adding 'storybook' as dev dependency`);
    logger9.log();
    if (!dryRun) {
      const versionToInstall = getStorybookVersionSpecifier(packageJson);
      packageManager.addDependencies({ installAsDevDependencies: true }, [
        `storybook@${versionToInstall}`
      ]);
    }
    logger9.info(`Updating scripts in package.json`);
    logger9.log();
    if (!dryRun && Object.keys(storybookScripts.official).length > 0) {
      const message = [
        `Migrating your scripts to:`,
        chalk12.yellow(JSON.stringify(storybookScripts.official, null, 2))
      ].join("\n");
      logger9.log(message);
      logger9.log();
      packageManager.addScripts(storybookScripts.official);
    }
    if (!dryRun && Object.keys(storybookScripts.custom).length > 0) {
      const message = [
        `We detected custom scripts that we can't automigrate:`,
        chalk12.yellow(JSON.stringify(storybookScripts.custom, null, 2)),
        "\n",
        `Please manually migrate the ones applicable and use the documentation below for reference: ${chalk12.yellow(
          "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#start-storybook--build-storybook-binaries-removed"
        )}`
      ].join("\n");
      logger9.log(message);
      logger9.log();
    }
  }
};

// src/automigrate/fixes/new-frameworks.ts
import chalk13 from "chalk";
import dedent12 from "ts-dedent";
import semver10 from "@storybook/semver";
import { readConfig as readConfig5, writeConfig as writeConfig5 } from "@storybook/csf-tools";
import { getStorybookInfo as getStorybookInfo6 } from "@storybook/core-common";
var logger10 = console;
var packagesMap = {
  "@storybook/react": {
    webpack5: "@storybook/react-webpack5",
    vite: "@storybook/react-vite"
  },
  "@storybook/preact": {
    webpack5: "@storybook/preact-webpack5"
  },
  "@storybook/server": {
    webpack5: "@storybook/server-webpack5"
  },
  "@storybook/angular": {
    webpack5: "@storybook/angular"
  },
  "@storybook/vue": {
    webpack5: "@storybook/vue-webpack5"
  },
  "@storybook/vue3": {
    webpack5: "@storybook/vue3-webpack5",
    vite: "@storybook/vue3-vite"
  },
  "@storybook/svelte": {
    webpack5: "@storybook/svelte-webpack5",
    vite: "@storybook/svelte-vite"
  },
  "@storybook/web-components": {
    webpack5: "@storybook/web-components-webpack5",
    vite: "@storybook/web-components-vite"
  },
  "@storybook/html": {
    webpack5: "@storybook/html-webpack5"
  }
};
var getBuilder = (builder) => {
  if (typeof builder === "string") {
    return builder.includes("vite") ? "vite" : "webpack5";
  }
  return builder?.name.includes("vite") ? "vite" : "webpack5";
};
var getFrameworkOptions = (framework, main) => {
  const frameworkOptions = main.getFieldValue([`${framework}Options`]);
  return frameworkOptions || {};
};
var newFrameworks = {
  id: "newFrameworks",
  async check({ packageManager }) {
    const packageJson = packageManager.retrievePackageJson();
    const allDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };
    const { mainConfig, version: storybookVersion, framework } = getStorybookInfo6(packageJson);
    if (!mainConfig) {
      logger10.warn("Unable to find storybook main.js config, skipping");
      return null;
    }
    const storybookCoerced = storybookVersion && semver10.coerce(storybookVersion)?.version;
    if (!storybookCoerced) {
      logger10.warn(dedent12`
        ❌ Unable to determine storybook version, skipping ${chalk13.cyan("newFrameworks")} fix.
        🤔 Are you running automigrate from your project directory?
      `);
      return null;
    }
    if (!semver10.gte(storybookCoerced, "7.0.0")) {
      return null;
    }
    const main = await readConfig5(mainConfig);
    const frameworkPackage = main.getFieldValue(["framework"]);
    const builder = main.getFieldValue(["core", "builder"]);
    if (!frameworkPackage) {
      return null;
    }
    const supportedPackages = Object.keys(packagesMap);
    if (!supportedPackages.includes(frameworkPackage)) {
      return null;
    }
    const builderInfo = {
      name: getBuilder(builder),
      options: main.getFieldValue(["core", "builder", "options"]) || {}
    };
    const newFrameworkPackage = packagesMap[frameworkPackage][builderInfo.name];
    if (!newFrameworkPackage) {
      return null;
    }
    if (allDeps.vite && semver10.lt(semver10.coerce(allDeps.vite).version, "3.0.0")) {
      logger10.warn(dedent12`
        ❌ Detected Vite ${allDeps.vite}, which is unsupported in Storybook 7.0, so the ${chalk13.cyan(
        "newFrameworks"
      )} fix will be skipped.
      Please upgrade vite to 3.0.0 or higher and rerun this automigration with "npx storybook@future automigrate".
      `);
      return null;
    }
    const frameworkOptions = getFrameworkOptions(framework, main);
    const dependenciesToRemove = [
      "@storybook/builder-webpack5",
      "@storybook/manager-webpack5",
      "@storybook/builder-webpack4",
      "@storybook/manager-webpack4",
      "@storybook/builder-vite",
      "storybook-builder-vite"
    ].filter((dep) => allDeps[dep]);
    const dependenciesToAdd = [];
    if (newFrameworkPackage !== frameworkPackage) {
      dependenciesToAdd.push(newFrameworkPackage);
    }
    return {
      main,
      dependenciesToAdd,
      dependenciesToRemove,
      frameworkPackage: newFrameworkPackage,
      frameworkOptions,
      builderInfo,
      packageJson
    };
  },
  prompt() {
    return dedent12`
      We've detected you are using an older format of Storybook frameworks and builders.

      In Storybook 7, frameworks also specify the builder to be used.

      We can remove the dependencies that are no longer needed and install the new framework that already includes the builder.

      To learn more about the framework field, see: ${chalk13.yellow(
      "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#framework-field-mandatory"
    )}

      ${chalk13.underline(chalk13.bold(chalk13.cyan("Webpack4 users")))}

      Unless you're using Storybook's Vite builder, this automigration will install a Webpack5-based framework.
      
      If you were using Storybook's Webpack4 builder (default in 6.x, discontinued in 7.0), this could be a breaking
      change--especially if your project has a custom webpack configuration.
      
      To learn more about migrating from Webpack4, see: ${chalk13.yellow(
      "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#webpack4-support-discontinued"
    )}
    `;
  },
  async run({
    result: {
      dependenciesToAdd,
      dependenciesToRemove,
      main,
      frameworkPackage,
      frameworkOptions,
      builderInfo,
      packageJson
    },
    packageManager,
    dryRun
  }) {
    logger10.info(`\u2705 Removing legacy dependencies: ${dependenciesToRemove.join(", ")}`);
    if (!dryRun) {
      packageManager.removeDependencies(
        { skipInstall: dependenciesToAdd.length > 0, packageJson },
        dependenciesToRemove
      );
    }
    if (dependenciesToAdd.length > 0) {
      logger10.info(`\u2705 Installing new dependencies: ${dependenciesToAdd.join(", ")}`);
      if (!dryRun) {
        const versionToInstall = getStorybookVersionSpecifier(packageJson);
        const depsToAdd = dependenciesToAdd.map((dep) => `${dep}@${versionToInstall}`);
        packageManager.addDependencies({ installAsDevDependencies: true }, depsToAdd);
      }
    }
    if (!dryRun) {
      logger10.info(`\u2705 Updating framework field in main.js`);
      const currentCore = main.getFieldValue(["core"]);
      main.setFieldValue(["framework", "name"], frameworkPackage);
      main.setFieldValue(["framework", "options"], frameworkOptions);
      if (currentCore?.builder) {
        delete currentCore.builder;
      }
      if (Object.keys(builderInfo.options).length > 0) {
        main.setFieldValue(["framework", "options", "builder"], builderInfo.options);
      }
      if (currentCore) {
        if (Object.keys(currentCore).length === 0) {
          main.setFieldValue(["core"], {});
        } else {
          main.setFieldValue(["core"], currentCore);
        }
      }
      await writeConfig5(main);
    }
  }
};

// src/automigrate/fixes/index.ts
var fixes = [
  cra5,
  webpack5,
  angular12,
  vue3,
  mainjsFramework,
  eslintPlugin,
  builderVite,
  npm7,
  sbScripts,
  newFrameworks
];

// src/automigrate/index.ts
var logger11 = console;
var automigrate = async ({ fixId, dryRun, yes } = {}) => {
  const packageManager = JsPackageManagerFactory.getPackageManager();
  const filtered = fixId ? fixes.filter((f) => f.id === fixId) : fixes;
  logger11.info("\u{1F50E} checking possible migrations..");
  for (let i = 0; i < filtered.length; i += 1) {
    const f = fixes[i];
    let result;
    try {
      result = await f.check({ packageManager });
    } catch (e) {
      logger11.info(`failed to check fix: ${f.id}`);
    }
    if (result) {
      logger11.info(`\u{1F50E} found a '${chalk14.cyan(f.id)}' migration:`);
      logger11.info();
      const message = f.prompt(result);
      logger11.info(
        boxen(message, { borderStyle: "round", padding: 1, borderColor: "#F1618C" })
      );
      let runAnswer;
      if (dryRun) {
        runAnswer = { fix: false };
      } else if (yes) {
        runAnswer = { fix: true };
      } else {
        runAnswer = await prompts2({
          type: "confirm",
          name: "fix",
          message: `Do you want to run the '${chalk14.cyan(f.id)}' migration on your project?`
        });
      }
      if (runAnswer.fix) {
        try {
          await f.run({ result, packageManager, dryRun });
          logger11.info(`\u2705 ran ${chalk14.cyan(f.id)} migration`);
        } catch (error) {
          logger11.info(`\u274C error when running ${chalk14.cyan(f.id)} migration:`);
          logger11.info(error);
          logger11.info();
        }
      } else {
        logger11.info(`Skipping the ${chalk14.cyan(f.id)} migration.`);
        logger11.info();
        logger11.info(
          `If you change your mind, run '${chalk14.cyan("npx storybook@next automigrate")}'`
        );
      }
    }
  }
  logger11.info();
  logger11.info("\u2705 migration check successfully ran");
  logger11.info();
};

// src/initiate.ts
var logger12 = console;
var installStorybook = (projectType, packageManager, options) => {
  const npmOptions = {
    installAsDevDependencies: true,
    skipInstall: options.skipInstall
  };
  let packageJson;
  try {
    packageJson = packageManager.readPackageJson();
  } catch (err) {
  }
  const language = detectLanguage(packageJson);
  const generatorOptions = {
    language,
    builder: options.builder || detectBuilder(packageManager),
    linkable: !!options.linkable,
    commonJs: options.commonJs,
    pnp: options.usePnp
  };
  const runGenerator = async () => {
    switch (projectType) {
      case "ALREADY_HAS_STORYBOOK" /* ALREADY_HAS_STORYBOOK */:
        logger12.log();
        paddedLog("There seems to be a Storybook already available in this project.");
        paddedLog("Apply following command to force:\n");
        codeLog(["sb init [options] -f"]);
        logger12.log();
        return Promise.resolve();
      case "REACT_SCRIPTS" /* REACT_SCRIPTS */:
        return REACT_SCRIPTS_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "Create React App" based project')
        );
      case "REACT" /* REACT */:
        return REACT_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "React" app\n')
        );
      case "REACT_NATIVE" /* REACT_NATIVE */: {
        return (options.yes ? Promise.resolve({ server: true }) : prompts3([
          {
            type: "confirm",
            name: "server",
            message: "Do you want to install dependencies necessary to run Storybook server? You can manually do it later by install @storybook/react-native-server",
            initial: false
          }
        ])).then(({ server }) => REACT_NATIVE_default(packageManager, npmOptions, server)).then(commandLog('Adding Storybook support to your "React Native" app\n'));
      }
      case "WEBPACK_REACT" /* WEBPACK_REACT */:
        return WEBPACK_REACT_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "Webpack React" app\n')
        );
      case "REACT_PROJECT" /* REACT_PROJECT */:
        return REACT_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "React" library\n')
        );
      case "SFC_VUE" /* SFC_VUE */:
        return SFC_VUE_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "Single File Components Vue" app\n')
        );
      case "VUE" /* VUE */:
        return VUE_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "Vue" app\n')
        );
      case "VUE3" /* VUE3 */:
        return VUE3_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "Vue 3" app\n')
        );
      case "ANGULAR" /* ANGULAR */:
        return ANGULAR_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "Angular" app\n')
        );
      case "EMBER" /* EMBER */:
        return EMBER_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "Ember" app\n')
        );
      case "MITHRIL" /* MITHRIL */:
        return MITHRIL_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "Mithril" app\n')
        );
      case "MARIONETTE" /* MARIONETTE */:
        return MARIONETTE_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "Marionette.js" app\n')
        );
      case "MARKO" /* MARKO */:
        return MARKO_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "Marko" app\n')
        );
      case "HTML" /* HTML */:
        return HTML_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "HTML" app\n')
        );
      case "WEB_COMPONENTS" /* WEB_COMPONENTS */:
        return WEB_COMPONENTS_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "web components" app\n')
        );
      case "RIOT" /* RIOT */:
        return RIOT_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "riot.js" app\n')
        );
      case "PREACT" /* PREACT */:
        return PREACT_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "Preact" app\n')
        );
      case "SVELTE" /* SVELTE */:
        return SVELTE_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "Svelte" app\n')
        );
      case "RAX" /* RAX */:
        return RAX_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "Rax" app\n')
        );
      case "AURELIA" /* AURELIA */:
        return AURELIA_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "Aurelia" app\n')
        );
      case "SERVER" /* SERVER */:
        return SERVER_default(packageManager, npmOptions, generatorOptions).then(
          commandLog('Adding Storybook support to your "Server" app\n')
        );
      case "UNSUPPORTED" /* UNSUPPORTED */:
        paddedLog(`We detected a project type that we don't support yet.`);
        paddedLog(
          `If you'd like your framework to be supported, please let use know about it at https://github.com/storybookjs/storybook/issues`
        );
        logger12.log();
        return Promise.resolve();
      default:
        paddedLog(`We couldn't detect your project type. (code: ${projectType})`);
        paddedLog(
          "You can specify a project type explicitly via `sb init --type <type>`, see our docs on how to configure Storybook for your framework: https://storybook.js.org/docs/react/get-started/install"
        );
        logger12.log();
        return projectTypeInquirer(options, packageManager);
    }
  };
  return runGenerator().catch((ex) => {
    logger12.error(`
     ${chalk15.red(ex.stack)}`);
    process.exit(1);
  });
};
var projectTypeInquirer = async (options, packageManager) => {
  const manualAnswer = options.yes ? true : await prompts3([
    {
      type: "confirm",
      name: "manual",
      message: "Do you want to manually choose a Storybook project type to install?"
    }
  ]);
  if (manualAnswer !== true && manualAnswer.manual) {
    const frameworkAnswer = await prompts3([
      {
        type: "select",
        name: "manualFramework",
        message: "Please choose a project type from the following list:",
        choices: installableProjectTypes.map((type) => ({
          title: type,
          value: type.toUpperCase()
        }))
      }
    ]);
    return installStorybook(frameworkAnswer.manualFramework, packageManager, options);
  }
  return Promise.resolve();
};
async function initiate(options, pkg2) {
  const packageManager = JsPackageManagerFactory.getPackageManager(options.useNpm);
  const welcomeMessage = "storybook init - the simplest way to add a Storybook to your project.";
  logger12.log(chalk15.inverse(`
 ${welcomeMessage} 
`));
  if (!options.disableTelemetry) {
    telemetry("init");
  }
  new UpdateNotifier({
    pkg: pkg2,
    updateCheckInterval: 1e3 * 60 * 60
  }).notify();
  let projectType;
  const projectTypeProvided = options.type;
  const infoText = projectTypeProvided ? `Installing Storybook for user specified project type: ${projectTypeProvided}` : "Detecting project type";
  const done = commandLog(infoText);
  const packageJson = packageManager.retrievePackageJson();
  const isEsm = packageJson && packageJson.type === "module";
  try {
    if (projectTypeProvided) {
      if (installableProjectTypes.includes(projectTypeProvided)) {
        const storybookInstalled = isStorybookInstalled(packageJson, options.force);
        projectType = storybookInstalled ? "ALREADY_HAS_STORYBOOK" /* ALREADY_HAS_STORYBOOK */ : projectTypeProvided.toUpperCase();
      } else {
        done(`The provided project type was not recognized by Storybook: ${projectTypeProvided}`);
        logger12.log(`
The project types currently supported by Storybook are:
`);
        installableProjectTypes.sort().forEach((framework) => paddedLog(`- ${framework}`));
        logger12.log();
        process.exit(1);
      }
    } else {
      projectType = detect(packageJson, options);
    }
  } catch (ex) {
    done(ex.message);
    process.exit(1);
  }
  done();
  await installStorybook(projectType, packageManager, {
    ...options,
    ...isEsm ? { commonJs: true } : void 0
  });
  if (!options.skipInstall) {
    packageManager.installDependencies();
  }
  await automigrate({ yes: options.yes || define_process_env_default.CI === "true" });
  logger12.log("\nTo run your Storybook, type:\n");
  codeLog([packageManager.getRunStorybookCommand()]);
  logger12.log("\nFor more information visit:", chalk15.cyan("https://storybook.js.org"));
  if (projectType === "REACT_NATIVE" /* REACT_NATIVE */) {
    const REACT_NATIVE_REPO = "https://github.com/storybookjs/react-native";
    logger12.log();
    logger12.log(chalk15.red("NOTE: installation is not 100% automated."));
    logger12.log(`To quickly run Storybook, replace contents of your app entry with:
`);
    codeLog(["export {default} from './storybook';"]);
    logger12.log("\n For more in information, see the github readme:\n");
    logger12.log(chalk15.cyan(REACT_NATIVE_REPO));
    logger12.log();
  }
  logger12.log();
}

// src/add.ts
import path8 from "path";
import fs6 from "fs";
import { sync as spawnSync3 } from "cross-spawn";
import { getStorybookInfo as getStorybookInfo7 } from "@storybook/core-common";
import { readConfig as readConfig6, writeConfig as writeConfig6 } from "@storybook/csf-tools";
var logger13 = console;
var LEGACY_CONFIGS = ["addons", "config", "presets"];
var postinstallAddon = async (addonName, isOfficialAddon) => {
  let skipMsg = null;
  if (!isOfficialAddon) {
    skipMsg = "unofficial addon";
  } else if (!fs6.existsSync(".storybook")) {
    skipMsg = "no .storybook config";
  } else {
    skipMsg = "no codmods found";
    LEGACY_CONFIGS.forEach((config) => {
      try {
        const codemod = __require.resolve(
          `${getPackageName(addonName, isOfficialAddon)}/postinstall/${config}.js`
        );
        commandLog(`Running postinstall script for ${addonName}`)();
        let configFile = path8.join(".storybook", `${config}.ts`);
        if (!fs6.existsSync(configFile)) {
          configFile = path8.join(".storybook", `${config}.js`);
          if (!fs6.existsSync(configFile)) {
            fs6.writeFileSync(configFile, "", "utf8");
          }
        }
        spawnSync3("npx", ["jscodeshift", "-t", codemod, configFile], {
          stdio: "inherit",
          shell: true
        });
        skipMsg = null;
      } catch (err) {
      }
    });
  }
  if (skipMsg) {
    commandLog(`Skipping postinstall for ${addonName}, ${skipMsg}`)();
  }
};
var getVersionSpecifier = (addon) => {
  const groups = /^(...*)@(.*)$/.exec(addon);
  return groups ? [groups[1], groups[2]] : [addon, void 0];
};
async function add(addon, options) {
  const packageManager = JsPackageManagerFactory.getPackageManager(options.useNpm);
  const packageJson = packageManager.retrievePackageJson();
  const [addonName, versionSpecifier] = getVersionSpecifier(addon);
  const { mainConfig, version: storybookVersion } = getStorybookInfo7(packageJson);
  if (!mainConfig) {
    logger13.error("Unable to find storybook main.js config");
    return;
  }
  const main = await readConfig6(mainConfig);
  const addons = main.getFieldValue(["addons"]);
  if (addons && !Array.isArray(addons)) {
    logger13.error("Expected addons array in main.js config");
  }
  logger13.log(`Verifying ${addonName}`);
  const latestVersion = packageManager.latestVersion(addonName);
  if (!latestVersion) {
    logger13.error(`Unknown addon ${addonName}`);
  }
  const isStorybookAddon = addonName.startsWith("@storybook/");
  const version = versionSpecifier || (isStorybookAddon ? storybookVersion : latestVersion);
  const addonWithVersion = `${addonName}@${version}`;
  logger13.log(`Installing ${addonWithVersion}`);
  packageManager.addDependencies({ installAsDevDependencies: true }, [addonWithVersion]);
  logger13.log(`Adding '${addon}' to main.js addons field.`);
  const updatedAddons = [...addons || [], addonName];
  main.setFieldValue(["addons"], updatedAddons);
  await writeConfig6(main);
  if (!options.skipPostinstall) {
    await postinstallAddon(addon, isStorybookAddon);
  }
}

// src/migrate.ts
import { listCodemods, runCodemod } from "@storybook/codemod";
async function migrate(migration, { configDir, glob, dryRun, list, rename, logger: logger23, parser }) {
  if (list) {
    listCodemods().forEach((key) => logger23.log(key));
  } else if (migration) {
    await runCodemod(migration, { configDir, glob, dryRun, logger: logger23, rename, parser });
  } else {
    throw new Error("Migrate: please specify a migration name or --list");
  }
}

// src/extract.ts
import path9 from "path";
import { writeFile as writeFile2, stat } from "fs-extra";
import puppeteerCore from "puppeteer-core";
import express from "express";
import getPort from "get-port";
import { logger as logger14 } from "@storybook/node-logger";
var read = async (url) => {
  const browser = await usePuppeteerBrowser();
  const page = await browser.newPage();
  await page.goto(url);
  await page.waitForFunction(`
    (window.__STORYBOOK_PREVIEW__ && window.__STORYBOOK_PREVIEW__.extract && window.__STORYBOOK_PREVIEW__.extract()) ||
    (window.__STORYBOOK_STORY_STORE__ && window.__STORYBOOK_STORY_STORE__.extract && window.__STORYBOOK_STORY_STORE__.extract())
  `);
  const data = JSON.parse(
    await page.evaluate(async () => {
      return JSON.stringify(window.__STORYBOOK_STORY_STORE__.getStoriesJsonData(), null, 2);
    })
  );
  setImmediate(() => {
    browser.close();
  });
  return data;
};
var useLocation = async (input) => {
  await stat(path9.resolve(input));
  if (input.match(/^http/)) {
    return [input, async () => {
    }];
  }
  const app = express();
  app.use(express.static(input));
  const port = await getPort();
  return new Promise((resolve2) => {
    const server = app.listen(port, () => {
      const result = `http://localhost:${port}/iframe.html`;
      logger14.info(`connecting to: ${result}`);
      resolve2([result, server.close.bind(server)]);
    });
  });
};
var usePuppeteerBrowser = async () => {
  const args = ["--no-sandbox ", "--disable-setuid-sandbox"];
  try {
    return await puppeteerCore.launch({ args, executablePath: define_process_env_default.SB_CHROMIUM_PATH });
  } catch (e) {
    logger14.info("installing puppeteer...");
    return new Promise((resolve2, reject) => {
      __require("child_process").exec(
        `node ${__require.resolve(path9.join("puppeteer-core", "install.js"))}`,
        (error) => error ? reject(error) : resolve2(puppeteerCore.launch({ args }))
      );
    });
  }
};
async function extract(input, targetPath) {
  if (input && targetPath) {
    const [location, exit] = await useLocation(input);
    const data = await read(location);
    await writeFile2(targetPath, JSON.stringify(data, null, 2));
    await exit();
  } else {
    throw new Error(
      "Extract: please specify a path where your built-storybook is (can be a public url) and a target directory"
    );
  }
}

// src/upgrade.ts
import { sync as spawnSync4 } from "cross-spawn";
import { telemetry as telemetry2 } from "@storybook/telemetry";
import semver11 from "@storybook/semver";
import { logger as logger15 } from "@storybook/node-logger";
var versionRegex = /(@storybook\/[^@]+)@(\S+)/;
var getStorybookVersion = (line) => {
  if (line.startsWith("npm "))
    return null;
  const match = versionRegex.exec(line);
  if (!match || !semver11.clean(match[2]))
    return null;
  return {
    package: match[1],
    version: match[2]
  };
};
var excludeList = [
  "@storybook/addon-bench",
  "@storybook/addon-console",
  "@storybook/addon-postcss",
  "@storybook/babel-plugin-require-context-hook",
  "@storybook/bench",
  "@storybook/builder-vite",
  "@storybook/csf",
  "@storybook/design-system",
  "@storybook/ember-cli-storybook",
  "@storybook/eslint-config-storybook",
  "@storybook/expect",
  "@storybook/jest",
  "@storybook/linter-config",
  "@storybook/mdx1-csf",
  "@storybook/mdx2-csf",
  "@storybook/react-docgen-typescript-plugin",
  "@storybook/semver",
  "@storybook/storybook-deployer",
  "@storybook/test-runner",
  "@storybook/testing-library",
  "@storybook/testing-react"
];
var isCorePackage = (pkg2) => pkg2.startsWith("@storybook/") && !pkg2.startsWith("@storybook/preset-") && !excludeList.includes(pkg2);
var deprecatedPackages = [
  {
    minVersion: "6.0.0-alpha.0",
    url: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#60-deprecations",
    deprecations: [
      "@storybook/addon-notes",
      "@storybook/addon-info",
      "@storybook/addon-contexts",
      "@storybook/addon-options",
      "@storybook/addon-centered"
    ]
  }
];
var formatPackage = (pkg2) => `${pkg2.package}@${pkg2.version}`;
var warnPackages = (pkgs) => pkgs.forEach((pkg2) => logger15.warn(`- ${formatPackage(pkg2)}`));
var checkVersionConsistency = () => {
  const lines = spawnSync4("npm", ["ls"], { stdio: "pipe", shell: true }).output.toString().split("\n");
  const storybookPackages = lines.map(getStorybookVersion).filter(Boolean).filter((pkg2) => isCorePackage(pkg2.package));
  if (!storybookPackages.length) {
    logger15.warn("No storybook core packages found.");
    logger15.warn(`'npm ls | grep storybook' can show if multiple versions are installed.`);
    return;
  }
  storybookPackages.sort((a, b) => semver11.rcompare(a.version, b.version));
  const latestVersion = storybookPackages[0].version;
  const outdated = storybookPackages.filter((pkg2) => pkg2.version !== latestVersion);
  if (outdated.length > 0) {
    logger15.warn(
      `Found ${outdated.length} outdated packages (relative to '${formatPackage(
        storybookPackages[0]
      )}')`
    );
    logger15.warn("Please make sure your packages are updated to ensure a consistent experience.");
    warnPackages(outdated);
  }
  deprecatedPackages.forEach(({ minVersion: minVersion2, url, deprecations }) => {
    if (semver11.gte(latestVersion, minVersion2)) {
      const deprecated = storybookPackages.filter((pkg2) => deprecations.includes(pkg2.package));
      if (deprecated.length > 0) {
        logger15.warn(`Found ${deprecated.length} deprecated packages since ${minVersion2}`);
        logger15.warn(`See ${url}`);
        warnPackages(deprecated);
      }
    }
  });
};
var EXTRA_FLAGS = {
  "react-scripts@<5": ["--reject", "/preset-create-react-app/"]
};
var addExtraFlags = (extraFlags, flags, { dependencies, devDependencies }) => {
  return Object.entries(extraFlags).reduce(
    (acc, entry) => {
      const [pattern, extra] = entry;
      const [pkg2, specifier] = getPackageDetails(pattern);
      const pkgVersion = dependencies[pkg2] || devDependencies[pkg2];
      if (pkgVersion && semver11.satisfies(semver11.coerce(pkgVersion), specifier)) {
        return [...acc, ...extra];
      }
      return acc;
    },
    [...flags]
  );
};
var upgrade = async ({
  prerelease,
  skipCheck,
  useNpm,
  dryRun,
  yes,
  ...options
}) => {
  const packageManager = JsPackageManagerFactory.getPackageManager(useNpm);
  commandLog(`Checking for latest versions of '@storybook/*' packages`);
  if (!options.disableTelemetry) {
    telemetry2("upgrade", { prerelease });
  }
  let flags = [];
  if (!dryRun)
    flags.push("--upgrade");
  flags.push("--target");
  flags.push(prerelease ? "greatest" : "latest");
  flags = addExtraFlags(EXTRA_FLAGS, flags, packageManager.retrievePackageJson());
  const check = spawnSync4("npx", ["npm-check-updates@latest", "/storybook/", ...flags], {
    stdio: "pipe",
    shell: true
  }).output.toString();
  logger15.info(check);
  if (!dryRun) {
    commandLog(`Installing upgrades`);
    packageManager.installDependencies();
  }
  if (!skipCheck) {
    checkVersionConsistency();
    await automigrate({ dryRun, yes });
  }
};

// src/repro.ts
import prompts4 from "prompts";
import fs7 from "fs";
import path11 from "path";
import chalk17 from "chalk";
import boxen2 from "boxen";
import { dedent as dedent13 } from "ts-dedent";

// src/repro-generators/scripts.ts
import path10 from "path";
import { readJSON, writeJSON, outputFile } from "fs-extra";
import shell2 from "shelljs";
import chalk16 from "chalk";
import { command } from "execa";

// src/repro-generators/configs.ts
var configs_exports = {};
__export(configs_exports, {
  angular: () => angular,
  angular12: () => angular122,
  angular13: () => angular13,
  angular130: () => angular130,
  cra: () => cra,
  cra_typescript: () => cra_typescript,
  html: () => html,
  preact: () => preact,
  react: () => react,
  react_in_yarn_workspace: () => react_in_yarn_workspace,
  react_legacy_root_api: () => react_legacy_root_api,
  react_typescript: () => react_typescript,
  sfcVue: () => sfcVue,
  svelte: () => svelte,
  vue: () => vue,
  vue3: () => vue32,
  web_components: () => web_components,
  web_components_lit2: () => web_components_lit2,
  web_components_typescript: () => web_components_typescript
});
var fromDeps = (...args) => [
  "mkdir {{appName}}",
  "cd {{appName}}",
  "touch yarn.lock",
  "yarn init --yes",
  args.length && `yarn add ${args.join(" ")}`
].filter(Boolean).join(" && ");
var cra = {
  renderer: "react",
  name: "cra",
  version: "latest",
  generator: [
    "npm_config_user_agent=npm npx -p create-react-app@{{version}} create-react-app {{appName}}",
    "cd {{appName}}",
    'echo "FAST_REFRESH=true" > .env',
    'echo "SKIP_PREFLIGHT_CHECK=true" > .env'
  ].join(" && ")
};
var cra_typescript = {
  renderer: "react",
  name: "cra_typescript",
  version: "latest",
  generator: [
    "npm_config_user_agent=npm npx -p create-react-app@{{version}} create-react-app {{appName}} --template typescript"
  ].join(" && ")
};
var react = {
  renderer: "react",
  name: "react",
  version: "latest",
  generator: fromDeps("react", "react-dom", "@babel/preset-react"),
  additionalDeps: ["prop-types"],
  additionalFiles: [{ path: ".babelrc", contents: '{ "presets": ["@babel/preset-react"] }' }]
};
var react_legacy_root_api = {
  renderer: "react",
  name: "react_legacy_root_api",
  version: "latest",
  generator: fromDeps("react", "react-dom"),
  additionalDeps: ["prop-types", "@babel/preset-react"],
  additionalFiles: [{ path: ".babelrc", contents: '{ "presets": ["@babel/preset-react"] }' }],
  mainOverrides: {
    reactOptions: {
      legacyRootApi: true
    }
  }
};
var react_typescript = {
  renderer: "react",
  name: "react_typescript",
  version: "latest",
  generator: fromDeps("react", "react-dom"),
  typescript: true,
  additionalDeps: ["@babel/preset-react", "@babel/preset-typescript"],
  additionalFiles: [
    {
      path: ".babelrc",
      contents: '{ "presets": ["@babel/preset-react", "@babel/preset-typescript"] }'
    }
  ]
};
var react_in_yarn_workspace = {
  renderer: "react",
  name: "react_in_yarn_workspace",
  version: "latest",
  generator: [
    "mkdir {{appName}}",
    "cd {{appName}}",
    'echo "{ \\"name\\": \\"workspace-root\\", \\"private\\": true, \\"workspaces\\": [] }" > package.json',
    "touch yarn.lock",
    `yarn add react react-dom`
  ].join(" && ")
};
var baseAngular = {
  renderer: "angular",
  name: "angular",
  version: "latest",
  generator: `npx -p @angular/cli@{{version}} ng new {{appName}} --routing=true --minimal=true --style=scss --skip-install=true --strict`
};
var angular122 = {
  ...baseAngular,
  name: "angular12",
  version: "v12-lts"
};
var angular130 = {
  ...baseAngular,
  name: "angular130",
  version: "13.0.x"
};
var angular13 = {
  ...baseAngular,
  name: "angular13",
  version: "13.1.x"
};
var angular = baseAngular;
var web_components = {
  renderer: "web-components",
  name: "web_components",
  version: "2",
  generator: fromDeps("lit-element")
};
var web_components_typescript = {
  ...web_components,
  name: "web_components_typescript",
  typescript: true,
  additionalDeps: ["@babel/preset-typescript"],
  additionalFiles: [
    {
      path: ".babelrc",
      contents: '{ "presets": ["@babel/preset-typescript"] }'
    }
  ]
};
var web_components_lit2 = {
  ...web_components,
  version: "next",
  name: "web_components_lit2",
  generator: fromDeps("lit"),
  typescript: true,
  additionalDeps: ["@babel/preset-typescript"],
  additionalFiles: [
    {
      path: ".babelrc",
      contents: '{ "presets": ["@babel/preset-typescript"] }'
    }
  ]
};
var vue = {
  renderer: "vue",
  name: "vue",
  version: "latest",
  generator: [
    `npx -p @vue/cli vue create {{appName}} --default --packageManager=yarn --force --merge --preset="Default (Vue 2)"`
  ].join(" && ")
};
var vue32 = {
  renderer: "vue3",
  name: "vue3",
  version: "next",
  generator: [
    `npx -p @vue/cli@^4 vue create {{appName}} --preset=__default_vue_3__ --packageManager=npm --no-git --force`
  ].join(" && ")
};
var html = {
  renderer: "html",
  name: "html",
  version: "latest",
  generator: fromDeps(),
  autoDetect: false
};
var preact = {
  renderer: "preact",
  name: "preact",
  version: "latest",
  generator: "npx preact-cli@{{version}} create preactjs-templates/default {{appName}} --install=false --git=false"
};
var sfcVue = {
  renderer: "vue",
  name: "sfcVue",
  version: "latest",
  generator: fromDeps("vue@2.6", "vue-loader@15.9", "vue-template-compiler@2.6", "webpack")
};
var svelte = {
  renderer: "svelte",
  name: "svelte",
  version: "latest",
  generator: "npx degit sveltejs/template {{appName}}"
};

// src/repro-generators/scripts.ts
var logger16 = console;
var exec = async (command2, options = {}, {
  startMessage,
  errorMessage,
  dryRun
} = {}) => {
  if (startMessage)
    logger16.info(startMessage);
  if (dryRun) {
    logger16.info(`
> ${command2}
`);
    return void 0;
  }
  logger16.debug(command2);
  return new Promise((resolve2, reject) => {
    const defaultOptions2 = {
      silent: false
    };
    const child = shell2.exec(command2, {
      ...defaultOptions2,
      ...options,
      async: true,
      silent: false
    });
    child.stderr.pipe(process.stderr);
    child.on("exit", (code) => {
      if (code === 0) {
        resolve2(void 0);
      } else {
        logger16.error(chalk16.red(`An error occurred while executing: \`${command2}\``));
        logger16.log(errorMessage);
        reject(new Error(`command exited with code: ${code}: `));
      }
    });
  });
};
var addPackageResolutions = async ({ cwd }) => {
  logger16.info(`\u{1F522} Adding package resolutions:`);
  const packageJsonPath = path10.join(cwd, "package.json");
  const packageJson = await readJSON(packageJsonPath);
  packageJson.resolutions = versions_default;
  await writeJSON(packageJsonPath, packageJson, { spaces: 2 });
};
var addLocalPackageResolutions = async ({ cwd }) => {
  logger16.info(`\u{1F522} Adding package resolutions:`);
  const packageJsonPath = path10.join(cwd, "package.json");
  const packageJson = await readJSON(packageJsonPath);
  const workspaceDir = path10.join(__dirname, "..", "..", "..", "..", "..");
  const { stdout } = await command("yarn workspaces list --json", { cwd: workspaceDir });
  console.log({ stdout, workspaceDir });
  const workspaces = JSON.parse(`[${stdout.split("\n").join(",")}]`);
  console.log({ workspaces });
  packageJson.resolutions = Object.keys(versions_default).reduce((acc, key) => {
    return {
      ...acc,
      [key]: path10.join(workspaceDir, workspaces.find((item) => item.name === key).location)
    };
  }, {});
  await writeJSON(packageJsonPath, packageJson, { spaces: 2 });
};
var installYarn2 = async ({ cwd, pnp, name }) => {
  const command2 = [
    `yarn set version berry`,
    `yarn config set enableGlobalCache true`,
    `yarn config set nodeLinker ${pnp ? "pnp" : "node-modules"}`
  ];
  if ([cra.name, cra_typescript.name].includes(name)) {
    command2.push(
      `yarn config set packageExtensions --json '{ "babel-preset-react-app@10.0.x": { "dependencies": { "@babel/plugin-proposal-private-property-in-object": "^7.16.0" } } }'`
    );
  }
  await exec(
    command2.join(" && "),
    { cwd },
    { startMessage: `\u{1F9F6} Installing Yarn 2`, errorMessage: `\u{1F6A8} Installing Yarn 2 failed` }
  );
};
var configureYarn2ForE2E = async ({ cwd }) => {
  const command2 = [
    `yarn config set npmScopes --json '{ "storybook": { "npmRegistryServer": "http://localhost:6001/" } }'`,
    `yarn config set unsafeHttpWhitelist --json '["localhost"]'`,
    `yarn config set pnpFallbackMode none`,
    `yarn config set enableImmutableInstalls false`,
    `yarn config set logFilters --json '[ { "code": "YN0013", "level": "discard" } ]'`
  ].join(" && ");
  await exec(
    command2,
    { cwd },
    { startMessage: `\u{1F39B} Configuring Yarn 2`, errorMessage: `\u{1F6A8} Configuring Yarn 2 failed` }
  );
};
var generate = async ({ cwd, name, appName, version, generator: generator21 }) => {
  const command2 = generator21.replace(/{{appName}}/g, appName).replace(/{{version}}/g, version);
  await exec(
    command2,
    { cwd },
    {
      startMessage: `\u{1F3D7} Bootstrapping ${name} project (this might take a few minutes)`,
      errorMessage: `\u{1F6A8} Bootstrapping ${name} failed`
    }
  );
};
var addAdditionalFiles = async ({ additionalFiles, cwd }) => {
  logger16.info(`\u2935\uFE0F Adding required files`);
  await Promise.all(
    additionalFiles.map(async (file) => {
      await outputFile(path10.resolve(cwd, file.path), file.contents, { encoding: "UTF-8" });
    })
  );
};
var initStorybook = async ({ cwd, autoDetect = true, name, e2e, pnp }) => {
  const flags = ["--yes"];
  if (!autoDetect) {
    flags.push(`--type ${name}`);
  }
  if (e2e) {
    flags.push("--linkable");
  }
  if (pnp) {
    flags.push("--use-pnp");
  }
  const sbCLICommand = `node ${__filename}`;
  const command2 = `${sbCLICommand} init ${flags.join(" ")}`;
  await exec(
    command2,
    { cwd },
    {
      startMessage: `\u{1F3A8} Initializing Storybook with @storybook/cli`,
      errorMessage: `\u{1F6A8} Storybook initialization failed`
    }
  );
};
var addRequiredDeps = async ({ cwd, additionalDeps }) => {
  shell2.rm("-f", path10.join(cwd, "package-lock.json"), path10.join(cwd, "yarn.lock"));
  const command2 = additionalDeps && additionalDeps.length > 0 ? `yarn add -D ${additionalDeps.join(" ")}` : `yarn install`;
  await exec(
    command2,
    { cwd },
    {
      startMessage: `\u{1F30D} Adding needed deps & installing all deps`,
      errorMessage: `\u{1F6A8} Dependencies installation failed`
    }
  );
};
var addTypescript = async ({ cwd }) => {
  logger16.info(`\u{1F46E} Adding typescript and tsconfig.json`);
  try {
    await exec(`yarn add -D typescript@latest`, { cwd });
    const tsConfig = {
      compilerOptions: {
        baseUrl: ".",
        esModuleInterop: true,
        jsx: "preserve",
        skipLibCheck: true,
        strict: true
      },
      include: ["src/*"]
    };
    const tsConfigJsonPath = path10.resolve(cwd, "tsconfig.json");
    await writeJSON(tsConfigJsonPath, tsConfig, { encoding: "utf8", spaces: 2 });
  } catch (e) {
    logger16.error(`\u{1F6A8} Creating tsconfig.json failed`);
    throw e;
  }
};
var doTask = async (task, options, condition = true) => {
  if (condition) {
    await task(options);
    logger16.log();
  }
};
var registryUrlNPM = (url) => {
  const args = ["config", "set", "registry", url];
  return exec(`npm ${args.join(" ")}`, { cwd: path10.join(process.cwd(), "..") });
};
var registryUrlYarn = (url) => {
  const args = ["config", "set", "npmRegistryServer", url];
  return exec(`yarn ${args.join(" ")}`, { cwd: path10.join(__dirname, "..") });
};
var createAndInit = async (cwd, { name, version, ...rest }, { e2e, pnp, local, registry }) => {
  const options = {
    name,
    version,
    appName: path10.basename(cwd),
    creationPath: path10.join(cwd, ".."),
    cwd,
    e2e,
    pnp,
    ...rest
  };
  logger16.log();
  logger16.info(`\u{1F3C3} Starting for ${name} ${version}`);
  logger16.log();
  await doTask(generate, { ...options, cwd: options.creationPath });
  await doTask(addAdditionalFiles, { ...options, cwd }, !!options.additionalFiles);
  if (e2e) {
    await doTask(addPackageResolutions, options);
  }
  if (local) {
    await doTask(addLocalPackageResolutions, options);
  }
  await doTask(installYarn2, options);
  if (e2e) {
    await doTask(configureYarn2ForE2E, options, e2e);
  }
  await doTask(addTypescript, options, !!options.typescript);
  await doTask(addRequiredDeps, options);
  if (registry) {
    await registryUrlNPM(registry);
    await registryUrlYarn(registry);
  }
  await doTask(initStorybook, options);
};

// src/repro.ts
var logger17 = console;
var TEMPLATES = configs_exports;
var CURATED_TEMPLATES = Object.fromEntries(
  Object.entries(configs_exports).filter((entry) => entry[0] !== "react_in_yarn_workspace")
);
var RENDERERS = Object.values(CURATED_TEMPLATES).reduce(
  (acc, cur) => {
    acc[cur.renderer] = [...acc[cur.renderer] || [], cur];
    return acc;
  },
  {}
);
var repro = async ({
  outputDirectory,
  list,
  template,
  renderer,
  generator: generator21,
  e2e,
  local,
  registry,
  pnp
}) => {
  logger17.info(
    boxen2(
      dedent13`
        🤗 Welcome to ${chalk17.yellow("sb repro")}! 🤗 

        Create a ${chalk17.green("new project")} to minimally reproduce Storybook issues.
        
        1. select an environment that most closely matches your project setup.
        2. select a location for the reproduction, outside of your project.
        
        After the reproduction is ready, we'll guide you through the next steps.
        `.trim(),
      { borderStyle: "round", padding: 1, borderColor: "#F1618C" }
    )
  );
  if (list) {
    logger17.info("\u{1F308} Available templates");
    Object.entries(RENDERERS).forEach(([r, templates]) => {
      logger17.info(r);
      templates.forEach((t) => logger17.info(`- ${t.name}`));
      if (r === "other") {
        logger17.info("- blank");
      }
    });
    return;
  }
  let selectedTemplate = template;
  let selectedRenderer = renderer;
  if (!selectedTemplate && !generator21) {
    if (!selectedRenderer) {
      const { renderer: rendererOpt } = await prompts4({
        type: "select",
        message: "\u{1F308} Select the repro renderer",
        name: "renderer",
        choices: Object.keys(RENDERERS).map((f) => ({ title: f, value: f }))
      });
      selectedRenderer = rendererOpt;
    }
    if (!selectedRenderer) {
      throw new Error("\u{1F6A8} Repro: please select a renderer!");
    }
    selectedTemplate = (await prompts4({
      type: "select",
      message: "\u{1F4DD} Select the repro base template",
      name: "template",
      choices: RENDERERS[selectedRenderer].map((f) => ({
        title: f.name,
        value: f.name
      }))
    })).template;
  }
  const selectedConfig = !generator21 ? TEMPLATES[selectedTemplate] : {
    name: "custom",
    version: "custom",
    generator: generator21
  };
  if (!selectedConfig) {
    throw new Error("\u{1F6A8} Repro: please specify a valid template type");
  }
  let selectedDirectory = outputDirectory;
  if (!selectedDirectory) {
    const { directory } = await prompts4({
      type: "text",
      message: "Enter the output directory",
      name: "directory",
      initial: selectedConfig.name,
      validate: (directoryName) => fs7.existsSync(directoryName) ? `${directoryName} already exists. Please choose another name.` : true
    });
    selectedDirectory = directory;
  }
  try {
    const cwd = path11.isAbsolute(selectedDirectory) ? selectedDirectory : path11.join(process.cwd(), selectedDirectory);
    logger17.info(`\u{1F3C3} Running ${selectedTemplate} into ${cwd}`);
    await createAndInit(cwd, selectedConfig, {
      registry,
      e2e: !!e2e,
      pnp: !!pnp,
      local: !!local
    });
    if (!e2e) {
      await initGitRepo(cwd);
    }
    logger17.info(
      boxen2(
        dedent13`
        🎉 Your Storybook reproduction project is ready to use! 🎉

        ${chalk17.yellow(`cd ${selectedDirectory}`)}
        ${chalk17.yellow(`yarn storybook`)}

        Once you've recreated the problem you're experiencing, please:
        
        1. Document any additional steps in ${chalk17.cyan("README.md")}
        2. Publish the repository to github
        3. Link to the repro repository in your issue

        Having a clean repro helps us solve your issue faster! 🙏
      `.trim(),
        { borderStyle: "round", padding: 1, borderColor: "#F1618C" }
      )
    );
  } catch (error) {
    logger17.error("\u{1F6A8} Failed to create repro");
    throw error;
  }
};
var initGitRepo = async (cwd) => {
  await exec("git init", { cwd });
  await exec('echo "node_modules" >> .gitignore', { cwd });
  await exec("git add --all", { cwd });
  await exec('git commit -am "added storybook"', { cwd });
  await exec("git tag repro-base", { cwd });
};

// src/repro-next.ts
import prompts5 from "prompts";
import path12 from "path";
import chalk18 from "chalk";
import boxen3 from "boxen";
import { dedent as dedent14 } from "ts-dedent";
import degit from "degit";
import { existsSync as existsSync2 } from "fs-extra";

// src/repro-templates.ts
var craTemplates = {
  "cra/default-js": {
    name: "Create React App (Javascript)",
    script: "npx create-react-app .",
    cadence: ["ci", "daily", "weekly"],
    expected: {
      framework: "@storybook/cra",
      renderer: "@storybook/react",
      builder: "@storybook/builder-webpack5"
    }
  },
  "cra/default-ts": {
    name: "Create React App (Typescript)",
    script: "npx create-react-app . --template typescript",
    cadence: ["ci", "daily", "weekly"],
    skipTasks: ["smoke-test"],
    expected: {
      framework: "@storybook/cra",
      renderer: "@storybook/react",
      builder: "@storybook/builder-webpack5"
    }
  }
};
var reactViteTemplates = {
  "react-vite/default-js": {
    name: "React Vite (JS)",
    script: "yarn create vite . --template react",
    cadence: ["ci", "daily", "weekly"],
    expected: {
      framework: "@storybook/react-vite",
      renderer: "@storybook/react",
      builder: "@storybook/builder-vite"
    }
  },
  "react-vite/default-ts": {
    name: "React Vite (TS)",
    script: "yarn create vite . --template react-ts",
    cadence: ["ci", "daily", "weekly"],
    expected: {
      framework: "@storybook/react-vite",
      renderer: "@storybook/react",
      builder: "@storybook/builder-vite"
    }
  }
};
var reactWebpackTemplates = {
  "react-webpack/18-ts": {
    name: "React Webpack5 (TS)",
    script: "yarn create webpack5-react .",
    cadence: ["ci", "daily", "weekly"],
    expected: {
      framework: "@storybook/react-webpack5",
      renderer: "@storybook/react",
      builder: "@storybook/builder-webpack5"
    }
  },
  "react-webpack/17-ts": {
    name: "React Webpack5 (TS)",
    script: 'yarn create webpack5-react . --version-react="17" --version-react-dom="17"',
    cadence: ["ci", "daily", "weekly"],
    expected: {
      framework: "@storybook/react-webpack5",
      renderer: "@storybook/react",
      builder: "@storybook/builder-webpack5"
    }
  }
};
var vue3ViteTemplates = {
  "vue3-vite/default-js": {
    name: "Vue3 Vite (JS)",
    script: "yarn create vite . --template vue",
    cadence: ["ci", "daily", "weekly"],
    expected: {
      framework: "@storybook/vue3-vite",
      renderer: "@storybook/vue3",
      builder: "@storybook/builder-vite"
    }
  },
  "vue3-vite/default-ts": {
    name: "Vue3 Vite (TS)",
    script: "yarn create vite . --template vue-ts",
    cadence: ["ci", "daily", "weekly"],
    expected: {
      framework: "@storybook/vue3-vite",
      renderer: "@storybook/vue3",
      builder: "@storybook/builder-vite"
    }
  }
};
var vue2ViteTemplates = {
  "vue2-vite/2.7-js": {
    name: "Vue2 Vite (vue 2.7 JS)",
    script: `yarn create vite . --template vanilla && yarn add --dev @vitejs/plugin-vue2 vue-template-compiler vue@2 && echo "import vue2 from '@vitejs/plugin-vue2';

export default {
	plugins: [vue2()]
};" > vite.config.js`,
    cadence: ["ci", "daily", "weekly"],
    expected: {
      framework: "@storybook/vue2-vite",
      renderer: "@storybook/vue",
      builder: "@storybook/builder-vite"
    }
  }
};
var svelteViteTemplates = {
  "svelte-vite/default-js": {
    name: "Svelte Vite (JS)",
    script: "yarn create vite . --template svelte",
    cadence: ["ci", "daily", "weekly"],
    expected: {
      framework: "@storybook/svelte-vite",
      renderer: "@storybook/svelte",
      builder: "@storybook/builder-vite"
    }
  }
};
var litViteTemplates = {
  "lit-vite/default-js": {
    name: "Lit Vite (JS)",
    script: "yarn create vite . --template lit",
    cadence: [],
    expected: {
      framework: "@storybook/web-components-vite",
      renderer: "@storybook/web-components",
      builder: "@storybook/builder-vite"
    }
  },
  "lit-vite/default-ts": {
    name: "Lit Vite (TS)",
    script: "yarn create vite . --template lit-ts",
    cadence: [],
    expected: {
      framework: "@storybook/web-components-vite",
      renderer: "@storybook/web-components",
      builder: "@storybook/builder-vite"
    }
  }
};
var vueCliTemplates = {
  "vue-cli/default-js": {
    name: "Vue-CLI (Default JS)",
    script: "npx -p @vue/cli vue create . --default --packageManager=yarn --force --merge",
    cadence: ["ci", "daily", "weekly"],
    expected: {
      framework: "@storybook/vue3-webpack5",
      renderer: "@storybook/vue3",
      builder: "@storybook/builder-webpack5"
    }
  },
  "vue-cli/vue2-default-js": {
    name: "Vue-CLI (Vue2 JS)",
    script: "npx -p @vue/cli vue create . --default --packageManager=yarn --force --merge --preset=Default\\ (Vue\\ 2)",
    cadence: ["ci", "daily", "weekly"],
    expected: {
      framework: "@storybook/vue-webpack5",
      renderer: "@storybook/vue",
      builder: "@storybook/builder-webpack5"
    }
  }
};
var repro_templates_default = {
  ...craTemplates,
  ...reactWebpackTemplates,
  ...reactViteTemplates,
  ...vue2ViteTemplates,
  ...vue3ViteTemplates,
  ...svelteViteTemplates,
  ...litViteTemplates,
  ...vueCliTemplates
};

// src/repro-next.ts
var logger18 = console;
var toChoices = (c) => ({ title: repro_templates_default[c].name, value: c });
var reproNext = async ({
  output: outputDirectory,
  filterValue,
  branch,
  init
}) => {
  const keys = Object.keys(repro_templates_default);
  const choices = keys.reduce((acc, group) => {
    const current = repro_templates_default[group];
    const filterRegex = new RegExp(filterValue, "i");
    if (!filterValue) {
      acc.push(group);
      return acc;
    }
    if (current.name.match(filterRegex) || group.match(filterRegex) || current.expected.builder.match(filterRegex) || current.expected.framework.match(filterRegex) || current.expected.renderer.match(filterRegex)) {
      acc.push(group);
      return acc;
    }
    return acc;
  }, []);
  if (choices.length === 0) {
    logger18.info(
      boxen3(
        dedent14`
          🔎 You filtered out all templates. 🔍
          
          After filtering all the templates with "${chalk18.yellow(
          filterValue
        )}", we found no results. Please try again with a different filter.

          Available templates:
          ${keys.map((key) => chalk18.blue`- ${key}`).join("\n")}
          `.trim(),
        { borderStyle: "round", padding: 1, borderColor: "#F1618C" }
      )
    );
    process.exit(1);
  }
  let selectedTemplate = null;
  if (choices.length === 1) {
    [selectedTemplate] = choices;
  } else {
    logger18.info(
      boxen3(
        dedent14`
          🤗 Welcome to ${chalk18.yellow("sb repro NEXT")}! 🤗 
  
          Create a ${chalk18.green("new project")} to minimally reproduce Storybook issues.
          
          1. select an environment that most closely matches your project setup.
          2. select a location for the reproduction, outside of your project.
          
          After the reproduction is ready, we'll guide you through the next steps.
          `.trim(),
        { borderStyle: "round", padding: 1, borderColor: "#F1618C" }
      )
    );
    selectedTemplate = await promptSelectedTemplate(choices);
  }
  const hasSelectedTemplate = !!(selectedTemplate ?? null);
  if (!hasSelectedTemplate) {
    logger18.error("Somehow we got no templates. Please rerun this command!");
    return;
  }
  const selectedConfig = repro_templates_default[selectedTemplate];
  if (!selectedConfig) {
    throw new Error("\u{1F6A8} Repro: please specify a valid template type");
  }
  let selectedDirectory = outputDirectory;
  const outputDirectoryName = outputDirectory || selectedTemplate;
  if (selectedDirectory && existsSync2(`${selectedDirectory}`)) {
    logger18.info(`\u26A0\uFE0F  ${selectedDirectory} already exists! Overwriting...`);
  }
  if (!selectedDirectory) {
    const { directory } = await prompts5({
      type: "text",
      message: "Enter the output directory",
      name: "directory",
      initial: outputDirectoryName,
      validate: async (directoryName) => existsSync2(directoryName) ? `${directoryName} already exists. Please choose another name.` : true
    });
    selectedDirectory = directory;
  }
  try {
    const templateDestination = path12.isAbsolute(selectedDirectory) ? selectedDirectory : path12.join(process.cwd(), selectedDirectory);
    logger18.info(`\u{1F3C3} Adding ${selectedConfig.name} into ${templateDestination}`);
    logger18.log("\u{1F4E6} Downloading repro template...");
    try {
      const templateType = init ? "after-storybook" : "before-storybook";
      await degit(
        `storybookjs/repro-templates-temp/${selectedTemplate}/${templateType}#${branch}`,
        {
          force: true
        }
      ).clone(templateDestination);
    } catch (err) {
      logger18.error(`\u{1F6A8} Failed to download repro template: ${err.message}`);
      throw err;
    }
    const initMessage = init ? chalk18.yellow(`yarn storybook`) : `Recreate your setup, then ${chalk18.yellow(`run npx storybook init`)}`;
    logger18.info(
      boxen3(
        dedent14`
        🎉 Your Storybook reproduction project is ready to use! 🎉

        ${chalk18.yellow(`cd ${selectedDirectory}`)}
        ${initMessage}

        Once you've recreated the problem you're experiencing, please:
        
        1. Document any additional steps in ${chalk18.cyan("README.md")}
        2. Publish the repository to github
        3. Link to the repro repository in your issue

        Having a clean repro helps us solve your issue faster! 🙏
      `.trim(),
        { borderStyle: "round", padding: 1, borderColor: "#F1618C" }
      )
    );
  } catch (error) {
    logger18.error("\u{1F6A8} Failed to create repro");
    throw error;
  }
};
async function promptSelectedTemplate(choices) {
  const { template } = await prompts5({
    type: "select",
    message: "\u{1F308} Select the template",
    name: "template",
    choices: choices.map(toChoices)
  });
  return template || null;
}

// src/link.ts
import fse6 from "fs-extra";
import path13 from "path";
import { sync as spawnSync5 } from "cross-spawn";
import { logger as logger19 } from "@storybook/node-logger";
var link = async ({ target, local, start }) => {
  const storybookDir = process.cwd();
  try {
    const packageJson = JSON.parse(fse6.readFileSync("package.json", "utf8"));
    if (packageJson.name !== "@storybook/root")
      throw new Error();
  } catch {
    throw new Error("Expected to run link from the root of the storybook monorepo");
  }
  let reproDir = target;
  let reproName = path13.basename(target);
  if (!local) {
    const reprosDir = path13.join(storybookDir, "../storybook-repros");
    logger19.info(`Ensuring directory ${reprosDir}`);
    fse6.ensureDirSync(reprosDir);
    logger19.info(`Cloning ${target}`);
    await exec(`git clone ${target}`, { cwd: reprosDir });
    reproName = path13.basename(target, path13.extname(target));
    reproDir = path13.join(reprosDir, reproName);
  }
  const version = spawnSync5("yarn", ["--version"], {
    cwd: reproDir,
    stdio: "pipe",
    shell: true
  }).stdout.toString();
  if (!/^[23]\./.test(version)) {
    logger19.warn(`\u{1F6A8} Expected yarn 2 or 3 in ${reproDir}!`);
    logger19.warn("");
    logger19.warn("Please set it up with `yarn set version berry`,");
    logger19.warn(`then link '${reproDir}' with the '--local' flag.`);
    return;
  }
  logger19.info(`Linking ${reproDir}`);
  await exec(`yarn link --all ${storybookDir}`, { cwd: reproDir });
  logger19.info(`Installing ${reproName}`);
  await exec(`yarn install`, { cwd: reproDir });
  logger19.info(
    `Magic stuff related to @storybook/preset-create-react-app, we need to fix peerDependencies`
  );
  await exec(`yarn add -D webpack-hot-middleware`, { cwd: reproDir });
  if (start) {
    logger19.info(`Running ${reproName} storybook`);
    await exec(`yarn run storybook`, { cwd: reproDir });
  }
};

// src/dev.ts
import { dedent as dedent15 } from "ts-dedent";
import { sync as readUpSync } from "read-pkg-up";
import { logger as logger20, instance as npmLog } from "@storybook/node-logger";
import { buildDevStandalone } from "@storybook/core-server";
import { cache } from "@storybook/core-common";
var dev = async (cliOptions) => {
  "development" = "development";
  try {
    await buildDevStandalone({
      ...cliOptions,
      configDir: cliOptions.configDir || "./.storybook",
      configType: "DEVELOPMENT",
      ignorePreview: !!cliOptions.previewUrl && !cliOptions.forceBuildPreview,
      docsMode: !!cliOptions.docs,
      cache,
      packageJson: readUpSync({ cwd: __dirname }).packageJson
    });
  } catch (error) {
    npmLog.heading = "";
    if (error instanceof Error) {
      if (error.error) {
        logger20.error(error.error);
      } else if (error.stats && error.stats.compilation.errors) {
        error.stats.compilation.errors.forEach((e) => logger20.plain(e));
      } else {
        logger20.error(error);
      }
    } else if (error.compilation?.errors) {
      error.compilation.errors.forEach((e) => logger20.plain(e));
    }
    logger20.line();
    logger20.warn(
      error.close ? dedent15`
          FATAL broken build!, will close the process,
          Fix the error below and restart storybook.
        ` : dedent15`
          Broken build, fix the error above.
          You may need to refresh the browser.
        `
    );
    logger20.line();
    process.exit(1);
  }
};

// src/build.ts
import { sync as readUpSync2 } from "read-pkg-up";
import { logger as logger21 } from "@storybook/node-logger";
import { buildStaticStandalone } from "@storybook/core-server";
import { cache as cache2 } from "@storybook/core-common";
var build = async (cliOptions) => {
  try {
    await buildStaticStandalone({
      ...cliOptions,
      configDir: cliOptions.configDir || "./.storybook",
      outputDir: cliOptions.outputDir || "./storybook-static",
      ignorePreview: !!cliOptions.previewUrl && !cliOptions.forceBuildPreview,
      docsMode: !!cliOptions.docs,
      configType: "PRODUCTION",
      cache: cache2,
      packageJson: readUpSync2({ cwd: __dirname }).packageJson
    });
  } catch (e) {
    logger21.error(e);
    process.exit(1);
  }
};

// src/utils.ts
function parseList(str) {
  return str.split(",").map((item) => item.trim()).filter((item) => item.length > 0);
}
function getEnvConfig(program2, configEnv) {
  Object.keys(configEnv).forEach((fieldName) => {
    const envVarName = configEnv[fieldName];
    const envVarValue = define_process_env_default[envVarName];
    if (envVarValue) {
      program2[fieldName] = envVarValue;
    }
  });
}

// src/generate.ts
var pkg = readUpSync3({ cwd: __dirname }).packageJson;
var consoleLogger = console;
program.option(
  "--disable-telemetry",
  "disable sending telemetry data",
  define_process_env_default.STORYBOOK_DISABLE_TELEMETRY && define_process_env_default.STORYBOOK_DISABLE_TELEMETRY !== "false"
);
program.option("--enable-crash-reports", "enable sending crash reports to telemetry data");
program.command("init").description("Initialize Storybook into your project.").option("-f --force", "Force add Storybook").option("-s --skip-install", "Skip installing deps").option("-N --use-npm", "Use npm to install deps").option("--use-pnp", "Enable pnp mode").option("-p --parser <babel | babylon | flow | ts | tsx>", "jscodeshift parser").option("-t --type <type>", "Add Storybook for a specific project type").option("-y --yes", "Answer yes to all prompts").option("-b --builder <builder>", "Builder library").option("-l --linkable", "Prepare installation for link (contributor helper)").action(
  (options) => initiate(options, pkg).catch((err) => {
    logger22.error(err);
    process.exit(1);
  })
);
program.command("add <addon>").description("Add an addon to your Storybook").option("-N --use-npm", "Use NPM to build the Storybook server").option("-s --skip-postinstall", "Skip package specific postinstall config modifications").action((addonName, options) => add(addonName, options));
program.command("babelrc").description("generate the default storybook babel config into your current working directory").action(() => generateStorybookBabelConfigInCWD());
program.command("upgrade").description("Upgrade your Storybook packages to the latest").option("-N --use-npm", "Use NPM to build the Storybook server").option("-y --yes", "Skip prompting the user").option("-n --dry-run", "Only check for upgrades, do not install").option("-p --prerelease", "Upgrade to the pre-release packages").option("-s --skip-check", "Skip postinstall version and automigration checks").action((options) => upgrade(options));
program.command("info").description("Prints debugging information about the local environment").action(() => {
  consoleLogger.log(chalk19.bold("\nEnvironment Info:"));
  envinfo.run({
    System: ["OS", "CPU"],
    Binaries: ["Node", "Yarn", "npm"],
    Browsers: ["Chrome", "Edge", "Firefox", "Safari"],
    npmPackages: "@storybook/*",
    npmGlobalPackages: "@storybook/*"
  }).then(consoleLogger.log);
});
program.command("migrate [migration]").description("Run a Storybook codemod migration on your source files").option("-l --list", "List available migrations").option("-g --glob <glob>", "Glob for files upon which to apply the migration", "**/*.js").option("-p --parser <babel | babylon | flow | ts | tsx>", "jscodeshift parser").option(
  "-n --dry-run",
  "Dry run: verify the migration exists and show the files to which it will be applied"
).option(
  "-r --rename <from-to>",
  'Rename suffix of matching files after codemod has been applied, e.g. ".js:.ts"'
).action((migration, { configDir, glob, dryRun, list, rename, parser }) => {
  migrate(migration, {
    configDir,
    glob,
    dryRun,
    list,
    rename,
    parser,
    logger: consoleLogger
  }).catch((err) => {
    logger22.error(err);
    process.exit(1);
  });
});
program.command("extract [location] [output]").description("extract stories.json from a built version").action(
  (location = "storybook-static", output = path14.join(location, "stories.json")) => extract(location, output).catch((e) => {
    logger22.error(e);
    process.exit(1);
  })
);
program.command("repro [outputDirectory]").description("Create a reproduction from a set of possible templates").option("-f --renderer <renderer>", "Filter on given renderer").option("-t --template <template>", "Use the given template").option("-l --list", "List available templates").option("-g --generator <generator>", "Use custom generator command").option("--registry <registry>", "which registry to use for storybook packages").option("--pnp", "Use Yarn Plug'n'Play mode instead of node_modules one").option("--local", "use storybook's local packages instead of yarn's registry").option("--e2e", "Used in e2e context").action(
  (outputDirectory, { renderer, template, list, e2e, generator: generator21, pnp, local }) => repro({ outputDirectory, renderer, template, list, e2e, local, generator: generator21, pnp }).catch((e) => {
    logger22.error(e);
    process.exit(1);
  })
);
program.command("repro-next [filterValue]").description("Create a reproduction from a set of possible templates").option("-o --output <outDir>", "Define an output directory").option("-b --branch <branch>", "Define the branch to degit from", "next").option("--no-init", "Whether to download a template without an initialized Storybook", false).action(
  (filterValue, options) => reproNext({ filterValue, ...options }).catch((e) => {
    logger22.error(e);
    process.exit(1);
  })
);
program.command("link <repo-url-or-directory>").description("Pull down a repro from a URL (or a local directory), link it, and run storybook").option("--local", "Link a local directory already in your file system").option("--no-start", "Start the storybook", true).action(
  (target, { local, start }) => link({ target, local, start }).catch((e) => {
    logger22.error(e);
    process.exit(1);
  })
);
program.command("automigrate [fixId]").description("Check storybook for known problems or migrations and apply fixes").option("-y --yes", "Skip prompting the user").option("-n --dry-run", "Only check for fixes, do not actually run them").action(
  (fixId, options) => automigrate({ fixId, ...options }).catch((e) => {
    logger22.error(e);
    process.exit(1);
  })
);
program.command("dev").option("-p, --port <number>", "Port to run Storybook", (str) => parseInt(str, 10)).option("-h, --host <string>", "Host to run Storybook").option("-s, --static-dir <dir-names>", "Directory where to load static files from", parseList).option("-c, --config-dir <dir-name>", "Directory where to load Storybook configurations from").option(
  "--https",
  "Serve Storybook over HTTPS. Note: You must provide your own certificate information."
).option(
  "--ssl-ca <ca>",
  "Provide an SSL certificate authority. (Optional with --https, required if using a self-signed certificate)",
  parseList
).option("--ssl-cert <cert>", "Provide an SSL certificate. (Required with --https)").option("--ssl-key <key>", "Provide an SSL key. (Required with --https)").option("--smoke-test", "Exit after successful start").option("--ci", "CI mode (skip interactive prompts, don't open browser)").option("--no-open", "Do not open Storybook automatically in the browser").option("--loglevel <level>", "Control level of logging during build").option("--quiet", "Suppress verbose build output").option("--no-version-updates", "Suppress update check", true).option(
  "--no-release-notes",
  "Suppress automatic redirects to the release notes after upgrading",
  true
).option("--no-manager-cache", "Do not cache the manager UI").option("--debug-webpack", "Display final webpack configurations for debugging purposes").option("--webpack-stats-json [directory]", "Write Webpack Stats JSON to disk").option(
  "--preview-url <string>",
  "Disables the default storybook preview and lets your use your own"
).option("--force-build-preview", "Build the preview iframe even if you are using --preview-url").option("--docs", "Build a documentation-only site using addon-docs").action((options) => {
  logger22.setLevel(program.loglevel);
  consoleLogger.log(chalk19.bold(`${pkg.name} v${pkg.version}`) + chalk19.reset("\n"));
  getEnvConfig(program, {
    port: "SBCONFIG_PORT",
    host: "SBCONFIG_HOSTNAME",
    staticDir: "SBCONFIG_STATIC_DIR",
    configDir: "SBCONFIG_CONFIG_DIR",
    ci: "CI"
  });
  if (typeof program.port === "string" && program.port.length > 0) {
    program.port = parseInt(program.port, 10);
  }
  dev({ ...options, packageJson: pkg });
});
program.command("build").option("-s, --static-dir <dir-names>", "Directory where to load static files from", parseList).option("-o, --output-dir <dir-name>", "Directory where to store built files").option("-c, --config-dir <dir-name>", "Directory where to load Storybook configurations from").option("--quiet", "Suppress verbose build output").option("--loglevel <level>", "Control level of logging during build").option("--debug-webpack", "Display final webpack configurations for debugging purposes").option("--webpack-stats-json [directory]", "Write Webpack Stats JSON to disk").option(
  "--preview-url <string>",
  "Disables the default storybook preview and lets your use your own"
).option("--force-build-preview", "Build the preview iframe even if you are using --preview-url").option("--docs", "Build a documentation-only site using addon-docs").option("--no-manager-cache", "Do not cache the manager UI").action((options) => {
  "development" = "development";
  logger22.setLevel(program.loglevel);
  consoleLogger.log(chalk19.bold(`${pkg.name} v${pkg.version}
`));
  getEnvConfig(program, {
    staticDir: "SBCONFIG_STATIC_DIR",
    outputDir: "SBCONFIG_OUTPUT_DIR",
    configDir: "SBCONFIG_CONFIG_DIR"
  });
  build({ ...options, packageJson: pkg });
});
program.on("command:*", ([invalidCmd]) => {
  consoleLogger.error(
    " Invalid command: %s.\n See --help for a list of available commands.",
    invalidCmd
  );
  const availableCommands = program.commands.map((cmd) => cmd._name);
  const suggestion = availableCommands.find((cmd) => leven(cmd, invalidCmd) < 3);
  if (suggestion) {
    consoleLogger.info(`
 Did you mean ${suggestion}?`);
  }
  process.exit(1);
});
program.usage("<command> [options]").version(pkg.version).parse(process.argv);
