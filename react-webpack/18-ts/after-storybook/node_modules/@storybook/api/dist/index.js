var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.tsx
var src_exports = {};
__export(src_exports, {
  ActiveTabs: () => ActiveTabs2,
  Consumer: () => ManagerConsumer,
  ManagerContext: () => ManagerContext,
  Provider: () => ManagerProvider,
  combineParameters: () => combineParameters,
  merge: () => merge_default,
  useAddonState: () => useAddonState,
  useArgTypes: () => useArgTypes,
  useArgs: () => useArgs,
  useChannel: () => useChannel,
  useGlobalTypes: () => useGlobalTypes,
  useGlobals: () => useGlobals,
  useParameter: () => useParameter,
  useSharedState: () => useSharedState,
  useStoryPrepared: () => useStoryPrepared,
  useStorybookApi: () => useStorybookApi,
  useStorybookState: () => useStorybookState
});
module.exports = __toCommonJS(src_exports);
var import_react2 = __toESM(require("react"));
var import_mergeWith2 = __toESM(require("lodash/mergeWith"));
var import_core_events7 = require("@storybook/core-events");

// src/context.ts
var import_react = require("react");
var createContext = ({ api, state }) => (0, import_react.createContext)({ api, state });

// src/store.ts
var import_store2 = __toESM(require("store2"));

// src/lib/store-setup.ts
var import_telejson = require("telejson");
var store_setup_default = (_) => {
  _.fn("set", function(key, data) {
    return _.set(this._area, this._in(key), (0, import_telejson.stringify)(data, { maxDepth: 50 }));
  });
  _.fn("get", function(key, alt) {
    const value = _.get(this._area, this._in(key));
    return value !== null ? (0, import_telejson.parse)(value) : alt || value;
  });
};

// src/store.ts
store_setup_default(import_store2.default._);
var STORAGE_KEY = "@storybook/ui/store";
function get(storage) {
  const data = storage.get(STORAGE_KEY);
  return data || {};
}
function set(storage, value) {
  return storage.set(STORAGE_KEY, value);
}
function update(storage, patch) {
  const previous = get(storage);
  return set(storage, { ...previous, ...patch });
}
var Store = class {
  constructor({ setState, getState }) {
    this.upstreamSetState = setState;
    this.upstreamGetState = getState;
  }
  getInitialState(base) {
    return { ...base, ...get(import_store2.default.local), ...get(import_store2.default.session) };
  }
  getState() {
    return this.upstreamGetState();
  }
  async setState(inputPatch, cbOrOptions, inputOptions) {
    let callback;
    let options;
    if (typeof cbOrOptions === "function") {
      callback = cbOrOptions;
      options = inputOptions;
    } else {
      options = cbOrOptions;
    }
    const { persistence = "none" } = options || {};
    let patch = {};
    let delta = {};
    if (typeof inputPatch === "function") {
      patch = (state) => {
        const getDelta = inputPatch;
        delta = getDelta(state);
        return delta;
      };
    } else {
      patch = inputPatch;
      delta = patch;
    }
    const newState = await new Promise((resolve) => {
      this.upstreamSetState(patch, resolve);
    });
    if (persistence !== "none") {
      const storage = persistence === "session" ? import_store2.default.session : import_store2.default.local;
      await update(storage, delta);
    }
    if (callback) {
      callback(newState);
    }
    return newState;
  }
};

// src/lib/merge.ts
var import_mergeWith = __toESM(require("lodash/mergeWith"));
var import_isEqual = __toESM(require("lodash/isEqual"));
var import_client_logger = require("@storybook/client-logger");
var merge_default = (a, b) => (0, import_mergeWith.default)({}, a, b, (objValue, srcValue) => {
  if (Array.isArray(srcValue) && Array.isArray(objValue)) {
    srcValue.forEach((s) => {
      const existing = objValue.find((o) => o === s || (0, import_isEqual.default)(o, s));
      if (!existing) {
        objValue.push(s);
      }
    });
    return objValue;
  }
  if (Array.isArray(objValue)) {
    import_client_logger.logger.log(["the types mismatch, picking", objValue]);
    return objValue;
  }
  return void 0;
});

// src/initial-state.ts
var main = (...additions) => additions.reduce((acc, item) => merge_default(acc, item), {});
var initial_state_default = main;

// src/modules/provider.ts
var provider_exports = {};
__export(provider_exports, {
  init: () => init
});
var init = ({ provider, fullAPI }) => {
  return {
    api: provider.renderPreview ? { renderPreview: provider.renderPreview } : {},
    state: {},
    init: () => {
      provider.handleAPI(fullAPI);
    }
  };
};

// src/modules/addons.ts
var addons_exports = {};
__export(addons_exports, {
  ensurePanel: () => ensurePanel,
  init: () => init2,
  types: () => types
});
var import_util_deprecate = __toESM(require("util-deprecate"));
var import_ts_dedent = require("ts-dedent");
var warnDisabledDeprecated = (0, import_util_deprecate.default)(
  () => {
  },
  import_ts_dedent.dedent`
    Use 'parameters.key.disable' instead of 'parameters.key.disabled'.
    
    https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-disabled-parameter
  `
);
var types = /* @__PURE__ */ ((types2) => {
  types2["TAB"] = "tab";
  types2["PANEL"] = "panel";
  types2["TOOL"] = "tool";
  types2["PREVIEW"] = "preview";
  types2["NOTES_ELEMENT"] = "notes-element";
  return types2;
})(types || {});
function ensurePanel(panels, selectedPanel, currentPanel) {
  const keys2 = Object.keys(panels);
  if (keys2.indexOf(selectedPanel) >= 0) {
    return selectedPanel;
  }
  if (keys2.length) {
    return keys2[0];
  }
  return currentPanel;
}
var init2 = ({ provider, store: store2, fullAPI }) => {
  const api = {
    getElements: (type) => provider.getElements(type),
    getPanels: () => api.getElements("panel" /* PANEL */),
    getStoryPanels: () => {
      const allPanels = api.getPanels();
      const { storyId } = store2.getState();
      const story = fullAPI.getData(storyId);
      if (!allPanels || !story || story.type !== "story") {
        return allPanels;
      }
      const { parameters } = story;
      const filteredPanels = {};
      Object.entries(allPanels).forEach(([id, panel]) => {
        const { paramKey } = panel;
        if (paramKey && parameters && parameters[paramKey] && (parameters[paramKey].disabled || parameters[paramKey].disable)) {
          if (parameters[paramKey].disabled) {
            warnDisabledDeprecated();
          }
          return;
        }
        filteredPanels[id] = panel;
      });
      return filteredPanels;
    },
    getSelectedPanel: () => {
      const { selectedPanel } = store2.getState();
      return ensurePanel(api.getPanels(), selectedPanel, selectedPanel);
    },
    setSelectedPanel: (panelName) => {
      store2.setState({ selectedPanel: panelName }, { persistence: "session" });
    },
    setAddonState(addonId, newStateOrMerger, options) {
      let nextState;
      const { addons: existing } = store2.getState();
      if (typeof newStateOrMerger === "function") {
        const merger = newStateOrMerger;
        nextState = merger(api.getAddonState(addonId));
      } else {
        nextState = newStateOrMerger;
      }
      return store2.setState({ addons: { ...existing, [addonId]: nextState } }, options).then(() => api.getAddonState(addonId));
    },
    getAddonState: (addonId) => {
      return store2.getState().addons[addonId];
    }
  };
  return {
    api,
    state: {
      selectedPanel: ensurePanel(api.getPanels(), store2.getState().selectedPanel),
      addons: {}
    }
  };
};

// src/modules/channel.ts
var channel_exports = {};
__export(channel_exports, {
  init: () => init3
});
var import_core_events = require("@storybook/core-events");
var init3 = ({ provider }) => {
  const api = {
    getChannel: () => provider.channel,
    on: (type, cb) => {
      provider.channel.addListener(type, cb);
      return () => provider.channel.removeListener(type, cb);
    },
    off: (type, cb) => provider.channel.removeListener(type, cb),
    once: (type, cb) => provider.channel.once(type, cb),
    emit: (type, data, ...args) => {
      var _a;
      if (((_a = data == null ? void 0 : data.options) == null ? void 0 : _a.target) && data.options.target !== "storybook-preview-iframe" && !data.options.target.startsWith("storybook-ref-")) {
        data.options.target = data.options.target !== "storybook_internal" ? `storybook-ref-${data.options.target}` : "storybook-preview-iframe";
      }
      provider.channel.emit(type, data, ...args);
    },
    collapseAll: () => {
      provider.channel.emit(import_core_events.STORIES_COLLAPSE_ALL, {});
    },
    expandAll: () => {
      api.emit(import_core_events.STORIES_EXPAND_ALL);
    }
  };
  return { api, state: {} };
};

// src/modules/notifications.ts
var notifications_exports = {};
__export(notifications_exports, {
  init: () => init4
});
var init4 = ({ store: store2 }) => {
  const api = {
    addNotification: (notification) => {
      api.clearNotification(notification.id);
      const { notifications } = store2.getState();
      store2.setState({ notifications: [...notifications, notification] });
    },
    clearNotification: (id) => {
      const { notifications } = store2.getState();
      store2.setState({ notifications: notifications.filter((n) => n.id !== id) });
      const notification = notifications.find((n) => n.id === id);
      if (notification && notification.onClear) {
        notification.onClear();
      }
    }
  };
  const state = { notifications: [] };
  return { api, state };
};

// src/modules/settings.ts
var settings_exports = {};
__export(settings_exports, {
  init: () => init5
});
var init5 = ({ store: store2, navigate, fullAPI }) => {
  const isSettingsScreenActive = () => {
    const { path } = fullAPI.getUrlState();
    return !!(path || "").match(/^\/settings/);
  };
  const api = {
    closeSettings: () => {
      const {
        settings: { lastTrackedStoryId }
      } = store2.getState();
      if (lastTrackedStoryId) {
        fullAPI.selectStory(lastTrackedStoryId);
      } else {
        fullAPI.selectFirstStory();
      }
    },
    changeSettingsTab: (tab) => {
      navigate(`/settings/${tab}`);
    },
    isSettingsScreenActive,
    navigateToSettingsPage: async (path) => {
      if (!isSettingsScreenActive()) {
        const { settings, storyId } = store2.getState();
        await store2.setState({
          settings: { ...settings, lastTrackedStoryId: storyId }
        });
      }
      navigate(path);
    }
  };
  return { state: { settings: { lastTrackedStoryId: null } }, api };
};

// src/modules/release-notes.ts
var release_notes_exports = {};
__export(release_notes_exports, {
  init: () => init6
});
var import_global = __toESM(require("global"));
var import_memoizerific = __toESM(require("memoizerific"));
var { RELEASE_NOTES_DATA } = import_global.default;
var getReleaseNotesData = (0, import_memoizerific.default)(1)(() => {
  try {
    return { ...JSON.parse(RELEASE_NOTES_DATA) || {} };
  } catch (e) {
    return {};
  }
});
var init6 = ({ store: store2 }) => {
  const releaseNotesData = getReleaseNotesData();
  const getReleaseNotesViewed = () => {
    const { releaseNotesViewed: persistedReleaseNotesViewed } = store2.getState();
    return persistedReleaseNotesViewed || [];
  };
  const api = {
    releaseNotesVersion: () => releaseNotesData.currentVersion,
    setDidViewReleaseNotes: () => {
      const releaseNotesViewed = getReleaseNotesViewed();
      if (!releaseNotesViewed.includes(releaseNotesData.currentVersion)) {
        store2.setState(
          { releaseNotesViewed: [...releaseNotesViewed, releaseNotesData.currentVersion] },
          { persistence: "permanent" }
        );
      }
    },
    showReleaseNotesOnLaunch: () => {
      if (!releaseNotesData.currentVersion)
        return false;
      const releaseNotesViewed = getReleaseNotesViewed();
      const didViewReleaseNotes = releaseNotesViewed.includes(releaseNotesData.currentVersion);
      const showReleaseNotesOnLaunch = releaseNotesData.showOnFirstLaunch && !didViewReleaseNotes;
      return showReleaseNotesOnLaunch;
    }
  };
  return { state: { releaseNotesViewed: [] }, api };
};

// src/modules/stories.ts
var stories_exports = {};
__export(stories_exports, {
  init: () => init8
});
var import_global4 = __toESM(require("global"));
var import_csf2 = require("@storybook/csf");
var import_core_events2 = require("@storybook/core-events");
var import_util_deprecate3 = __toESM(require("util-deprecate"));
var import_client_logger3 = require("@storybook/client-logger");

// src/lib/events.ts
var import_client_logger2 = require("@storybook/client-logger");

// src/modules/refs.ts
var refs_exports = {};
__export(refs_exports, {
  defaultStoryMapper: () => defaultStoryMapper,
  getSourceType: () => getSourceType,
  init: () => init7
});
var import_global3 = __toESM(require("global"));
var import_ts_dedent3 = require("ts-dedent");

// src/lib/stories.ts
var import_memoizerific2 = __toESM(require("memoizerific"));
var import_util_deprecate2 = __toESM(require("util-deprecate"));
var import_ts_dedent2 = require("ts-dedent");
var import_mapValues = __toESM(require("lodash/mapValues"));
var import_countBy = __toESM(require("lodash/countBy"));
var import_global2 = __toESM(require("global"));
var import_csf = require("@storybook/csf");
var { FEATURES } = import_global2.default;
var warnLegacyShowRoots = (0, import_util_deprecate2.default)(
  () => {
  },
  import_ts_dedent2.dedent`
    The 'showRoots' config option is deprecated and will be removed in Storybook 7.0. Use 'sidebar.showRoots' instead.
    Read more about it in the migration guide: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md
  `
);
var warnChangedDefaultHierarchySeparators = (0, import_util_deprecate2.default)(
  () => {
  },
  import_ts_dedent2.dedent`
    The default hierarchy separators changed in Storybook 6.0.
    '|' and '.' will no longer create a hierarchy, but codemods are available.
    Read more about it in the migration guide: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md
  `
);
var denormalizeStoryParameters = ({
  globalParameters,
  kindParameters,
  stories
}) => {
  return (0, import_mapValues.default)(stories, (storyData) => ({
    ...storyData,
    parameters: combineParameters(
      globalParameters,
      kindParameters[storyData.kind],
      storyData.parameters
    )
  }));
};
var TITLE_PATH_SEPARATOR = /\s*\/\s*/;
var transformSetStoriesStoryDataToStoriesHash = (data, { provider, docsOptions }) => transformStoryIndexToStoriesHash(
  transformSetStoriesStoryDataToPreparedStoryIndex(data, { docsOptions }),
  {
    provider,
    docsOptions
  }
);
var transformSetStoriesStoryDataToPreparedStoryIndex = (stories, { docsOptions }) => {
  const seenTitles = /* @__PURE__ */ new Set();
  const entries = Object.entries(stories).reduce(
    (acc, [id, story]) => {
      if (!story)
        return acc;
      const { docsOnly, fileName, ...parameters } = story.parameters;
      const base = {
        title: story.kind,
        id,
        name: story.name,
        importPath: fileName
      };
      if (docsOnly) {
        acc[id] = {
          type: "docs",
          storiesImports: [],
          ...base
        };
      } else {
        if (!seenTitles.has(base.title) && docsOptions.docsPage) {
          const name = docsOptions.defaultName;
          const docsId = (0, import_csf.toId)(story.componentId || base.title, name);
          seenTitles.add(base.title);
          acc[docsId] = {
            type: "docs",
            storiesImports: [],
            ...base,
            id: docsId,
            name
          };
        }
        const { argTypes, args, initialArgs } = story;
        acc[id] = {
          type: "story",
          ...base,
          parameters,
          argTypes,
          args,
          initialArgs
        };
      }
      return acc;
    },
    {}
  );
  return { v: 4, entries };
};
var transformStoryIndexV3toV4 = (index) => {
  const countByTitle = (0, import_countBy.default)(Object.values(index.stories), "title");
  return {
    v: 4,
    entries: Object.values(index.stories).reduce((acc, entry) => {
      var _a;
      let type = "story";
      if (((_a = entry.parameters) == null ? void 0 : _a.docsOnly) || entry.name === "Page" && countByTitle[entry.title] === 1) {
        type = "docs";
      }
      acc[entry.id] = {
        type,
        ...type === "docs" && { storiesImports: [] },
        ...entry
      };
      return acc;
    }, {})
  };
};
var transformStoryIndexToStoriesHash = (index, {
  provider,
  docsOptions
}) => {
  if (!index.v)
    throw new Error("Composition: Missing stories.json version");
  const v4Index = index.v === 4 ? index : transformStoryIndexV3toV4(index);
  const entryValues = Object.values(v4Index.entries);
  const { sidebar = {}, showRoots: deprecatedShowRoots } = provider.getConfig();
  const { showRoots = deprecatedShowRoots, collapsedRoots = [], renderLabel } = sidebar;
  const usesOldHierarchySeparator = entryValues.some(({ title }) => title.match(/\.|\|/));
  if (typeof deprecatedShowRoots !== "undefined") {
    warnLegacyShowRoots();
  }
  const setShowRoots = typeof showRoots !== "undefined";
  if (usesOldHierarchySeparator && !setShowRoots && (FEATURES == null ? void 0 : FEATURES.warnOnLegacyHierarchySeparator)) {
    warnChangedDefaultHierarchySeparators();
  }
  const storiesHashOutOfOrder = Object.values(entryValues).reduce((acc, item) => {
    if (docsOptions.docsMode && item.type !== "docs")
      return acc;
    const { title } = item;
    const groups = title.trim().split(TITLE_PATH_SEPARATOR);
    const root = (!setShowRoots || showRoots) && groups.length > 1 ? [groups.shift()] : [];
    const names = [...root, ...groups];
    const paths = names.reduce((list, name, idx) => {
      const parent = idx > 0 && list[idx - 1];
      const id = (0, import_csf.sanitize)(parent ? `${parent}-${name}` : name);
      if (parent === id) {
        throw new Error(
          import_ts_dedent2.dedent`
          Invalid part '${name}', leading to id === parentId ('${id}'), inside title '${title}'
          
          Did you create a path that uses the separator char accidentally, such as 'Vue <docs/>' where '/' is a separator char? See https://github.com/storybookjs/storybook/issues/6128
          `
        );
      }
      list.push(id);
      return list;
    }, []);
    paths.forEach((id, idx) => {
      const childId = paths[idx + 1] || item.id;
      if (root.length && idx === 0) {
        acc[id] = merge_default(acc[id] || {}, {
          type: "root",
          id,
          name: names[idx],
          depth: idx,
          renderLabel,
          startCollapsed: collapsedRoots.includes(id),
          children: [childId],
          isRoot: true,
          isComponent: false,
          isLeaf: false
        });
      } else if ((!acc[id] || acc[id].type === "component") && idx === paths.length - 1) {
        acc[id] = merge_default(acc[id] || {}, {
          type: "component",
          id,
          name: names[idx],
          parent: paths[idx - 1],
          depth: idx,
          renderLabel,
          ...childId && {
            children: [childId]
          },
          isRoot: false,
          isComponent: true,
          isLeaf: false
        });
      } else {
        acc[id] = merge_default(acc[id] || {}, {
          type: "group",
          id,
          name: names[idx],
          parent: paths[idx - 1],
          depth: idx,
          renderLabel,
          ...childId && {
            children: [childId]
          },
          isRoot: false,
          isComponent: false,
          isLeaf: false
        });
      }
    });
    acc[item.id] = {
      type: "story",
      ...item,
      depth: paths.length,
      parent: paths[paths.length - 1],
      renderLabel,
      ...item.type !== "docs" && { prepared: !!item.parameters },
      kind: item.title,
      isRoot: false,
      isComponent: false,
      isLeaf: true
    };
    return acc;
  }, {});
  function addItem(acc, item) {
    if (acc[item.id]) {
      return acc;
    }
    acc[item.id] = item;
    if (item.type === "root" || item.type === "group" || item.type === "component") {
      item.children.forEach((childId) => addItem(acc, storiesHashOutOfOrder[childId]));
    }
    return acc;
  }
  const orphanHash = Object.values(storiesHashOutOfOrder).filter((i) => i.type !== "root" && !i.parent).reduce(addItem, {});
  return Object.values(storiesHashOutOfOrder).filter((i) => i.type === "root").reduce(addItem, orphanHash);
};
var addPreparedStories = (newHash, oldHash) => {
  if (!oldHash)
    return newHash;
  return Object.fromEntries(
    Object.entries(newHash).map(([id, newEntry]) => {
      const oldEntry = oldHash[id];
      if (newEntry.type === "story" && (oldEntry == null ? void 0 : oldEntry.type) === "story" && oldEntry.prepared) {
        return [id, { ...oldEntry, ...newEntry, prepared: true }];
      }
      return [id, newEntry];
    })
  );
};
var getComponentLookupList = (0, import_memoizerific2.default)(1)((hash) => {
  return Object.entries(hash).reduce((acc, i) => {
    const value = i[1];
    if (value.type === "component") {
      acc.push([...value.children]);
    }
    return acc;
  }, []);
});
var getStoriesLookupList = (0, import_memoizerific2.default)(1)((hash) => {
  return Object.keys(hash).filter((k) => ["story", "docs"].includes(hash[k].type));
});

// src/modules/refs.ts
var { location, fetch } = import_global3.default;
var findFilename = /(\/((?:[^\/]+?)\.[^\/]+?)|\/)$/;
var getSourceType = (source, refId) => {
  const { origin: localOrigin, pathname: localPathname } = location;
  const { origin: sourceOrigin, pathname: sourcePathname } = new URL(source);
  const localFull = `${localOrigin + localPathname}`.replace(findFilename, "");
  const sourceFull = `${sourceOrigin + sourcePathname}`.replace(findFilename, "");
  if (localFull === sourceFull) {
    return ["local", sourceFull];
  }
  if (refId || source) {
    return ["external", sourceFull];
  }
  return [null, null];
};
var defaultStoryMapper = (b, a) => {
  return { ...a, kind: a.kind.replace("|", "/") };
};
var addRefIds = (input, ref) => {
  return Object.entries(input).reduce((acc, [id, item]) => {
    return { ...acc, [id]: { ...item, refId: ref.id } };
  }, {});
};
async function handleRequest(request) {
  if (!request)
    return {};
  try {
    const response = await request;
    if (!response.ok)
      return {};
    const json = await response.json();
    if (json.entries || json.stories) {
      return { storyIndex: json };
    }
    return json;
  } catch (error) {
    return { error };
  }
}
var map = (input, ref, options) => {
  const { storyMapper } = options;
  if (storyMapper) {
    return Object.entries(input).reduce((acc, [id, item]) => {
      return { ...acc, [id]: storyMapper(ref, item) };
    }, {});
  }
  return input;
};
var init7 = ({ store: store2, provider, singleStory, docsOptions = {} }, { runCheck = true } = {}) => {
  const api = {
    findRef: (source) => {
      const refs2 = api.getRefs();
      return Object.values(refs2).find(({ url }) => url.match(source));
    },
    changeRefVersion: (id, url) => {
      const { versions, title } = api.getRefs()[id];
      const ref = { id, url, versions, title, stories: {} };
      api.checkRef(ref);
    },
    changeRefState: (id, ready) => {
      const { [id]: ref, ...updated } = api.getRefs();
      updated[id] = { ...ref, ready };
      store2.setState({
        refs: updated
      });
    },
    checkRef: async (ref) => {
      const { id, url, version: version2, type } = ref;
      const isPublic = type === "server-checked";
      const loadedData = {};
      const query = version2 ? `?version=${version2}` : "";
      const credentials = isPublic ? "omit" : "include";
      const [indexFetch, storiesFetch] = await Promise.all(
        ["index.json", "stories.json"].map(
          async (file) => fetch(`${url}/${file}${query}`, {
            headers: { Accept: "application/json" },
            credentials
          })
        )
      );
      if (indexFetch.ok || storiesFetch.ok) {
        const [index, metadata] = await Promise.all([
          indexFetch.ok ? handleRequest(indexFetch) : handleRequest(storiesFetch),
          handleRequest(
            fetch(`${url}/metadata.json${query}`, {
              headers: {
                Accept: "application/json"
              },
              credentials,
              cache: "no-cache"
            }).catch(() => false)
          )
        ]);
        Object.assign(loadedData, { ...index, ...metadata });
      } else if (!isPublic) {
        loadedData.error = {
          message: import_ts_dedent3.dedent`
            Error: Loading of ref failed
              at fetch (lib/api/src/modules/refs.ts)

            URL: ${url}

            We weren't able to load the above URL,
            it's possible a CORS error happened.

            Please check your dev-tools network tab.
          `
        };
      }
      const versions = ref.versions && Object.keys(ref.versions).length ? ref.versions : loadedData.versions;
      await api.setRef(id, {
        id,
        url,
        ...loadedData,
        ...versions ? { versions } : {},
        type: !loadedData.storyIndex ? "auto-inject" : "lazy"
      });
    },
    getRefs: () => {
      const { refs: refs2 = {} } = store2.getState();
      return refs2;
    },
    setRef: (id, { storyIndex, setStoriesData, ...rest }, ready = false) => {
      if (singleStory) {
        return;
      }
      const { storyMapper = defaultStoryMapper } = provider.getConfig();
      const ref = api.getRefs()[id];
      let storiesHash;
      if (setStoriesData) {
        storiesHash = transformSetStoriesStoryDataToStoriesHash(
          map(setStoriesData, ref, { storyMapper }),
          { provider, docsOptions }
        );
      } else if (storyIndex) {
        storiesHash = transformStoryIndexToStoriesHash(storyIndex, { provider, docsOptions });
      }
      if (storiesHash)
        storiesHash = addRefIds(storiesHash, ref);
      api.updateRef(id, { stories: storiesHash, ...rest, ready });
    },
    updateRef: (id, data) => {
      const { [id]: ref, ...updated } = api.getRefs();
      updated[id] = { ...ref, ...data };
      const ordered = Object.keys(initialState).reduce((obj, key) => {
        obj[key] = updated[key];
        return obj;
      }, {});
      store2.setState({
        refs: ordered
      });
    }
  };
  const refs = !singleStory && import_global3.default.REFS || {};
  const initialState = refs;
  if (runCheck) {
    Object.entries(refs).forEach(([id, ref]) => {
      api.checkRef({ ...ref, stories: {} });
    });
  }
  return {
    api,
    state: {
      refs: initialState
    }
  };
};

// src/lib/events.ts
var getEventMetadata = (context, fullAPI) => {
  const { source, refId, type } = context;
  const [sourceType, sourceLocation] = getSourceType(source, refId);
  const ref = refId && fullAPI.getRefs()[refId] ? fullAPI.getRefs()[refId] : fullAPI.findRef(sourceLocation);
  const meta = {
    source,
    sourceType,
    sourceLocation,
    refId,
    ref,
    type
  };
  switch (true) {
    case typeof refId === "string":
    case sourceType === "local":
    case sourceType === "external": {
      return meta;
    }
    default: {
      import_client_logger2.logger.warn(`Received a ${type} frame that was not configured as a ref`);
      return null;
    }
  }
};

// src/modules/stories.ts
var { FEATURES: FEATURES2, fetch: fetch2 } = import_global4.default;
var STORY_INDEX_PATH = "./index.json";
var deprecatedOptionsParameterWarnings = [
  "enableShortcuts",
  "theme",
  "showRoots"
].reduce((acc, option) => {
  acc[option] = (0, import_util_deprecate3.default)(
    () => {
    },
    `parameters.options.${option} is deprecated and will be removed in Storybook 7.0.
To change this setting, use \`addons.setConfig\`. See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-immutable-options-parameters
  `
  );
  return acc;
}, {});
function checkDeprecatedOptionParameters(options) {
  if (!options) {
    return;
  }
  Object.keys(options).forEach((option) => {
    if (deprecatedOptionsParameterWarnings[option]) {
      deprecatedOptionsParameterWarnings[option]();
    }
  });
}
var init8 = ({
  fullAPI,
  store: store2,
  navigate,
  provider,
  storyId: initialStoryId,
  viewMode: initialViewMode,
  docsOptions = {}
}) => {
  const api = {
    storyId: import_csf2.toId,
    getData: (storyId, refId) => {
      const result = api.resolveStory(storyId, refId);
      if ((result == null ? void 0 : result.type) === "story" || (result == null ? void 0 : result.type) === "docs") {
        return result;
      }
      return void 0;
    },
    isPrepared: (storyId, refId) => {
      const data = api.getData(storyId, refId);
      return data.type === "story" ? data.prepared : true;
    },
    resolveStory: (storyId, refId) => {
      const { refs, storiesHash } = store2.getState();
      if (refId) {
        return refs[refId].stories ? refs[refId].stories[storyId] : void 0;
      }
      return storiesHash ? storiesHash[storyId] : void 0;
    },
    getCurrentStoryData: () => {
      const { storyId, refId } = store2.getState();
      return api.getData(storyId, refId);
    },
    getParameters: (storyIdOrCombo, parameterName) => {
      const { storyId, refId } = typeof storyIdOrCombo === "string" ? { storyId: storyIdOrCombo, refId: void 0 } : storyIdOrCombo;
      const data = api.getData(storyId, refId);
      if ((data == null ? void 0 : data.type) === "story") {
        const { parameters } = data;
        if (parameters) {
          return parameterName ? parameters[parameterName] : parameters;
        }
      }
      return null;
    },
    getCurrentParameter: (parameterName) => {
      const { storyId, refId } = store2.getState();
      const parameters = api.getParameters({ storyId, refId }, parameterName);
      return parameters || void 0;
    },
    jumpToComponent: (direction) => {
      const { storiesHash, storyId, refs, refId } = store2.getState();
      const story = api.getData(storyId, refId);
      if (!story) {
        return;
      }
      const hash = refId ? refs[refId].stories || {} : storiesHash;
      const result = api.findSiblingStoryId(storyId, hash, direction, true);
      if (result) {
        api.selectStory(result, void 0, { ref: refId });
      }
    },
    jumpToStory: (direction) => {
      const { storiesHash, storyId, refs, refId } = store2.getState();
      const story = api.getData(storyId, refId);
      if (!story) {
        return;
      }
      const hash = story.refId ? refs[story.refId].stories : storiesHash;
      const result = api.findSiblingStoryId(storyId, hash, direction, false);
      if (result) {
        api.selectStory(result, void 0, { ref: refId });
      }
    },
    setStories: async (input, error) => {
      const hash = transformSetStoriesStoryDataToStoriesHash(input, {
        provider,
        docsOptions
      });
      await store2.setState({
        storiesHash: hash,
        storiesConfigured: true,
        storiesFailed: error
      });
    },
    selectFirstStory: () => {
      const { storiesHash } = store2.getState();
      const firstStory = Object.keys(storiesHash).find((id) => storiesHash[id].type === "story");
      if (firstStory) {
        api.selectStory(firstStory);
        return;
      }
      navigate("/");
    },
    selectStory: (titleOrId = void 0, name = void 0, options = {}) => {
      const { ref } = options;
      const { storyId, storiesHash, refs } = store2.getState();
      const hash = ref ? refs[ref].stories : storiesHash;
      const kindSlug = storyId == null ? void 0 : storyId.split("--", 2)[0];
      if (!name) {
        const entry = titleOrId ? hash[titleOrId] || hash[(0, import_csf2.sanitize)(titleOrId)] : hash[kindSlug];
        if (!entry)
          throw new Error(`Unknown id or title: '${titleOrId}'`);
        const leafEntry = api.findLeafEntry(hash, entry.id);
        const fullId = leafEntry.refId ? `${leafEntry.refId}_${leafEntry.id}` : leafEntry.id;
        navigate(`/${leafEntry.type}/${fullId}`);
      } else if (!titleOrId) {
        const id = (0, import_csf2.toId)(kindSlug, name);
        api.selectStory(id, void 0, options);
      } else {
        const id = ref ? `${ref}_${(0, import_csf2.toId)(titleOrId, name)}` : (0, import_csf2.toId)(titleOrId, name);
        if (hash[id]) {
          api.selectStory(id, void 0, options);
        } else {
          const entry = hash[(0, import_csf2.sanitize)(titleOrId)];
          if ((entry == null ? void 0 : entry.type) === "component") {
            const foundId = entry.children.find((childId) => hash[childId].name === name);
            if (foundId) {
              api.selectStory(foundId, void 0, options);
            }
          }
        }
      }
    },
    findLeafEntry(storiesHash, storyId) {
      const entry = storiesHash[storyId];
      if (entry.type === "docs" || entry.type === "story") {
        return entry;
      }
      const childStoryId = entry.children[0];
      return api.findLeafEntry(storiesHash, childStoryId);
    },
    findLeafStoryId(storiesHash, storyId) {
      var _a;
      return (_a = api.findLeafEntry(storiesHash, storyId)) == null ? void 0 : _a.id;
    },
    findSiblingStoryId(storyId, hash, direction, toSiblingGroup) {
      if (toSiblingGroup) {
        const lookupList2 = getComponentLookupList(hash);
        const index2 = lookupList2.findIndex((i) => i.includes(storyId));
        if (index2 === lookupList2.length - 1 && direction > 0) {
          return;
        }
        if (index2 === 0 && direction < 0) {
          return;
        }
        if (lookupList2[index2 + direction]) {
          return lookupList2[index2 + direction][0];
        }
        return;
      }
      const lookupList = getStoriesLookupList(hash);
      const index = lookupList.indexOf(storyId);
      if (index === lookupList.length - 1 && direction > 0) {
        return;
      }
      if (index === 0 && direction < 0) {
        return;
      }
      return lookupList[index + direction];
    },
    updateStoryArgs: (story, updatedArgs) => {
      const { id: storyId, refId } = story;
      fullAPI.emit(import_core_events2.UPDATE_STORY_ARGS, {
        storyId,
        updatedArgs,
        options: { target: refId }
      });
    },
    resetStoryArgs: (story, argNames) => {
      const { id: storyId, refId } = story;
      fullAPI.emit(import_core_events2.RESET_STORY_ARGS, {
        storyId,
        argNames,
        options: { target: refId }
      });
    },
    fetchStoryList: async () => {
      try {
        const result = await fetch2(STORY_INDEX_PATH);
        if (result.status !== 200)
          throw new Error(await result.text());
        const storyIndex = await result.json();
        if (storyIndex.v < 3) {
          import_client_logger3.logger.warn(`Skipping story index with version v${storyIndex.v}, awaiting SET_STORIES.`);
          return;
        }
        await fullAPI.setStoryList(storyIndex);
      } catch (err) {
        store2.setState({
          storiesConfigured: true,
          storiesFailed: err
        });
      }
    },
    setStoryList: async (storyIndex) => {
      const newHash = transformStoryIndexToStoriesHash(storyIndex, {
        provider,
        docsOptions
      });
      const oldHash = store2.getState().storiesHash;
      await store2.setState({
        storiesHash: addPreparedStories(newHash, oldHash),
        storiesConfigured: true,
        storiesFailed: null
      });
    },
    updateStory: async (storyId, update2, ref) => {
      if (!ref) {
        const { storiesHash } = store2.getState();
        storiesHash[storyId] = {
          ...storiesHash[storyId],
          ...update2
        };
        await store2.setState({ storiesHash });
      } else {
        const { id: refId, stories } = ref;
        stories[storyId] = {
          ...stories[storyId],
          ...update2
        };
        await fullAPI.updateRef(refId, { stories });
      }
    }
  };
  const initModule = async () => {
    var _a;
    fullAPI.on(
      import_core_events2.STORY_SPECIFIED,
      function handler({
        storyId,
        viewMode
      }) {
        const { sourceType } = getEventMetadata(this, fullAPI);
        if (fullAPI.isSettingsScreenActive())
          return;
        if (sourceType === "local") {
          const state = store2.getState();
          if (state.storyId !== storyId || state.viewMode !== viewMode) {
            navigate(`/${viewMode}/${storyId}`);
          }
        }
      }
    );
    fullAPI.on(import_core_events2.STORY_CHANGED, function handler() {
      const { sourceType } = getEventMetadata(this, fullAPI);
      if (sourceType === "local") {
        const options = fullAPI.getCurrentParameter("options");
        if (options) {
          checkDeprecatedOptionParameters(options);
          fullAPI.setOptions(options);
        }
      }
    });
    fullAPI.on(import_core_events2.STORY_PREPARED, function handler({ id, ...update2 }) {
      const { ref, sourceType } = getEventMetadata(this, fullAPI);
      fullAPI.updateStory(id, { ...update2, prepared: true }, ref);
      if (!ref) {
        if (!store2.getState().hasCalledSetOptions) {
          const { options } = update2.parameters;
          checkDeprecatedOptionParameters(options);
          fullAPI.setOptions(options);
          store2.setState({ hasCalledSetOptions: true });
        }
      } else {
        fullAPI.updateRef(ref.id, { ready: true });
      }
      if (sourceType === "local") {
        const { storyId, storiesHash, refId } = store2.getState();
        const toBePreloaded = Array.from(
          /* @__PURE__ */ new Set([
            api.findSiblingStoryId(storyId, storiesHash, 1, true),
            api.findSiblingStoryId(storyId, storiesHash, -1, true)
          ])
        ).filter(Boolean);
        fullAPI.emit(import_core_events2.PRELOAD_ENTRIES, {
          ids: toBePreloaded,
          options: { target: refId }
        });
      }
    });
    fullAPI.on(import_core_events2.SET_STORIES, function handler(data) {
      const { ref } = getEventMetadata(this, fullAPI);
      const setStoriesData = data.v ? denormalizeStoryParameters(data) : data.stories;
      if (!ref) {
        if (!data.v) {
          throw new Error("Unexpected legacy SET_STORIES event from local source");
        }
        fullAPI.setStories(setStoriesData);
        const options = fullAPI.getCurrentParameter("options");
        checkDeprecatedOptionParameters(options);
        fullAPI.setOptions(options);
      } else {
        fullAPI.setRef(ref.id, { ...ref, setStoriesData }, true);
      }
    });
    fullAPI.on(
      import_core_events2.SELECT_STORY,
      function handler({
        kind,
        story,
        storyId,
        ...rest
      }) {
        const { ref } = getEventMetadata(this, fullAPI);
        if (!ref) {
          fullAPI.selectStory(storyId || kind, story, rest);
        } else {
          fullAPI.selectStory(storyId || kind, story, { ...rest, ref: ref.id });
        }
      }
    );
    fullAPI.on(
      import_core_events2.STORY_ARGS_UPDATED,
      function handleStoryArgsUpdated({ storyId, args }) {
        const { ref } = getEventMetadata(this, fullAPI);
        fullAPI.updateStory(storyId, { args }, ref);
      }
    );
    fullAPI.on(import_core_events2.CONFIG_ERROR, function handleConfigError(err) {
      store2.setState({
        storiesConfigured: true,
        storiesFailed: err
      });
    });
    if (FEATURES2 == null ? void 0 : FEATURES2.storyStoreV7) {
      (_a = provider.serverChannel) == null ? void 0 : _a.on(import_core_events2.STORY_INDEX_INVALIDATED, () => fullAPI.fetchStoryList());
      await fullAPI.fetchStoryList();
    }
  };
  return {
    api,
    state: {
      storiesHash: {},
      storyId: initialStoryId,
      viewMode: initialViewMode,
      storiesConfigured: false,
      hasCalledSetOptions: false
    },
    init: initModule
  };
};

// src/modules/layout.ts
var layout_exports = {};
__export(layout_exports, {
  ActiveTabs: () => ActiveTabs,
  focusableUIElements: () => focusableUIElements,
  init: () => init9
});
var import_global5 = __toESM(require("global"));
var import_pick = __toESM(require("lodash/pick"));
var import_dequal = require("dequal");
var import_create = require("@storybook/theming/create");
var import_core_events3 = require("@storybook/core-events");
var import_client_logger4 = require("@storybook/client-logger");
var import_ts_dedent4 = require("ts-dedent");
var { document } = import_global5.default;
var ActiveTabs = {
  SIDEBAR: "sidebar",
  CANVAS: "canvas",
  ADDONS: "addons"
};
var defaultState = {
  ui: {
    enableShortcuts: true
  },
  layout: {
    initialActive: ActiveTabs.CANVAS,
    showToolbar: true,
    isFullscreen: false,
    showPanel: true,
    showNav: true,
    panelPosition: "bottom",
    showTabs: true
  },
  selectedPanel: void 0,
  theme: (0, import_create.create)()
};
var focusableUIElements = {
  storySearchField: "storybook-explorer-searchfield",
  storyListMenu: "storybook-explorer-menu",
  storyPanelRoot: "storybook-panel-root"
};
var init9 = ({ store: store2, provider, singleStory, fullAPI }) => {
  const api = {
    toggleFullscreen(toggled) {
      return store2.setState(
        (state) => {
          const { showNav } = state.layout;
          const value = typeof toggled === "boolean" ? toggled : !state.layout.isFullscreen;
          const shouldShowNav = showNav === false && value === false;
          return {
            layout: {
              ...state.layout,
              isFullscreen: value,
              showNav: !singleStory && shouldShowNav ? true : showNav
            }
          };
        },
        { persistence: "session" }
      );
    },
    togglePanel(toggled) {
      return store2.setState(
        (state) => {
          const { showNav, isFullscreen } = state.layout;
          const value = typeof toggled !== "undefined" ? toggled : !state.layout.showPanel;
          const shouldToggleFullScreen = showNav === false && value === false;
          return {
            layout: {
              ...state.layout,
              showPanel: value,
              isFullscreen: shouldToggleFullScreen ? true : isFullscreen
            }
          };
        },
        { persistence: "session" }
      );
    },
    togglePanelPosition(position) {
      if (typeof position !== "undefined") {
        return store2.setState(
          (state) => ({
            layout: {
              ...state.layout,
              panelPosition: position
            }
          }),
          { persistence: "permanent" }
        );
      }
      return store2.setState(
        (state) => ({
          layout: {
            ...state.layout,
            panelPosition: state.layout.panelPosition === "right" ? "bottom" : "right"
          }
        }),
        { persistence: "permanent" }
      );
    },
    toggleNav(toggled) {
      return store2.setState(
        (state) => {
          if (singleStory)
            return { layout: state.layout };
          const { showPanel, isFullscreen } = state.layout;
          const showNav = typeof toggled !== "undefined" ? toggled : !state.layout.showNav;
          const shouldToggleFullScreen = showPanel === false && showNav === false;
          return {
            layout: {
              ...state.layout,
              showNav,
              isFullscreen: shouldToggleFullScreen ? true : !showNav && isFullscreen
            }
          };
        },
        { persistence: "session" }
      );
    },
    toggleToolbar(toggled) {
      return store2.setState(
        (state) => {
          const value = typeof toggled !== "undefined" ? toggled : !state.layout.showToolbar;
          return {
            layout: {
              ...state.layout,
              showToolbar: value
            }
          };
        },
        { persistence: "session" }
      );
    },
    resetLayout() {
      return store2.setState(
        (state) => {
          return {
            layout: {
              ...state.layout,
              showNav: false,
              showPanel: false,
              isFullscreen: false
            }
          };
        },
        { persistence: "session" }
      );
    },
    focusOnUIElement(elementId, select) {
      if (!elementId) {
        return;
      }
      const element = document.getElementById(elementId);
      if (element) {
        element.focus();
        if (select)
          element.select();
      }
    },
    getInitialOptions() {
      var _a;
      const { theme, selectedPanel, ...options } = provider.getConfig();
      if (((_a = options.layout) == null ? void 0 : _a.isToolshown) !== void 0) {
        import_client_logger4.once.warn(import_ts_dedent4.dedent`
          The "isToolshown" option is deprecated. Please use "showToolbar" instead.

          See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#renamed-istoolshown-to-showtoolbar
        `);
        options.layout.showToolbar = options.layout.isToolshown;
      }
      return {
        ...defaultState,
        layout: {
          ...defaultState.layout,
          ...(0, import_pick.default)(options, Object.keys(defaultState.layout)),
          ...singleStory && { showNav: false }
        },
        ui: {
          ...defaultState.ui,
          ...(0, import_pick.default)(options, Object.keys(defaultState.ui))
        },
        selectedPanel: selectedPanel || defaultState.selectedPanel,
        theme: theme || defaultState.theme
      };
    },
    setOptions: (options) => {
      const { layout, ui, selectedPanel, theme } = store2.getState();
      if (options) {
        const updatedLayout = {
          ...layout,
          ...(0, import_pick.default)(options, Object.keys(layout)),
          ...singleStory && { showNav: false }
        };
        const updatedUi = {
          ...ui,
          ...(0, import_pick.default)(options, Object.keys(ui))
        };
        const updatedTheme = {
          ...theme,
          ...options.theme
        };
        const modification = {};
        if (!(0, import_dequal.dequal)(ui, updatedUi)) {
          modification.ui = updatedUi;
        }
        if (!(0, import_dequal.dequal)(layout, updatedLayout)) {
          modification.layout = updatedLayout;
        }
        if (options.selectedPanel && !(0, import_dequal.dequal)(selectedPanel, options.selectedPanel)) {
          modification.selectedPanel = options.selectedPanel;
        }
        if (Object.keys(modification).length) {
          store2.setState(modification, { persistence: "permanent" });
        }
        if (!(0, import_dequal.dequal)(theme, updatedTheme)) {
          store2.setState({ theme: updatedTheme });
        }
      }
    }
  };
  const persisted = (0, import_pick.default)(store2.getState(), "layout", "ui", "selectedPanel");
  return {
    api,
    state: merge_default(api.getInitialOptions(), persisted),
    init: () => {
      api.setOptions(merge_default(api.getInitialOptions(), persisted));
      fullAPI.on(import_core_events3.SET_CONFIG, () => {
        api.setOptions(merge_default(api.getInitialOptions(), persisted));
      });
    }
  };
};

// src/modules/shortcuts.ts
var shortcuts_exports = {};
__export(shortcuts_exports, {
  controlOrMetaKey: () => controlOrMetaKey,
  defaultShortcuts: () => defaultShortcuts,
  init: () => init10,
  isMacLike: () => isMacLike,
  keys: () => keys
});
var import_global7 = __toESM(require("global"));
var import_core_events4 = require("@storybook/core-events");

// src/lib/shortcut.ts
var import_global6 = __toESM(require("global"));
var { navigator } = import_global6.default;
var eventToShortcut = (e) => {
  if (["Meta", "Alt", "Control", "Shift"].includes(e.key)) {
    return null;
  }
  const keys2 = [];
  if (e.altKey) {
    keys2.push("alt");
  }
  if (e.ctrlKey) {
    keys2.push("control");
  }
  if (e.metaKey) {
    keys2.push("meta");
  }
  if (e.shiftKey) {
    keys2.push("shift");
  }
  if (e.key && e.key.length === 1 && e.key !== " ") {
    keys2.push(e.key.toUpperCase());
  }
  if (e.key === " ") {
    keys2.push("space");
  }
  if (e.key === "Escape") {
    keys2.push("escape");
  }
  if (e.key === "ArrowRight") {
    keys2.push("ArrowRight");
  }
  if (e.key === "ArrowDown") {
    keys2.push("ArrowDown");
  }
  if (e.key === "ArrowUp") {
    keys2.push("ArrowUp");
  }
  if (e.key === "ArrowLeft") {
    keys2.push("ArrowLeft");
  }
  return keys2.length > 0 ? keys2 : null;
};
var shortcutMatchesShortcut = (inputShortcut, shortcut) => {
  if (!inputShortcut || !shortcut)
    return false;
  if (inputShortcut.join("") === "shift/")
    inputShortcut.shift();
  if (inputShortcut.length !== shortcut.length)
    return false;
  return !inputShortcut.find((key, i) => key !== shortcut[i]);
};

// src/modules/shortcuts.ts
var { navigator: navigator2, document: document2 } = import_global7.default;
var isMacLike = () => navigator2 && navigator2.platform ? !!navigator2.platform.match(/(Mac|iPhone|iPod|iPad)/i) : false;
var controlOrMetaKey = () => isMacLike() ? "meta" : "control";
function keys(o) {
  return Object.keys(o);
}
var defaultShortcuts = Object.freeze({
  fullScreen: ["F"],
  togglePanel: ["A"],
  panelPosition: ["D"],
  toggleNav: ["S"],
  toolbar: ["T"],
  search: ["/"],
  focusNav: ["1"],
  focusIframe: ["2"],
  focusPanel: ["3"],
  prevComponent: ["alt", "ArrowUp"],
  nextComponent: ["alt", "ArrowDown"],
  prevStory: ["alt", "ArrowLeft"],
  nextStory: ["alt", "ArrowRight"],
  shortcutsPage: [controlOrMetaKey(), "shift", ","],
  aboutPage: [","],
  escape: ["escape"],
  collapseAll: [controlOrMetaKey(), "shift", "ArrowUp"],
  expandAll: [controlOrMetaKey(), "shift", "ArrowDown"]
});
var addonsShortcuts = {};
function focusInInput(event) {
  return /input|textarea/i.test(event.target.tagName) || event.target.getAttribute("contenteditable") !== null;
}
var init10 = ({ store: store2, fullAPI }) => {
  const api = {
    getShortcutKeys() {
      return store2.getState().shortcuts;
    },
    getDefaultShortcuts() {
      return {
        ...defaultShortcuts,
        ...api.getAddonsShortcutDefaults()
      };
    },
    getAddonsShortcuts() {
      return addonsShortcuts;
    },
    getAddonsShortcutLabels() {
      const labels = {};
      Object.entries(api.getAddonsShortcuts()).forEach(([actionName, { label }]) => {
        labels[actionName] = label;
      });
      return labels;
    },
    getAddonsShortcutDefaults() {
      const defaults = {};
      Object.entries(api.getAddonsShortcuts()).forEach(([actionName, { defaultShortcut }]) => {
        defaults[actionName] = defaultShortcut;
      });
      return defaults;
    },
    async setShortcuts(shortcuts) {
      await store2.setState({ shortcuts }, { persistence: "permanent" });
      return shortcuts;
    },
    async restoreAllDefaultShortcuts() {
      return api.setShortcuts(api.getDefaultShortcuts());
    },
    async setShortcut(action, value) {
      const shortcuts = api.getShortcutKeys();
      await api.setShortcuts({ ...shortcuts, [action]: value });
      return value;
    },
    async setAddonShortcut(addon, shortcut) {
      const shortcuts = api.getShortcutKeys();
      await api.setShortcuts({
        ...shortcuts,
        [`${addon}-${shortcut.actionName}`]: shortcut.defaultShortcut
      });
      addonsShortcuts[`${addon}-${shortcut.actionName}`] = shortcut;
      return shortcut;
    },
    async restoreDefaultShortcut(action) {
      const defaultShortcut = api.getDefaultShortcuts()[action];
      return api.setShortcut(action, defaultShortcut);
    },
    handleKeydownEvent(event) {
      const shortcut = eventToShortcut(event);
      const shortcuts = api.getShortcutKeys();
      const actions = keys(shortcuts);
      const matchedFeature = actions.find(
        (feature) => shortcutMatchesShortcut(shortcut, shortcuts[feature])
      );
      if (matchedFeature) {
        if (event == null ? void 0 : event.preventDefault)
          event.preventDefault();
        api.handleShortcutFeature(matchedFeature);
      }
    },
    handleShortcutFeature(feature) {
      const {
        layout: { isFullscreen, showNav, showPanel },
        ui: { enableShortcuts }
      } = store2.getState();
      if (!enableShortcuts) {
        return;
      }
      switch (feature) {
        case "escape": {
          if (isFullscreen) {
            fullAPI.toggleFullscreen();
          } else if (!showNav) {
            fullAPI.toggleNav();
          }
          break;
        }
        case "focusNav": {
          if (isFullscreen) {
            fullAPI.toggleFullscreen();
          }
          if (!showNav) {
            fullAPI.toggleNav();
          }
          fullAPI.focusOnUIElement(focusableUIElements.storyListMenu);
          break;
        }
        case "search": {
          if (isFullscreen) {
            fullAPI.toggleFullscreen();
          }
          if (!showNav) {
            fullAPI.toggleNav();
          }
          setTimeout(() => {
            fullAPI.focusOnUIElement(focusableUIElements.storySearchField, true);
          }, 0);
          break;
        }
        case "focusIframe": {
          const element = document2.getElementById("storybook-preview-iframe");
          if (element) {
            try {
              element.contentWindow.focus();
            } catch (e) {
            }
          }
          break;
        }
        case "focusPanel": {
          if (isFullscreen) {
            fullAPI.toggleFullscreen();
          }
          if (!showPanel) {
            fullAPI.togglePanel();
          }
          fullAPI.focusOnUIElement(focusableUIElements.storyPanelRoot);
          break;
        }
        case "nextStory": {
          fullAPI.jumpToStory(1);
          break;
        }
        case "prevStory": {
          fullAPI.jumpToStory(-1);
          break;
        }
        case "nextComponent": {
          fullAPI.jumpToComponent(1);
          break;
        }
        case "prevComponent": {
          fullAPI.jumpToComponent(-1);
          break;
        }
        case "fullScreen": {
          fullAPI.toggleFullscreen();
          break;
        }
        case "togglePanel": {
          if (isFullscreen) {
            fullAPI.toggleFullscreen();
            fullAPI.resetLayout();
          }
          fullAPI.togglePanel();
          break;
        }
        case "toggleNav": {
          if (isFullscreen) {
            fullAPI.toggleFullscreen();
            fullAPI.resetLayout();
          }
          fullAPI.toggleNav();
          break;
        }
        case "toolbar": {
          fullAPI.toggleToolbar();
          break;
        }
        case "panelPosition": {
          if (isFullscreen) {
            fullAPI.toggleFullscreen();
          }
          if (!showPanel) {
            fullAPI.togglePanel();
          }
          fullAPI.togglePanelPosition();
          break;
        }
        case "aboutPage": {
          fullAPI.navigate("/settings/about");
          break;
        }
        case "shortcutsPage": {
          fullAPI.navigate("/settings/shortcuts");
          break;
        }
        case "collapseAll": {
          fullAPI.collapseAll();
          break;
        }
        case "expandAll": {
          fullAPI.expandAll();
          break;
        }
        default:
          addonsShortcuts[feature].action();
          break;
      }
    }
  };
  const { shortcuts: persistedShortcuts = defaultShortcuts } = store2.getState();
  const state = {
    shortcuts: keys(defaultShortcuts).reduce(
      (acc, key) => ({ ...acc, [key]: persistedShortcuts[key] || defaultShortcuts[key] }),
      defaultShortcuts
    )
  };
  const initModule = () => {
    document2.addEventListener("keydown", (event) => {
      if (!focusInInput(event)) {
        fullAPI.handleKeydownEvent(event);
      }
    });
    fullAPI.on(import_core_events4.PREVIEW_KEYDOWN, (data) => {
      fullAPI.handleKeydownEvent(data.event);
    });
  };
  return { api, state, init: initModule };
};

// src/modules/url.ts
var url_exports = {};
__export(url_exports, {
  init: () => init11
});
var import_client_logger5 = require("@storybook/client-logger");
var import_core_events5 = require("@storybook/core-events");
var import_router = require("@storybook/router");
var import_csf3 = require("@storybook/csf");
var import_dequal2 = require("dequal");
var import_global8 = __toESM(require("global"));
var import_ts_dedent5 = require("ts-dedent");
var { window: globalWindow } = import_global8.default;
var parseBoolean = (value) => {
  if (value === "true" || value === "1")
    return true;
  if (value === "false" || value === "0")
    return false;
  return void 0;
};
var prevParams;
var initialUrlSupport = ({
  state: { location: location2, path, viewMode, storyId: storyIdFromUrl },
  singleStory
}) => {
  const {
    full,
    panel,
    nav,
    shortcuts,
    addonPanel,
    tabs,
    addons,
    panelRight,
    stories,
    selectedKind,
    selectedStory,
    path: queryPath,
    ...otherParams
  } = (0, import_router.queryFromLocation)(location2);
  const layout = {
    isFullscreen: parseBoolean(full),
    showNav: !singleStory && parseBoolean(nav),
    showPanel: parseBoolean(panel),
    panelPosition: ["right", "bottom"].includes(panel) ? panel : void 0,
    showTabs: parseBoolean(tabs)
  };
  const ui = {
    enableShortcuts: parseBoolean(shortcuts)
  };
  const selectedPanel = addonPanel || void 0;
  if (addons === "0") {
    import_client_logger5.once.warn(import_ts_dedent5.dedent`
      The 'addons' query param is deprecated and will be removed in Storybook 7.0. Use 'panel=false' instead.

      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-layout-url-params
    `);
    layout.showPanel = false;
  }
  if (panelRight === "1") {
    import_client_logger5.once.warn(import_ts_dedent5.dedent`
      The 'panelRight' query param is deprecated and will be removed in Storybook 7.0. Use 'panel=right' instead.

      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-layout-url-params
    `);
    layout.panelPosition = "right";
  }
  if (stories === "0") {
    import_client_logger5.once.warn(import_ts_dedent5.dedent`
      The 'stories' query param is deprecated and will be removed in Storybook 7.0. Use 'nav=false' instead.

      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-layout-url-params
    `);
    layout.showNav = false;
  }
  let storyId = storyIdFromUrl;
  if (!storyId && selectedKind) {
    import_client_logger5.once.warn(import_ts_dedent5.dedent`
      The 'selectedKind' and 'selectedStory' query params are deprecated and will be removed in Storybook 7.0. Use 'path' instead.

      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-layout-url-params
    `);
    storyId = selectedStory ? (0, import_csf3.toId)(selectedKind, selectedStory) : (0, import_csf3.sanitize)(selectedKind);
  }
  const customQueryParams = (0, import_dequal2.dequal)(prevParams, otherParams) ? prevParams : otherParams;
  prevParams = customQueryParams;
  return { viewMode, layout, ui, selectedPanel, location: location2, path, customQueryParams, storyId };
};
var init11 = ({ store: store2, navigate, state, provider, fullAPI, ...rest }) => {
  const navigateTo = (path, queryParams = {}, options = {}) => {
    const params = Object.entries(queryParams).filter(([, v]) => v).sort(([a], [b]) => a < b ? -1 : 1).map(([k, v]) => `${k}=${v}`);
    const to = [path, ...params].join("&");
    return navigate(to, options);
  };
  const api = {
    getQueryParam(key) {
      const { customQueryParams } = store2.getState();
      return customQueryParams ? customQueryParams[key] : void 0;
    },
    getUrlState() {
      const { path, customQueryParams, storyId, url, viewMode } = store2.getState();
      return { path, queryParams: customQueryParams, storyId, url, viewMode };
    },
    setQueryParams(input) {
      const { customQueryParams } = store2.getState();
      const queryParams = {};
      const update2 = {
        ...customQueryParams,
        ...Object.entries(input).reduce((acc, [key, value]) => {
          if (value !== null) {
            acc[key] = value;
          }
          return acc;
        }, queryParams)
      };
      if (!(0, import_dequal2.dequal)(customQueryParams, update2)) {
        store2.setState({ customQueryParams: update2 });
        fullAPI.emit(import_core_events5.UPDATE_QUERY_PARAMS, update2);
      }
    },
    navigateUrl(url, options) {
      navigate(url, { ...options, plain: true });
    }
  };
  const initModule = () => {
    const updateArgsParam = () => {
      const { path, queryParams, viewMode } = fullAPI.getUrlState();
      if (viewMode !== "story")
        return;
      const currentStory = fullAPI.getCurrentStoryData();
      if ((currentStory == null ? void 0 : currentStory.type) !== "story")
        return;
      const { args, initialArgs } = currentStory;
      const argsString = (0, import_router.buildArgsParam)(initialArgs, args);
      navigateTo(path, { ...queryParams, args: argsString }, { replace: true });
      api.setQueryParams({ args: argsString });
    };
    fullAPI.on(import_core_events5.SET_CURRENT_STORY, () => updateArgsParam());
    let handleOrId;
    fullAPI.on(import_core_events5.STORY_ARGS_UPDATED, () => {
      if ("requestIdleCallback" in globalWindow) {
        if (handleOrId)
          globalWindow.cancelIdleCallback(handleOrId);
        handleOrId = globalWindow.requestIdleCallback(updateArgsParam, { timeout: 1e3 });
      } else {
        if (handleOrId)
          clearTimeout(handleOrId);
        setTimeout(updateArgsParam, 100);
      }
    });
    fullAPI.on(import_core_events5.GLOBALS_UPDATED, ({ globals, initialGlobals }) => {
      const { path, queryParams } = fullAPI.getUrlState();
      const globalsString = (0, import_router.buildArgsParam)(initialGlobals, globals);
      navigateTo(path, { ...queryParams, globals: globalsString }, { replace: true });
      api.setQueryParams({ globals: globalsString });
    });
    fullAPI.on(import_core_events5.NAVIGATE_URL, (url, options) => {
      fullAPI.navigateUrl(url, options);
    });
    if (fullAPI.showReleaseNotesOnLaunch()) {
      navigate("/settings/release-notes");
    }
  };
  return {
    api,
    state: initialUrlSupport({ store: store2, navigate, state, provider, fullAPI, ...rest }),
    init: initModule
  };
};

// src/modules/versions.ts
var versions_exports = {};
__export(versions_exports, {
  init: () => init12
});
var import_global9 = __toESM(require("global"));
var import_semver = __toESM(require("@storybook/semver"));
var import_memoizerific3 = __toESM(require("memoizerific"));

// src/version.ts
var version = "7.0.0-alpha.34";

// src/modules/versions.ts
var { VERSIONCHECK } = import_global9.default;
var getVersionCheckData = (0, import_memoizerific3.default)(1)(() => {
  try {
    return { ...JSON.parse(VERSIONCHECK).data || {} };
  } catch (e) {
    return {};
  }
});
var init12 = ({ store: store2, mode, fullAPI }) => {
  const { dismissedVersionNotification } = store2.getState();
  const state = {
    versions: {
      current: {
        version
      },
      ...getVersionCheckData()
    },
    dismissedVersionNotification
  };
  const api = {
    getCurrentVersion: () => {
      const {
        versions: { current }
      } = store2.getState();
      return current;
    },
    getLatestVersion: () => {
      const {
        versions: { latest, next, current }
      } = store2.getState();
      if (current && import_semver.default.prerelease(current.version) && next) {
        return latest && import_semver.default.gt(latest.version, next.version) ? latest : next;
      }
      return latest;
    },
    versionUpdateAvailable: () => {
      const latest = api.getLatestVersion();
      const current = api.getCurrentVersion();
      if (latest) {
        if (!latest.version) {
          return true;
        }
        if (!current.version) {
          return true;
        }
        const onPrerelease = !!import_semver.default.prerelease(current.version);
        const actualCurrent = onPrerelease ? `${import_semver.default.major(current.version)}.${import_semver.default.minor(current.version)}.${import_semver.default.patch(
          current.version
        )}` : current.version;
        const diff = import_semver.default.diff(actualCurrent, latest.version);
        return import_semver.default.gt(latest.version, actualCurrent) && diff !== "patch" && !diff.includes("pre");
      }
      return false;
    }
  };
  const initModule = async () => {
    const { versions = {} } = store2.getState();
    const { latest, next } = getVersionCheckData();
    await store2.setState({
      versions: { ...versions, latest, next }
    });
    if (api.versionUpdateAvailable()) {
      const latestVersion = api.getLatestVersion().version;
      const diff = import_semver.default.diff(versions.current.version, versions.latest.version);
      if (latestVersion !== dismissedVersionNotification && diff !== "patch" && !import_semver.default.prerelease(latestVersion) && mode !== "production") {
        fullAPI.addNotification({
          id: "update",
          link: "/settings/about",
          content: {
            headline: `Storybook ${latestVersion} is available!`,
            subHeadline: `Your current version is: ${versions.current.version}`
          },
          icon: { name: "book" },
          onClear() {
            store2.setState(
              { dismissedVersionNotification: latestVersion },
              { persistence: "permanent" }
            );
          }
        });
      }
    }
  };
  return { init: initModule, state, api };
};

// src/modules/globals.ts
var globals_exports = {};
__export(globals_exports, {
  init: () => init13
});
var import_core_events6 = require("@storybook/core-events");
var import_client_logger6 = require("@storybook/client-logger");
var import_dequal3 = require("dequal");
var init13 = ({ store: store2, fullAPI }) => {
  const api = {
    getGlobals() {
      return store2.getState().globals;
    },
    getGlobalTypes() {
      return store2.getState().globalTypes;
    },
    updateGlobals(newGlobals) {
      fullAPI.emit(import_core_events6.UPDATE_GLOBALS, {
        globals: newGlobals,
        options: {
          target: "storybook-preview-iframe"
        }
      });
    }
  };
  const state = {
    globals: {},
    globalTypes: {}
  };
  const updateGlobals = (globals) => {
    var _a;
    const currentGlobals = (_a = store2.getState()) == null ? void 0 : _a.globals;
    if (!(0, import_dequal3.dequal)(globals, currentGlobals)) {
      store2.setState({ globals });
    }
  };
  const initModule = () => {
    fullAPI.on(import_core_events6.GLOBALS_UPDATED, function handleGlobalsUpdated({ globals }) {
      const { ref } = getEventMetadata(this, fullAPI);
      if (!ref) {
        updateGlobals(globals);
      } else {
        import_client_logger6.logger.warn(
          "received a GLOBALS_UPDATED from a non-local ref. This is not currently supported."
        );
      }
    });
    fullAPI.on(import_core_events6.SET_GLOBALS, function handleSetStories({ globals, globalTypes }) {
      var _a;
      const { ref } = getEventMetadata(this, fullAPI);
      const currentGlobals = (_a = store2.getState()) == null ? void 0 : _a.globals;
      if (!ref) {
        store2.setState({ globals, globalTypes });
      } else if (Object.keys(globals).length > 0) {
        import_client_logger6.logger.warn("received globals from a non-local ref. This is not currently supported.");
      }
      if (currentGlobals && Object.keys(currentGlobals).length !== 0 && !(0, import_dequal3.dequal)(globals, currentGlobals)) {
        api.updateGlobals(currentGlobals);
      }
    });
  };
  return {
    api,
    state,
    init: initModule
  };
};

// src/index.tsx
var { ActiveTabs: ActiveTabs2 } = layout_exports;
var ManagerContext = createContext({ api: void 0, state: initial_state_default({}) });
var combineParameters = (...parameterSets) => (0, import_mergeWith2.default)({}, ...parameterSets, (objValue, srcValue) => {
  if (Array.isArray(srcValue))
    return srcValue;
  return void 0;
});
var ManagerProvider = class extends import_react2.Component {
  constructor(props) {
    super(props);
    this.api = {};
    this.initModules = () => {
      this.modules.forEach((module2) => {
        if ("init" in module2) {
          module2.init();
        }
      });
    };
    const {
      location: location2,
      path,
      refId,
      viewMode = props.docsOptions.docsMode ? "docs" : "story",
      singleStory,
      storyId,
      docsOptions,
      navigate
    } = props;
    const store2 = new Store({
      getState: () => this.state,
      setState: (stateChange, callback) => this.setState(stateChange, callback)
    });
    const routeData = { location: location2, path, viewMode, singleStory, storyId, refId };
    const optionsData = { docsOptions };
    this.state = store2.getInitialState(initial_state_default({ ...routeData, ...optionsData }));
    const apiData = {
      navigate,
      store: store2,
      provider: props.provider
    };
    this.modules = [
      provider_exports,
      channel_exports,
      addons_exports,
      layout_exports,
      notifications_exports,
      settings_exports,
      release_notes_exports,
      shortcuts_exports,
      stories_exports,
      refs_exports,
      globals_exports,
      url_exports,
      versions_exports
    ].map(
      (m) => m.init({ ...routeData, ...optionsData, ...apiData, state: this.state, fullAPI: this.api })
    );
    const state = initial_state_default(this.state, ...this.modules.map((m) => m.state));
    const api = Object.assign(this.api, { navigate }, ...this.modules.map((m) => m.api));
    this.state = state;
    this.api = api;
  }
  static getDerivedStateFromProps(props, state) {
    if (state.path !== props.path) {
      return {
        ...state,
        location: props.location,
        path: props.path,
        refId: props.refId,
        viewMode: props.viewMode,
        storyId: props.storyId
      };
    }
    return null;
  }
  shouldComponentUpdate(nextProps, nextState) {
    const prevState = this.state;
    const prevProps = this.props;
    if (prevState !== nextState) {
      return true;
    }
    if (prevProps.path !== nextProps.path) {
      return true;
    }
    return false;
  }
  render() {
    const { children } = this.props;
    const value = {
      state: this.state,
      api: this.api
    };
    return /* @__PURE__ */ import_react2.default.createElement(EffectOnMount, {
      effect: this.initModules
    }, /* @__PURE__ */ import_react2.default.createElement(ManagerContext.Provider, {
      value
    }, /* @__PURE__ */ import_react2.default.createElement(ManagerConsumer, null, children)));
  }
};
ManagerProvider.displayName = "Manager";
var EffectOnMount = ({ children, effect }) => {
  import_react2.default.useEffect(effect, []);
  return children;
};
var defaultFilter = (c) => c;
function ManagerConsumer({
  filter = defaultFilter,
  children
}) {
  const c = (0, import_react2.useContext)(ManagerContext);
  const renderer = (0, import_react2.useRef)(children);
  const filterer = (0, import_react2.useRef)(filter);
  if (typeof renderer.current !== "function") {
    return /* @__PURE__ */ import_react2.default.createElement(import_react2.Fragment, null, renderer.current);
  }
  const data = filterer.current(c);
  const l = (0, import_react2.useMemo)(() => {
    return [...Object.entries(data).reduce((acc, keyval) => acc.concat(keyval), [])];
  }, [c.state]);
  return (0, import_react2.useMemo)(() => {
    const Child = renderer.current;
    return /* @__PURE__ */ import_react2.default.createElement(Child, {
      ...data
    });
  }, l);
}
function useStorybookState() {
  const { state } = (0, import_react2.useContext)(ManagerContext);
  return state;
}
function useStorybookApi() {
  const { api } = (0, import_react2.useContext)(ManagerContext);
  return api;
}
function orDefault(fromStore, defaultState2) {
  if (typeof fromStore === "undefined") {
    return defaultState2;
  }
  return fromStore;
}
var useChannel = (eventMap, deps = []) => {
  const api = useStorybookApi();
  (0, import_react2.useEffect)(() => {
    Object.entries(eventMap).forEach(([type, listener]) => api.on(type, listener));
    return () => {
      Object.entries(eventMap).forEach(([type, listener]) => api.off(type, listener));
    };
  }, deps);
  return api.emit;
};
function useStoryPrepared(storyId) {
  const api = useStorybookApi();
  return api.isPrepared(storyId);
}
function useParameter(parameterKey, defaultValue) {
  const api = useStorybookApi();
  const result = api.getCurrentParameter(parameterKey);
  return orDefault(result, defaultValue);
}
var addonStateCache = {};
function useSharedState(stateId, defaultState2) {
  const api = useStorybookApi();
  const existingState = api.getAddonState(stateId);
  const state = orDefault(
    existingState,
    addonStateCache[stateId] ? addonStateCache[stateId] : defaultState2
  );
  const setState = (s, options) => {
    if (addonStateCache[stateId]) {
      addonStateCache[stateId] = s;
    }
    api.setAddonState(stateId, s, options);
  };
  const allListeners = (0, import_react2.useMemo)(() => {
    const stateChangeHandlers = {
      [`${import_core_events7.SHARED_STATE_CHANGED}-client-${stateId}`]: (s) => setState(s),
      [`${import_core_events7.SHARED_STATE_SET}-client-${stateId}`]: (s) => setState(s)
    };
    const stateInitializationHandlers = {
      [import_core_events7.SET_STORIES]: () => {
        const currentState = api.getAddonState(stateId);
        if (currentState) {
          addonStateCache[stateId] = currentState;
          api.emit(`${import_core_events7.SHARED_STATE_SET}-manager-${stateId}`, currentState);
        } else if (addonStateCache[stateId]) {
          setState(addonStateCache[stateId]);
          api.emit(`${import_core_events7.SHARED_STATE_SET}-manager-${stateId}`, addonStateCache[stateId]);
        } else if (defaultState2 !== void 0) {
          setState(defaultState2);
          addonStateCache[stateId] = defaultState2;
          api.emit(`${import_core_events7.SHARED_STATE_SET}-manager-${stateId}`, defaultState2);
        }
      },
      [import_core_events7.STORY_CHANGED]: () => {
        const currentState = api.getAddonState(stateId);
        if (currentState !== void 0) {
          api.emit(`${import_core_events7.SHARED_STATE_SET}-manager-${stateId}`, currentState);
        }
      }
    };
    return {
      ...stateChangeHandlers,
      ...stateInitializationHandlers
    };
  }, [stateId]);
  const emit = useChannel(allListeners);
  return [
    state,
    (newStateOrMerger, options) => {
      setState(newStateOrMerger, options);
      emit(`${import_core_events7.SHARED_STATE_CHANGED}-manager-${stateId}`, newStateOrMerger);
    }
  ];
}
function useAddonState(addonId, defaultState2) {
  return useSharedState(addonId, defaultState2);
}
function useArgs() {
  const { getCurrentStoryData, updateStoryArgs, resetStoryArgs } = useStorybookApi();
  const data = getCurrentStoryData();
  const args = data.type === "story" ? data.args : {};
  const updateArgs = (0, import_react2.useCallback)(
    (newArgs) => updateStoryArgs(data, newArgs),
    [data, updateStoryArgs]
  );
  const resetArgs = (0, import_react2.useCallback)(
    (argNames) => resetStoryArgs(data, argNames),
    [data, resetStoryArgs]
  );
  return [args, updateArgs, resetArgs];
}
function useGlobals() {
  const api = useStorybookApi();
  return [api.getGlobals(), api.updateGlobals];
}
function useGlobalTypes() {
  return useStorybookApi().getGlobalTypes();
}
function useCurrentStory() {
  const { getCurrentStoryData } = useStorybookApi();
  return getCurrentStoryData();
}
function useArgTypes() {
  const current = useCurrentStory();
  return (current == null ? void 0 : current.type) === "story" && current.argTypes || {};
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ActiveTabs,
  Consumer,
  ManagerContext,
  Provider,
  combineParameters,
  merge,
  useAddonState,
  useArgTypes,
  useArgs,
  useChannel,
  useGlobalTypes,
  useGlobals,
  useParameter,
  useSharedState,
  useStoryPrepared,
  useStorybookApi,
  useStorybookState
});
