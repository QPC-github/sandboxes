import {
  __export,
  eventToShortcut,
  shortcutMatchesShortcut
} from "./chunk-EW7PSQ54.mjs";

// src/index.tsx
import React, {
  Component,
  Fragment,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef
} from "react";
import mergeWith2 from "lodash/mergeWith";
import {
  STORY_CHANGED as STORY_CHANGED2,
  SHARED_STATE_CHANGED,
  SHARED_STATE_SET,
  SET_STORIES as SET_STORIES2
} from "@storybook/core-events";

// src/context.ts
import { createContext as ReactCreateContext } from "react";
var createContext = ({ api, state }) => ReactCreateContext({ api, state });

// src/store.ts
import store from "store2";

// src/lib/store-setup.ts
import { parse, stringify } from "telejson";
var store_setup_default = (_) => {
  _.fn("set", function(key, data) {
    return _.set(this._area, this._in(key), stringify(data, { maxDepth: 50 }));
  });
  _.fn("get", function(key, alt) {
    const value = _.get(this._area, this._in(key));
    return value !== null ? parse(value) : alt || value;
  });
};

// src/store.ts
store_setup_default(store._);
var STORAGE_KEY = "@storybook/ui/store";
function get(storage) {
  const data = storage.get(STORAGE_KEY);
  return data || {};
}
function set(storage, value) {
  return storage.set(STORAGE_KEY, value);
}
function update(storage, patch) {
  const previous = get(storage);
  return set(storage, { ...previous, ...patch });
}
var Store = class {
  constructor({ setState, getState }) {
    this.upstreamSetState = setState;
    this.upstreamGetState = getState;
  }
  getInitialState(base) {
    return { ...base, ...get(store.local), ...get(store.session) };
  }
  getState() {
    return this.upstreamGetState();
  }
  async setState(inputPatch, cbOrOptions, inputOptions) {
    let callback;
    let options;
    if (typeof cbOrOptions === "function") {
      callback = cbOrOptions;
      options = inputOptions;
    } else {
      options = cbOrOptions;
    }
    const { persistence = "none" } = options || {};
    let patch = {};
    let delta = {};
    if (typeof inputPatch === "function") {
      patch = (state) => {
        const getDelta = inputPatch;
        delta = getDelta(state);
        return delta;
      };
    } else {
      patch = inputPatch;
      delta = patch;
    }
    const newState = await new Promise((resolve) => {
      this.upstreamSetState(patch, resolve);
    });
    if (persistence !== "none") {
      const storage = persistence === "session" ? store.session : store.local;
      await update(storage, delta);
    }
    if (callback) {
      callback(newState);
    }
    return newState;
  }
};

// src/lib/merge.ts
import mergeWith from "lodash/mergeWith";
import isEqual from "lodash/isEqual";
import { logger } from "@storybook/client-logger";
var merge_default = (a, b) => mergeWith({}, a, b, (objValue, srcValue) => {
  if (Array.isArray(srcValue) && Array.isArray(objValue)) {
    srcValue.forEach((s) => {
      const existing = objValue.find((o) => o === s || isEqual(o, s));
      if (!existing) {
        objValue.push(s);
      }
    });
    return objValue;
  }
  if (Array.isArray(objValue)) {
    logger.log(["the types mismatch, picking", objValue]);
    return objValue;
  }
  return void 0;
});

// src/initial-state.ts
var main = (...additions) => additions.reduce((acc, item) => merge_default(acc, item), {});
var initial_state_default = main;

// src/modules/provider.ts
var provider_exports = {};
__export(provider_exports, {
  init: () => init
});
var init = ({ provider, fullAPI }) => {
  return {
    api: provider.renderPreview ? { renderPreview: provider.renderPreview } : {},
    state: {},
    init: () => {
      provider.handleAPI(fullAPI);
    }
  };
};

// src/modules/addons.ts
var addons_exports = {};
__export(addons_exports, {
  ensurePanel: () => ensurePanel,
  init: () => init2,
  types: () => types
});
import deprecate from "util-deprecate";
import { dedent } from "ts-dedent";
var warnDisabledDeprecated = deprecate(
  () => {
  },
  dedent`
    Use 'parameters.key.disable' instead of 'parameters.key.disabled'.
    
    https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-disabled-parameter
  `
);
var types = /* @__PURE__ */ ((types2) => {
  types2["TAB"] = "tab";
  types2["PANEL"] = "panel";
  types2["TOOL"] = "tool";
  types2["PREVIEW"] = "preview";
  types2["NOTES_ELEMENT"] = "notes-element";
  return types2;
})(types || {});
function ensurePanel(panels, selectedPanel, currentPanel) {
  const keys2 = Object.keys(panels);
  if (keys2.indexOf(selectedPanel) >= 0) {
    return selectedPanel;
  }
  if (keys2.length) {
    return keys2[0];
  }
  return currentPanel;
}
var init2 = ({ provider, store: store2, fullAPI }) => {
  const api = {
    getElements: (type) => provider.getElements(type),
    getPanels: () => api.getElements("panel" /* PANEL */),
    getStoryPanels: () => {
      const allPanels = api.getPanels();
      const { storyId } = store2.getState();
      const story = fullAPI.getData(storyId);
      if (!allPanels || !story || story.type !== "story") {
        return allPanels;
      }
      const { parameters } = story;
      const filteredPanels = {};
      Object.entries(allPanels).forEach(([id, panel]) => {
        const { paramKey } = panel;
        if (paramKey && parameters && parameters[paramKey] && (parameters[paramKey].disabled || parameters[paramKey].disable)) {
          if (parameters[paramKey].disabled) {
            warnDisabledDeprecated();
          }
          return;
        }
        filteredPanels[id] = panel;
      });
      return filteredPanels;
    },
    getSelectedPanel: () => {
      const { selectedPanel } = store2.getState();
      return ensurePanel(api.getPanels(), selectedPanel, selectedPanel);
    },
    setSelectedPanel: (panelName) => {
      store2.setState({ selectedPanel: panelName }, { persistence: "session" });
    },
    setAddonState(addonId, newStateOrMerger, options) {
      let nextState;
      const { addons: existing } = store2.getState();
      if (typeof newStateOrMerger === "function") {
        const merger = newStateOrMerger;
        nextState = merger(api.getAddonState(addonId));
      } else {
        nextState = newStateOrMerger;
      }
      return store2.setState({ addons: { ...existing, [addonId]: nextState } }, options).then(() => api.getAddonState(addonId));
    },
    getAddonState: (addonId) => {
      return store2.getState().addons[addonId];
    }
  };
  return {
    api,
    state: {
      selectedPanel: ensurePanel(api.getPanels(), store2.getState().selectedPanel),
      addons: {}
    }
  };
};

// src/modules/channel.ts
var channel_exports = {};
__export(channel_exports, {
  init: () => init3
});
import { STORIES_COLLAPSE_ALL, STORIES_EXPAND_ALL } from "@storybook/core-events";
var init3 = ({ provider }) => {
  const api = {
    getChannel: () => provider.channel,
    on: (type, cb) => {
      provider.channel.addListener(type, cb);
      return () => provider.channel.removeListener(type, cb);
    },
    off: (type, cb) => provider.channel.removeListener(type, cb),
    once: (type, cb) => provider.channel.once(type, cb),
    emit: (type, data, ...args) => {
      if (data?.options?.target && data.options.target !== "storybook-preview-iframe" && !data.options.target.startsWith("storybook-ref-")) {
        data.options.target = data.options.target !== "storybook_internal" ? `storybook-ref-${data.options.target}` : "storybook-preview-iframe";
      }
      provider.channel.emit(type, data, ...args);
    },
    collapseAll: () => {
      provider.channel.emit(STORIES_COLLAPSE_ALL, {});
    },
    expandAll: () => {
      api.emit(STORIES_EXPAND_ALL);
    }
  };
  return { api, state: {} };
};

// src/modules/notifications.ts
var notifications_exports = {};
__export(notifications_exports, {
  init: () => init4
});
var init4 = ({ store: store2 }) => {
  const api = {
    addNotification: (notification) => {
      api.clearNotification(notification.id);
      const { notifications } = store2.getState();
      store2.setState({ notifications: [...notifications, notification] });
    },
    clearNotification: (id) => {
      const { notifications } = store2.getState();
      store2.setState({ notifications: notifications.filter((n) => n.id !== id) });
      const notification = notifications.find((n) => n.id === id);
      if (notification && notification.onClear) {
        notification.onClear();
      }
    }
  };
  const state = { notifications: [] };
  return { api, state };
};

// src/modules/settings.ts
var settings_exports = {};
__export(settings_exports, {
  init: () => init5
});
var init5 = ({ store: store2, navigate, fullAPI }) => {
  const isSettingsScreenActive = () => {
    const { path } = fullAPI.getUrlState();
    return !!(path || "").match(/^\/settings/);
  };
  const api = {
    closeSettings: () => {
      const {
        settings: { lastTrackedStoryId }
      } = store2.getState();
      if (lastTrackedStoryId) {
        fullAPI.selectStory(lastTrackedStoryId);
      } else {
        fullAPI.selectFirstStory();
      }
    },
    changeSettingsTab: (tab) => {
      navigate(`/settings/${tab}`);
    },
    isSettingsScreenActive,
    navigateToSettingsPage: async (path) => {
      if (!isSettingsScreenActive()) {
        const { settings, storyId } = store2.getState();
        await store2.setState({
          settings: { ...settings, lastTrackedStoryId: storyId }
        });
      }
      navigate(path);
    }
  };
  return { state: { settings: { lastTrackedStoryId: null } }, api };
};

// src/modules/release-notes.ts
var release_notes_exports = {};
__export(release_notes_exports, {
  init: () => init6
});
import global from "global";
import memoize from "memoizerific";
var { RELEASE_NOTES_DATA } = global;
var getReleaseNotesData = memoize(1)(() => {
  try {
    return { ...JSON.parse(RELEASE_NOTES_DATA) || {} };
  } catch (e) {
    return {};
  }
});
var init6 = ({ store: store2 }) => {
  const releaseNotesData = getReleaseNotesData();
  const getReleaseNotesViewed = () => {
    const { releaseNotesViewed: persistedReleaseNotesViewed } = store2.getState();
    return persistedReleaseNotesViewed || [];
  };
  const api = {
    releaseNotesVersion: () => releaseNotesData.currentVersion,
    setDidViewReleaseNotes: () => {
      const releaseNotesViewed = getReleaseNotesViewed();
      if (!releaseNotesViewed.includes(releaseNotesData.currentVersion)) {
        store2.setState(
          { releaseNotesViewed: [...releaseNotesViewed, releaseNotesData.currentVersion] },
          { persistence: "permanent" }
        );
      }
    },
    showReleaseNotesOnLaunch: () => {
      if (!releaseNotesData.currentVersion)
        return false;
      const releaseNotesViewed = getReleaseNotesViewed();
      const didViewReleaseNotes = releaseNotesViewed.includes(releaseNotesData.currentVersion);
      const showReleaseNotesOnLaunch = releaseNotesData.showOnFirstLaunch && !didViewReleaseNotes;
      return showReleaseNotesOnLaunch;
    }
  };
  return { state: { releaseNotesViewed: [] }, api };
};

// src/modules/stories.ts
var stories_exports = {};
__export(stories_exports, {
  init: () => init8
});
import global4 from "global";
import { toId as toId2, sanitize as sanitize2 } from "@storybook/csf";
import {
  PRELOAD_ENTRIES,
  STORY_PREPARED,
  UPDATE_STORY_ARGS,
  RESET_STORY_ARGS,
  STORY_ARGS_UPDATED,
  STORY_CHANGED,
  SELECT_STORY,
  SET_STORIES,
  STORY_SPECIFIED,
  STORY_INDEX_INVALIDATED,
  CONFIG_ERROR
} from "@storybook/core-events";
import deprecate3 from "util-deprecate";
import { logger as logger3 } from "@storybook/client-logger";

// src/lib/events.ts
import { logger as logger2 } from "@storybook/client-logger";

// src/modules/refs.ts
var refs_exports = {};
__export(refs_exports, {
  defaultStoryMapper: () => defaultStoryMapper,
  getSourceType: () => getSourceType,
  init: () => init7
});
import global3 from "global";
import { dedent as dedent3 } from "ts-dedent";

// src/lib/stories.ts
import memoize2 from "memoizerific";
import deprecate2 from "util-deprecate";
import { dedent as dedent2 } from "ts-dedent";
import mapValues from "lodash/mapValues";
import countBy from "lodash/countBy";
import global2 from "global";
import { toId, sanitize } from "@storybook/csf";
var { FEATURES } = global2;
var warnLegacyShowRoots = deprecate2(
  () => {
  },
  dedent2`
    The 'showRoots' config option is deprecated and will be removed in Storybook 7.0. Use 'sidebar.showRoots' instead.
    Read more about it in the migration guide: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md
  `
);
var warnChangedDefaultHierarchySeparators = deprecate2(
  () => {
  },
  dedent2`
    The default hierarchy separators changed in Storybook 6.0.
    '|' and '.' will no longer create a hierarchy, but codemods are available.
    Read more about it in the migration guide: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md
  `
);
var denormalizeStoryParameters = ({
  globalParameters,
  kindParameters,
  stories
}) => {
  return mapValues(stories, (storyData) => ({
    ...storyData,
    parameters: combineParameters(
      globalParameters,
      kindParameters[storyData.kind],
      storyData.parameters
    )
  }));
};
var TITLE_PATH_SEPARATOR = /\s*\/\s*/;
var transformSetStoriesStoryDataToStoriesHash = (data, { provider, docsOptions }) => transformStoryIndexToStoriesHash(
  transformSetStoriesStoryDataToPreparedStoryIndex(data, { docsOptions }),
  {
    provider,
    docsOptions
  }
);
var transformSetStoriesStoryDataToPreparedStoryIndex = (stories, { docsOptions }) => {
  const seenTitles = /* @__PURE__ */ new Set();
  const entries = Object.entries(stories).reduce(
    (acc, [id, story]) => {
      if (!story)
        return acc;
      const { docsOnly, fileName, ...parameters } = story.parameters;
      const base = {
        title: story.kind,
        id,
        name: story.name,
        importPath: fileName
      };
      if (docsOnly) {
        acc[id] = {
          type: "docs",
          storiesImports: [],
          ...base
        };
      } else {
        if (!seenTitles.has(base.title) && docsOptions.docsPage) {
          const name = docsOptions.defaultName;
          const docsId = toId(story.componentId || base.title, name);
          seenTitles.add(base.title);
          acc[docsId] = {
            type: "docs",
            storiesImports: [],
            ...base,
            id: docsId,
            name
          };
        }
        const { argTypes, args, initialArgs } = story;
        acc[id] = {
          type: "story",
          ...base,
          parameters,
          argTypes,
          args,
          initialArgs
        };
      }
      return acc;
    },
    {}
  );
  return { v: 4, entries };
};
var transformStoryIndexV3toV4 = (index) => {
  const countByTitle = countBy(Object.values(index.stories), "title");
  return {
    v: 4,
    entries: Object.values(index.stories).reduce((acc, entry) => {
      let type = "story";
      if (entry.parameters?.docsOnly || entry.name === "Page" && countByTitle[entry.title] === 1) {
        type = "docs";
      }
      acc[entry.id] = {
        type,
        ...type === "docs" && { storiesImports: [] },
        ...entry
      };
      return acc;
    }, {})
  };
};
var transformStoryIndexToStoriesHash = (index, {
  provider,
  docsOptions
}) => {
  if (!index.v)
    throw new Error("Composition: Missing stories.json version");
  const v4Index = index.v === 4 ? index : transformStoryIndexV3toV4(index);
  const entryValues = Object.values(v4Index.entries);
  const { sidebar = {}, showRoots: deprecatedShowRoots } = provider.getConfig();
  const { showRoots = deprecatedShowRoots, collapsedRoots = [], renderLabel } = sidebar;
  const usesOldHierarchySeparator = entryValues.some(({ title }) => title.match(/\.|\|/));
  if (typeof deprecatedShowRoots !== "undefined") {
    warnLegacyShowRoots();
  }
  const setShowRoots = typeof showRoots !== "undefined";
  if (usesOldHierarchySeparator && !setShowRoots && FEATURES?.warnOnLegacyHierarchySeparator) {
    warnChangedDefaultHierarchySeparators();
  }
  const storiesHashOutOfOrder = Object.values(entryValues).reduce((acc, item) => {
    if (docsOptions.docsMode && item.type !== "docs")
      return acc;
    const { title } = item;
    const groups = title.trim().split(TITLE_PATH_SEPARATOR);
    const root = (!setShowRoots || showRoots) && groups.length > 1 ? [groups.shift()] : [];
    const names = [...root, ...groups];
    const paths = names.reduce((list, name, idx) => {
      const parent = idx > 0 && list[idx - 1];
      const id = sanitize(parent ? `${parent}-${name}` : name);
      if (parent === id) {
        throw new Error(
          dedent2`
          Invalid part '${name}', leading to id === parentId ('${id}'), inside title '${title}'
          
          Did you create a path that uses the separator char accidentally, such as 'Vue <docs/>' where '/' is a separator char? See https://github.com/storybookjs/storybook/issues/6128
          `
        );
      }
      list.push(id);
      return list;
    }, []);
    paths.forEach((id, idx) => {
      const childId = paths[idx + 1] || item.id;
      if (root.length && idx === 0) {
        acc[id] = merge_default(acc[id] || {}, {
          type: "root",
          id,
          name: names[idx],
          depth: idx,
          renderLabel,
          startCollapsed: collapsedRoots.includes(id),
          children: [childId],
          isRoot: true,
          isComponent: false,
          isLeaf: false
        });
      } else if ((!acc[id] || acc[id].type === "component") && idx === paths.length - 1) {
        acc[id] = merge_default(acc[id] || {}, {
          type: "component",
          id,
          name: names[idx],
          parent: paths[idx - 1],
          depth: idx,
          renderLabel,
          ...childId && {
            children: [childId]
          },
          isRoot: false,
          isComponent: true,
          isLeaf: false
        });
      } else {
        acc[id] = merge_default(acc[id] || {}, {
          type: "group",
          id,
          name: names[idx],
          parent: paths[idx - 1],
          depth: idx,
          renderLabel,
          ...childId && {
            children: [childId]
          },
          isRoot: false,
          isComponent: false,
          isLeaf: false
        });
      }
    });
    acc[item.id] = {
      type: "story",
      ...item,
      depth: paths.length,
      parent: paths[paths.length - 1],
      renderLabel,
      ...item.type !== "docs" && { prepared: !!item.parameters },
      kind: item.title,
      isRoot: false,
      isComponent: false,
      isLeaf: true
    };
    return acc;
  }, {});
  function addItem(acc, item) {
    if (acc[item.id]) {
      return acc;
    }
    acc[item.id] = item;
    if (item.type === "root" || item.type === "group" || item.type === "component") {
      item.children.forEach((childId) => addItem(acc, storiesHashOutOfOrder[childId]));
    }
    return acc;
  }
  const orphanHash = Object.values(storiesHashOutOfOrder).filter((i) => i.type !== "root" && !i.parent).reduce(addItem, {});
  return Object.values(storiesHashOutOfOrder).filter((i) => i.type === "root").reduce(addItem, orphanHash);
};
var addPreparedStories = (newHash, oldHash) => {
  if (!oldHash)
    return newHash;
  return Object.fromEntries(
    Object.entries(newHash).map(([id, newEntry]) => {
      const oldEntry = oldHash[id];
      if (newEntry.type === "story" && oldEntry?.type === "story" && oldEntry.prepared) {
        return [id, { ...oldEntry, ...newEntry, prepared: true }];
      }
      return [id, newEntry];
    })
  );
};
var getComponentLookupList = memoize2(1)((hash) => {
  return Object.entries(hash).reduce((acc, i) => {
    const value = i[1];
    if (value.type === "component") {
      acc.push([...value.children]);
    }
    return acc;
  }, []);
});
var getStoriesLookupList = memoize2(1)((hash) => {
  return Object.keys(hash).filter((k) => ["story", "docs"].includes(hash[k].type));
});

// src/modules/refs.ts
var { location, fetch } = global3;
var findFilename = /(\/((?:[^\/]+?)\.[^\/]+?)|\/)$/;
var getSourceType = (source, refId) => {
  const { origin: localOrigin, pathname: localPathname } = location;
  const { origin: sourceOrigin, pathname: sourcePathname } = new URL(source);
  const localFull = `${localOrigin + localPathname}`.replace(findFilename, "");
  const sourceFull = `${sourceOrigin + sourcePathname}`.replace(findFilename, "");
  if (localFull === sourceFull) {
    return ["local", sourceFull];
  }
  if (refId || source) {
    return ["external", sourceFull];
  }
  return [null, null];
};
var defaultStoryMapper = (b, a) => {
  return { ...a, kind: a.kind.replace("|", "/") };
};
var addRefIds = (input, ref) => {
  return Object.entries(input).reduce((acc, [id, item]) => {
    return { ...acc, [id]: { ...item, refId: ref.id } };
  }, {});
};
async function handleRequest(request) {
  if (!request)
    return {};
  try {
    const response = await request;
    if (!response.ok)
      return {};
    const json = await response.json();
    if (json.entries || json.stories) {
      return { storyIndex: json };
    }
    return json;
  } catch (error) {
    return { error };
  }
}
var map = (input, ref, options) => {
  const { storyMapper } = options;
  if (storyMapper) {
    return Object.entries(input).reduce((acc, [id, item]) => {
      return { ...acc, [id]: storyMapper(ref, item) };
    }, {});
  }
  return input;
};
var init7 = ({ store: store2, provider, singleStory, docsOptions = {} }, { runCheck = true } = {}) => {
  const api = {
    findRef: (source) => {
      const refs2 = api.getRefs();
      return Object.values(refs2).find(({ url }) => url.match(source));
    },
    changeRefVersion: (id, url) => {
      const { versions, title } = api.getRefs()[id];
      const ref = { id, url, versions, title, stories: {} };
      api.checkRef(ref);
    },
    changeRefState: (id, ready) => {
      const { [id]: ref, ...updated } = api.getRefs();
      updated[id] = { ...ref, ready };
      store2.setState({
        refs: updated
      });
    },
    checkRef: async (ref) => {
      const { id, url, version: version2, type } = ref;
      const isPublic = type === "server-checked";
      const loadedData = {};
      const query = version2 ? `?version=${version2}` : "";
      const credentials = isPublic ? "omit" : "include";
      const [indexFetch, storiesFetch] = await Promise.all(
        ["index.json", "stories.json"].map(
          async (file) => fetch(`${url}/${file}${query}`, {
            headers: { Accept: "application/json" },
            credentials
          })
        )
      );
      if (indexFetch.ok || storiesFetch.ok) {
        const [index, metadata] = await Promise.all([
          indexFetch.ok ? handleRequest(indexFetch) : handleRequest(storiesFetch),
          handleRequest(
            fetch(`${url}/metadata.json${query}`, {
              headers: {
                Accept: "application/json"
              },
              credentials,
              cache: "no-cache"
            }).catch(() => false)
          )
        ]);
        Object.assign(loadedData, { ...index, ...metadata });
      } else if (!isPublic) {
        loadedData.error = {
          message: dedent3`
            Error: Loading of ref failed
              at fetch (lib/api/src/modules/refs.ts)

            URL: ${url}

            We weren't able to load the above URL,
            it's possible a CORS error happened.

            Please check your dev-tools network tab.
          `
        };
      }
      const versions = ref.versions && Object.keys(ref.versions).length ? ref.versions : loadedData.versions;
      await api.setRef(id, {
        id,
        url,
        ...loadedData,
        ...versions ? { versions } : {},
        type: !loadedData.storyIndex ? "auto-inject" : "lazy"
      });
    },
    getRefs: () => {
      const { refs: refs2 = {} } = store2.getState();
      return refs2;
    },
    setRef: (id, { storyIndex, setStoriesData, ...rest }, ready = false) => {
      if (singleStory) {
        return;
      }
      const { storyMapper = defaultStoryMapper } = provider.getConfig();
      const ref = api.getRefs()[id];
      let storiesHash;
      if (setStoriesData) {
        storiesHash = transformSetStoriesStoryDataToStoriesHash(
          map(setStoriesData, ref, { storyMapper }),
          { provider, docsOptions }
        );
      } else if (storyIndex) {
        storiesHash = transformStoryIndexToStoriesHash(storyIndex, { provider, docsOptions });
      }
      if (storiesHash)
        storiesHash = addRefIds(storiesHash, ref);
      api.updateRef(id, { stories: storiesHash, ...rest, ready });
    },
    updateRef: (id, data) => {
      const { [id]: ref, ...updated } = api.getRefs();
      updated[id] = { ...ref, ...data };
      const ordered = Object.keys(initialState).reduce((obj, key) => {
        obj[key] = updated[key];
        return obj;
      }, {});
      store2.setState({
        refs: ordered
      });
    }
  };
  const refs = !singleStory && global3.REFS || {};
  const initialState = refs;
  if (runCheck) {
    Object.entries(refs).forEach(([id, ref]) => {
      api.checkRef({ ...ref, stories: {} });
    });
  }
  return {
    api,
    state: {
      refs: initialState
    }
  };
};

// src/lib/events.ts
var getEventMetadata = (context, fullAPI) => {
  const { source, refId, type } = context;
  const [sourceType, sourceLocation] = getSourceType(source, refId);
  const ref = refId && fullAPI.getRefs()[refId] ? fullAPI.getRefs()[refId] : fullAPI.findRef(sourceLocation);
  const meta = {
    source,
    sourceType,
    sourceLocation,
    refId,
    ref,
    type
  };
  switch (true) {
    case typeof refId === "string":
    case sourceType === "local":
    case sourceType === "external": {
      return meta;
    }
    default: {
      logger2.warn(`Received a ${type} frame that was not configured as a ref`);
      return null;
    }
  }
};

// src/modules/stories.ts
var { FEATURES: FEATURES2, fetch: fetch2 } = global4;
var STORY_INDEX_PATH = "./index.json";
var deprecatedOptionsParameterWarnings = [
  "enableShortcuts",
  "theme",
  "showRoots"
].reduce((acc, option) => {
  acc[option] = deprecate3(
    () => {
    },
    `parameters.options.${option} is deprecated and will be removed in Storybook 7.0.
To change this setting, use \`addons.setConfig\`. See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-immutable-options-parameters
  `
  );
  return acc;
}, {});
function checkDeprecatedOptionParameters(options) {
  if (!options) {
    return;
  }
  Object.keys(options).forEach((option) => {
    if (deprecatedOptionsParameterWarnings[option]) {
      deprecatedOptionsParameterWarnings[option]();
    }
  });
}
var init8 = ({
  fullAPI,
  store: store2,
  navigate,
  provider,
  storyId: initialStoryId,
  viewMode: initialViewMode,
  docsOptions = {}
}) => {
  const api = {
    storyId: toId2,
    getData: (storyId, refId) => {
      const result = api.resolveStory(storyId, refId);
      if (result?.type === "story" || result?.type === "docs") {
        return result;
      }
      return void 0;
    },
    isPrepared: (storyId, refId) => {
      const data = api.getData(storyId, refId);
      return data.type === "story" ? data.prepared : true;
    },
    resolveStory: (storyId, refId) => {
      const { refs, storiesHash } = store2.getState();
      if (refId) {
        return refs[refId].stories ? refs[refId].stories[storyId] : void 0;
      }
      return storiesHash ? storiesHash[storyId] : void 0;
    },
    getCurrentStoryData: () => {
      const { storyId, refId } = store2.getState();
      return api.getData(storyId, refId);
    },
    getParameters: (storyIdOrCombo, parameterName) => {
      const { storyId, refId } = typeof storyIdOrCombo === "string" ? { storyId: storyIdOrCombo, refId: void 0 } : storyIdOrCombo;
      const data = api.getData(storyId, refId);
      if (data?.type === "story") {
        const { parameters } = data;
        if (parameters) {
          return parameterName ? parameters[parameterName] : parameters;
        }
      }
      return null;
    },
    getCurrentParameter: (parameterName) => {
      const { storyId, refId } = store2.getState();
      const parameters = api.getParameters({ storyId, refId }, parameterName);
      return parameters || void 0;
    },
    jumpToComponent: (direction) => {
      const { storiesHash, storyId, refs, refId } = store2.getState();
      const story = api.getData(storyId, refId);
      if (!story) {
        return;
      }
      const hash = refId ? refs[refId].stories || {} : storiesHash;
      const result = api.findSiblingStoryId(storyId, hash, direction, true);
      if (result) {
        api.selectStory(result, void 0, { ref: refId });
      }
    },
    jumpToStory: (direction) => {
      const { storiesHash, storyId, refs, refId } = store2.getState();
      const story = api.getData(storyId, refId);
      if (!story) {
        return;
      }
      const hash = story.refId ? refs[story.refId].stories : storiesHash;
      const result = api.findSiblingStoryId(storyId, hash, direction, false);
      if (result) {
        api.selectStory(result, void 0, { ref: refId });
      }
    },
    setStories: async (input, error) => {
      const hash = transformSetStoriesStoryDataToStoriesHash(input, {
        provider,
        docsOptions
      });
      await store2.setState({
        storiesHash: hash,
        storiesConfigured: true,
        storiesFailed: error
      });
    },
    selectFirstStory: () => {
      const { storiesHash } = store2.getState();
      const firstStory = Object.keys(storiesHash).find((id) => storiesHash[id].type === "story");
      if (firstStory) {
        api.selectStory(firstStory);
        return;
      }
      navigate("/");
    },
    selectStory: (titleOrId = void 0, name = void 0, options = {}) => {
      const { ref } = options;
      const { storyId, storiesHash, refs } = store2.getState();
      const hash = ref ? refs[ref].stories : storiesHash;
      const kindSlug = storyId?.split("--", 2)[0];
      if (!name) {
        const entry = titleOrId ? hash[titleOrId] || hash[sanitize2(titleOrId)] : hash[kindSlug];
        if (!entry)
          throw new Error(`Unknown id or title: '${titleOrId}'`);
        const leafEntry = api.findLeafEntry(hash, entry.id);
        const fullId = leafEntry.refId ? `${leafEntry.refId}_${leafEntry.id}` : leafEntry.id;
        navigate(`/${leafEntry.type}/${fullId}`);
      } else if (!titleOrId) {
        const id = toId2(kindSlug, name);
        api.selectStory(id, void 0, options);
      } else {
        const id = ref ? `${ref}_${toId2(titleOrId, name)}` : toId2(titleOrId, name);
        if (hash[id]) {
          api.selectStory(id, void 0, options);
        } else {
          const entry = hash[sanitize2(titleOrId)];
          if (entry?.type === "component") {
            const foundId = entry.children.find((childId) => hash[childId].name === name);
            if (foundId) {
              api.selectStory(foundId, void 0, options);
            }
          }
        }
      }
    },
    findLeafEntry(storiesHash, storyId) {
      const entry = storiesHash[storyId];
      if (entry.type === "docs" || entry.type === "story") {
        return entry;
      }
      const childStoryId = entry.children[0];
      return api.findLeafEntry(storiesHash, childStoryId);
    },
    findLeafStoryId(storiesHash, storyId) {
      return api.findLeafEntry(storiesHash, storyId)?.id;
    },
    findSiblingStoryId(storyId, hash, direction, toSiblingGroup) {
      if (toSiblingGroup) {
        const lookupList2 = getComponentLookupList(hash);
        const index2 = lookupList2.findIndex((i) => i.includes(storyId));
        if (index2 === lookupList2.length - 1 && direction > 0) {
          return;
        }
        if (index2 === 0 && direction < 0) {
          return;
        }
        if (lookupList2[index2 + direction]) {
          return lookupList2[index2 + direction][0];
        }
        return;
      }
      const lookupList = getStoriesLookupList(hash);
      const index = lookupList.indexOf(storyId);
      if (index === lookupList.length - 1 && direction > 0) {
        return;
      }
      if (index === 0 && direction < 0) {
        return;
      }
      return lookupList[index + direction];
    },
    updateStoryArgs: (story, updatedArgs) => {
      const { id: storyId, refId } = story;
      fullAPI.emit(UPDATE_STORY_ARGS, {
        storyId,
        updatedArgs,
        options: { target: refId }
      });
    },
    resetStoryArgs: (story, argNames) => {
      const { id: storyId, refId } = story;
      fullAPI.emit(RESET_STORY_ARGS, {
        storyId,
        argNames,
        options: { target: refId }
      });
    },
    fetchStoryList: async () => {
      try {
        const result = await fetch2(STORY_INDEX_PATH);
        if (result.status !== 200)
          throw new Error(await result.text());
        const storyIndex = await result.json();
        if (storyIndex.v < 3) {
          logger3.warn(`Skipping story index with version v${storyIndex.v}, awaiting SET_STORIES.`);
          return;
        }
        await fullAPI.setStoryList(storyIndex);
      } catch (err) {
        store2.setState({
          storiesConfigured: true,
          storiesFailed: err
        });
      }
    },
    setStoryList: async (storyIndex) => {
      const newHash = transformStoryIndexToStoriesHash(storyIndex, {
        provider,
        docsOptions
      });
      const oldHash = store2.getState().storiesHash;
      await store2.setState({
        storiesHash: addPreparedStories(newHash, oldHash),
        storiesConfigured: true,
        storiesFailed: null
      });
    },
    updateStory: async (storyId, update2, ref) => {
      if (!ref) {
        const { storiesHash } = store2.getState();
        storiesHash[storyId] = {
          ...storiesHash[storyId],
          ...update2
        };
        await store2.setState({ storiesHash });
      } else {
        const { id: refId, stories } = ref;
        stories[storyId] = {
          ...stories[storyId],
          ...update2
        };
        await fullAPI.updateRef(refId, { stories });
      }
    }
  };
  const initModule = async () => {
    fullAPI.on(
      STORY_SPECIFIED,
      function handler({
        storyId,
        viewMode
      }) {
        const { sourceType } = getEventMetadata(this, fullAPI);
        if (fullAPI.isSettingsScreenActive())
          return;
        if (sourceType === "local") {
          const state = store2.getState();
          if (state.storyId !== storyId || state.viewMode !== viewMode) {
            navigate(`/${viewMode}/${storyId}`);
          }
        }
      }
    );
    fullAPI.on(STORY_CHANGED, function handler() {
      const { sourceType } = getEventMetadata(this, fullAPI);
      if (sourceType === "local") {
        const options = fullAPI.getCurrentParameter("options");
        if (options) {
          checkDeprecatedOptionParameters(options);
          fullAPI.setOptions(options);
        }
      }
    });
    fullAPI.on(STORY_PREPARED, function handler({ id, ...update2 }) {
      const { ref, sourceType } = getEventMetadata(this, fullAPI);
      fullAPI.updateStory(id, { ...update2, prepared: true }, ref);
      if (!ref) {
        if (!store2.getState().hasCalledSetOptions) {
          const { options } = update2.parameters;
          checkDeprecatedOptionParameters(options);
          fullAPI.setOptions(options);
          store2.setState({ hasCalledSetOptions: true });
        }
      } else {
        fullAPI.updateRef(ref.id, { ready: true });
      }
      if (sourceType === "local") {
        const { storyId, storiesHash, refId } = store2.getState();
        const toBePreloaded = Array.from(
          /* @__PURE__ */ new Set([
            api.findSiblingStoryId(storyId, storiesHash, 1, true),
            api.findSiblingStoryId(storyId, storiesHash, -1, true)
          ])
        ).filter(Boolean);
        fullAPI.emit(PRELOAD_ENTRIES, {
          ids: toBePreloaded,
          options: { target: refId }
        });
      }
    });
    fullAPI.on(SET_STORIES, function handler(data) {
      const { ref } = getEventMetadata(this, fullAPI);
      const setStoriesData = data.v ? denormalizeStoryParameters(data) : data.stories;
      if (!ref) {
        if (!data.v) {
          throw new Error("Unexpected legacy SET_STORIES event from local source");
        }
        fullAPI.setStories(setStoriesData);
        const options = fullAPI.getCurrentParameter("options");
        checkDeprecatedOptionParameters(options);
        fullAPI.setOptions(options);
      } else {
        fullAPI.setRef(ref.id, { ...ref, setStoriesData }, true);
      }
    });
    fullAPI.on(
      SELECT_STORY,
      function handler({
        kind,
        story,
        storyId,
        ...rest
      }) {
        const { ref } = getEventMetadata(this, fullAPI);
        if (!ref) {
          fullAPI.selectStory(storyId || kind, story, rest);
        } else {
          fullAPI.selectStory(storyId || kind, story, { ...rest, ref: ref.id });
        }
      }
    );
    fullAPI.on(
      STORY_ARGS_UPDATED,
      function handleStoryArgsUpdated({ storyId, args }) {
        const { ref } = getEventMetadata(this, fullAPI);
        fullAPI.updateStory(storyId, { args }, ref);
      }
    );
    fullAPI.on(CONFIG_ERROR, function handleConfigError(err) {
      store2.setState({
        storiesConfigured: true,
        storiesFailed: err
      });
    });
    if (FEATURES2?.storyStoreV7) {
      provider.serverChannel?.on(STORY_INDEX_INVALIDATED, () => fullAPI.fetchStoryList());
      await fullAPI.fetchStoryList();
    }
  };
  return {
    api,
    state: {
      storiesHash: {},
      storyId: initialStoryId,
      viewMode: initialViewMode,
      storiesConfigured: false,
      hasCalledSetOptions: false
    },
    init: initModule
  };
};

// src/modules/layout.ts
var layout_exports = {};
__export(layout_exports, {
  ActiveTabs: () => ActiveTabs,
  focusableUIElements: () => focusableUIElements,
  init: () => init9
});
import global5 from "global";
import pick from "lodash/pick";
import { dequal as deepEqual } from "dequal";
import { create } from "@storybook/theming/create";
import { SET_CONFIG } from "@storybook/core-events";
import { once } from "@storybook/client-logger";
import { dedent as dedent4 } from "ts-dedent";
var { document } = global5;
var ActiveTabs = {
  SIDEBAR: "sidebar",
  CANVAS: "canvas",
  ADDONS: "addons"
};
var defaultState = {
  ui: {
    enableShortcuts: true
  },
  layout: {
    initialActive: ActiveTabs.CANVAS,
    showToolbar: true,
    isFullscreen: false,
    showPanel: true,
    showNav: true,
    panelPosition: "bottom",
    showTabs: true
  },
  selectedPanel: void 0,
  theme: create()
};
var focusableUIElements = {
  storySearchField: "storybook-explorer-searchfield",
  storyListMenu: "storybook-explorer-menu",
  storyPanelRoot: "storybook-panel-root"
};
var init9 = ({ store: store2, provider, singleStory, fullAPI }) => {
  const api = {
    toggleFullscreen(toggled) {
      return store2.setState(
        (state) => {
          const { showNav } = state.layout;
          const value = typeof toggled === "boolean" ? toggled : !state.layout.isFullscreen;
          const shouldShowNav = showNav === false && value === false;
          return {
            layout: {
              ...state.layout,
              isFullscreen: value,
              showNav: !singleStory && shouldShowNav ? true : showNav
            }
          };
        },
        { persistence: "session" }
      );
    },
    togglePanel(toggled) {
      return store2.setState(
        (state) => {
          const { showNav, isFullscreen } = state.layout;
          const value = typeof toggled !== "undefined" ? toggled : !state.layout.showPanel;
          const shouldToggleFullScreen = showNav === false && value === false;
          return {
            layout: {
              ...state.layout,
              showPanel: value,
              isFullscreen: shouldToggleFullScreen ? true : isFullscreen
            }
          };
        },
        { persistence: "session" }
      );
    },
    togglePanelPosition(position) {
      if (typeof position !== "undefined") {
        return store2.setState(
          (state) => ({
            layout: {
              ...state.layout,
              panelPosition: position
            }
          }),
          { persistence: "permanent" }
        );
      }
      return store2.setState(
        (state) => ({
          layout: {
            ...state.layout,
            panelPosition: state.layout.panelPosition === "right" ? "bottom" : "right"
          }
        }),
        { persistence: "permanent" }
      );
    },
    toggleNav(toggled) {
      return store2.setState(
        (state) => {
          if (singleStory)
            return { layout: state.layout };
          const { showPanel, isFullscreen } = state.layout;
          const showNav = typeof toggled !== "undefined" ? toggled : !state.layout.showNav;
          const shouldToggleFullScreen = showPanel === false && showNav === false;
          return {
            layout: {
              ...state.layout,
              showNav,
              isFullscreen: shouldToggleFullScreen ? true : !showNav && isFullscreen
            }
          };
        },
        { persistence: "session" }
      );
    },
    toggleToolbar(toggled) {
      return store2.setState(
        (state) => {
          const value = typeof toggled !== "undefined" ? toggled : !state.layout.showToolbar;
          return {
            layout: {
              ...state.layout,
              showToolbar: value
            }
          };
        },
        { persistence: "session" }
      );
    },
    resetLayout() {
      return store2.setState(
        (state) => {
          return {
            layout: {
              ...state.layout,
              showNav: false,
              showPanel: false,
              isFullscreen: false
            }
          };
        },
        { persistence: "session" }
      );
    },
    focusOnUIElement(elementId, select) {
      if (!elementId) {
        return;
      }
      const element = document.getElementById(elementId);
      if (element) {
        element.focus();
        if (select)
          element.select();
      }
    },
    getInitialOptions() {
      const { theme, selectedPanel, ...options } = provider.getConfig();
      if (options.layout?.isToolshown !== void 0) {
        once.warn(dedent4`
          The "isToolshown" option is deprecated. Please use "showToolbar" instead.

          See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#renamed-istoolshown-to-showtoolbar
        `);
        options.layout.showToolbar = options.layout.isToolshown;
      }
      return {
        ...defaultState,
        layout: {
          ...defaultState.layout,
          ...pick(options, Object.keys(defaultState.layout)),
          ...singleStory && { showNav: false }
        },
        ui: {
          ...defaultState.ui,
          ...pick(options, Object.keys(defaultState.ui))
        },
        selectedPanel: selectedPanel || defaultState.selectedPanel,
        theme: theme || defaultState.theme
      };
    },
    setOptions: (options) => {
      const { layout, ui, selectedPanel, theme } = store2.getState();
      if (options) {
        const updatedLayout = {
          ...layout,
          ...pick(options, Object.keys(layout)),
          ...singleStory && { showNav: false }
        };
        const updatedUi = {
          ...ui,
          ...pick(options, Object.keys(ui))
        };
        const updatedTheme = {
          ...theme,
          ...options.theme
        };
        const modification = {};
        if (!deepEqual(ui, updatedUi)) {
          modification.ui = updatedUi;
        }
        if (!deepEqual(layout, updatedLayout)) {
          modification.layout = updatedLayout;
        }
        if (options.selectedPanel && !deepEqual(selectedPanel, options.selectedPanel)) {
          modification.selectedPanel = options.selectedPanel;
        }
        if (Object.keys(modification).length) {
          store2.setState(modification, { persistence: "permanent" });
        }
        if (!deepEqual(theme, updatedTheme)) {
          store2.setState({ theme: updatedTheme });
        }
      }
    }
  };
  const persisted = pick(store2.getState(), "layout", "ui", "selectedPanel");
  return {
    api,
    state: merge_default(api.getInitialOptions(), persisted),
    init: () => {
      api.setOptions(merge_default(api.getInitialOptions(), persisted));
      fullAPI.on(SET_CONFIG, () => {
        api.setOptions(merge_default(api.getInitialOptions(), persisted));
      });
    }
  };
};

// src/modules/shortcuts.ts
var shortcuts_exports = {};
__export(shortcuts_exports, {
  controlOrMetaKey: () => controlOrMetaKey,
  defaultShortcuts: () => defaultShortcuts,
  init: () => init10,
  isMacLike: () => isMacLike,
  keys: () => keys
});
import global6 from "global";
import { PREVIEW_KEYDOWN } from "@storybook/core-events";
var { navigator, document: document2 } = global6;
var isMacLike = () => navigator && navigator.platform ? !!navigator.platform.match(/(Mac|iPhone|iPod|iPad)/i) : false;
var controlOrMetaKey = () => isMacLike() ? "meta" : "control";
function keys(o) {
  return Object.keys(o);
}
var defaultShortcuts = Object.freeze({
  fullScreen: ["F"],
  togglePanel: ["A"],
  panelPosition: ["D"],
  toggleNav: ["S"],
  toolbar: ["T"],
  search: ["/"],
  focusNav: ["1"],
  focusIframe: ["2"],
  focusPanel: ["3"],
  prevComponent: ["alt", "ArrowUp"],
  nextComponent: ["alt", "ArrowDown"],
  prevStory: ["alt", "ArrowLeft"],
  nextStory: ["alt", "ArrowRight"],
  shortcutsPage: [controlOrMetaKey(), "shift", ","],
  aboutPage: [","],
  escape: ["escape"],
  collapseAll: [controlOrMetaKey(), "shift", "ArrowUp"],
  expandAll: [controlOrMetaKey(), "shift", "ArrowDown"]
});
var addonsShortcuts = {};
function focusInInput(event) {
  return /input|textarea/i.test(event.target.tagName) || event.target.getAttribute("contenteditable") !== null;
}
var init10 = ({ store: store2, fullAPI }) => {
  const api = {
    getShortcutKeys() {
      return store2.getState().shortcuts;
    },
    getDefaultShortcuts() {
      return {
        ...defaultShortcuts,
        ...api.getAddonsShortcutDefaults()
      };
    },
    getAddonsShortcuts() {
      return addonsShortcuts;
    },
    getAddonsShortcutLabels() {
      const labels = {};
      Object.entries(api.getAddonsShortcuts()).forEach(([actionName, { label }]) => {
        labels[actionName] = label;
      });
      return labels;
    },
    getAddonsShortcutDefaults() {
      const defaults = {};
      Object.entries(api.getAddonsShortcuts()).forEach(([actionName, { defaultShortcut }]) => {
        defaults[actionName] = defaultShortcut;
      });
      return defaults;
    },
    async setShortcuts(shortcuts) {
      await store2.setState({ shortcuts }, { persistence: "permanent" });
      return shortcuts;
    },
    async restoreAllDefaultShortcuts() {
      return api.setShortcuts(api.getDefaultShortcuts());
    },
    async setShortcut(action, value) {
      const shortcuts = api.getShortcutKeys();
      await api.setShortcuts({ ...shortcuts, [action]: value });
      return value;
    },
    async setAddonShortcut(addon, shortcut) {
      const shortcuts = api.getShortcutKeys();
      await api.setShortcuts({
        ...shortcuts,
        [`${addon}-${shortcut.actionName}`]: shortcut.defaultShortcut
      });
      addonsShortcuts[`${addon}-${shortcut.actionName}`] = shortcut;
      return shortcut;
    },
    async restoreDefaultShortcut(action) {
      const defaultShortcut = api.getDefaultShortcuts()[action];
      return api.setShortcut(action, defaultShortcut);
    },
    handleKeydownEvent(event) {
      const shortcut = eventToShortcut(event);
      const shortcuts = api.getShortcutKeys();
      const actions = keys(shortcuts);
      const matchedFeature = actions.find(
        (feature) => shortcutMatchesShortcut(shortcut, shortcuts[feature])
      );
      if (matchedFeature) {
        if (event?.preventDefault)
          event.preventDefault();
        api.handleShortcutFeature(matchedFeature);
      }
    },
    handleShortcutFeature(feature) {
      const {
        layout: { isFullscreen, showNav, showPanel },
        ui: { enableShortcuts }
      } = store2.getState();
      if (!enableShortcuts) {
        return;
      }
      switch (feature) {
        case "escape": {
          if (isFullscreen) {
            fullAPI.toggleFullscreen();
          } else if (!showNav) {
            fullAPI.toggleNav();
          }
          break;
        }
        case "focusNav": {
          if (isFullscreen) {
            fullAPI.toggleFullscreen();
          }
          if (!showNav) {
            fullAPI.toggleNav();
          }
          fullAPI.focusOnUIElement(focusableUIElements.storyListMenu);
          break;
        }
        case "search": {
          if (isFullscreen) {
            fullAPI.toggleFullscreen();
          }
          if (!showNav) {
            fullAPI.toggleNav();
          }
          setTimeout(() => {
            fullAPI.focusOnUIElement(focusableUIElements.storySearchField, true);
          }, 0);
          break;
        }
        case "focusIframe": {
          const element = document2.getElementById("storybook-preview-iframe");
          if (element) {
            try {
              element.contentWindow.focus();
            } catch (e) {
            }
          }
          break;
        }
        case "focusPanel": {
          if (isFullscreen) {
            fullAPI.toggleFullscreen();
          }
          if (!showPanel) {
            fullAPI.togglePanel();
          }
          fullAPI.focusOnUIElement(focusableUIElements.storyPanelRoot);
          break;
        }
        case "nextStory": {
          fullAPI.jumpToStory(1);
          break;
        }
        case "prevStory": {
          fullAPI.jumpToStory(-1);
          break;
        }
        case "nextComponent": {
          fullAPI.jumpToComponent(1);
          break;
        }
        case "prevComponent": {
          fullAPI.jumpToComponent(-1);
          break;
        }
        case "fullScreen": {
          fullAPI.toggleFullscreen();
          break;
        }
        case "togglePanel": {
          if (isFullscreen) {
            fullAPI.toggleFullscreen();
            fullAPI.resetLayout();
          }
          fullAPI.togglePanel();
          break;
        }
        case "toggleNav": {
          if (isFullscreen) {
            fullAPI.toggleFullscreen();
            fullAPI.resetLayout();
          }
          fullAPI.toggleNav();
          break;
        }
        case "toolbar": {
          fullAPI.toggleToolbar();
          break;
        }
        case "panelPosition": {
          if (isFullscreen) {
            fullAPI.toggleFullscreen();
          }
          if (!showPanel) {
            fullAPI.togglePanel();
          }
          fullAPI.togglePanelPosition();
          break;
        }
        case "aboutPage": {
          fullAPI.navigate("/settings/about");
          break;
        }
        case "shortcutsPage": {
          fullAPI.navigate("/settings/shortcuts");
          break;
        }
        case "collapseAll": {
          fullAPI.collapseAll();
          break;
        }
        case "expandAll": {
          fullAPI.expandAll();
          break;
        }
        default:
          addonsShortcuts[feature].action();
          break;
      }
    }
  };
  const { shortcuts: persistedShortcuts = defaultShortcuts } = store2.getState();
  const state = {
    shortcuts: keys(defaultShortcuts).reduce(
      (acc, key) => ({ ...acc, [key]: persistedShortcuts[key] || defaultShortcuts[key] }),
      defaultShortcuts
    )
  };
  const initModule = () => {
    document2.addEventListener("keydown", (event) => {
      if (!focusInInput(event)) {
        fullAPI.handleKeydownEvent(event);
      }
    });
    fullAPI.on(PREVIEW_KEYDOWN, (data) => {
      fullAPI.handleKeydownEvent(data.event);
    });
  };
  return { api, state, init: initModule };
};

// src/modules/url.ts
var url_exports = {};
__export(url_exports, {
  init: () => init11
});
import { once as once2 } from "@storybook/client-logger";
import {
  NAVIGATE_URL,
  STORY_ARGS_UPDATED as STORY_ARGS_UPDATED2,
  SET_CURRENT_STORY,
  GLOBALS_UPDATED,
  UPDATE_QUERY_PARAMS
} from "@storybook/core-events";
import { queryFromLocation, buildArgsParam } from "@storybook/router";
import { toId as toId3, sanitize as sanitize3 } from "@storybook/csf";
import { dequal as deepEqual2 } from "dequal";
import global7 from "global";
import { dedent as dedent5 } from "ts-dedent";
var { window: globalWindow } = global7;
var parseBoolean = (value) => {
  if (value === "true" || value === "1")
    return true;
  if (value === "false" || value === "0")
    return false;
  return void 0;
};
var prevParams;
var initialUrlSupport = ({
  state: { location: location2, path, viewMode, storyId: storyIdFromUrl },
  singleStory
}) => {
  const {
    full,
    panel,
    nav,
    shortcuts,
    addonPanel,
    tabs,
    addons,
    panelRight,
    stories,
    selectedKind,
    selectedStory,
    path: queryPath,
    ...otherParams
  } = queryFromLocation(location2);
  const layout = {
    isFullscreen: parseBoolean(full),
    showNav: !singleStory && parseBoolean(nav),
    showPanel: parseBoolean(panel),
    panelPosition: ["right", "bottom"].includes(panel) ? panel : void 0,
    showTabs: parseBoolean(tabs)
  };
  const ui = {
    enableShortcuts: parseBoolean(shortcuts)
  };
  const selectedPanel = addonPanel || void 0;
  if (addons === "0") {
    once2.warn(dedent5`
      The 'addons' query param is deprecated and will be removed in Storybook 7.0. Use 'panel=false' instead.

      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-layout-url-params
    `);
    layout.showPanel = false;
  }
  if (panelRight === "1") {
    once2.warn(dedent5`
      The 'panelRight' query param is deprecated and will be removed in Storybook 7.0. Use 'panel=right' instead.

      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-layout-url-params
    `);
    layout.panelPosition = "right";
  }
  if (stories === "0") {
    once2.warn(dedent5`
      The 'stories' query param is deprecated and will be removed in Storybook 7.0. Use 'nav=false' instead.

      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-layout-url-params
    `);
    layout.showNav = false;
  }
  let storyId = storyIdFromUrl;
  if (!storyId && selectedKind) {
    once2.warn(dedent5`
      The 'selectedKind' and 'selectedStory' query params are deprecated and will be removed in Storybook 7.0. Use 'path' instead.

      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-layout-url-params
    `);
    storyId = selectedStory ? toId3(selectedKind, selectedStory) : sanitize3(selectedKind);
  }
  const customQueryParams = deepEqual2(prevParams, otherParams) ? prevParams : otherParams;
  prevParams = customQueryParams;
  return { viewMode, layout, ui, selectedPanel, location: location2, path, customQueryParams, storyId };
};
var init11 = ({ store: store2, navigate, state, provider, fullAPI, ...rest }) => {
  const navigateTo = (path, queryParams = {}, options = {}) => {
    const params = Object.entries(queryParams).filter(([, v]) => v).sort(([a], [b]) => a < b ? -1 : 1).map(([k, v]) => `${k}=${v}`);
    const to = [path, ...params].join("&");
    return navigate(to, options);
  };
  const api = {
    getQueryParam(key) {
      const { customQueryParams } = store2.getState();
      return customQueryParams ? customQueryParams[key] : void 0;
    },
    getUrlState() {
      const { path, customQueryParams, storyId, url, viewMode } = store2.getState();
      return { path, queryParams: customQueryParams, storyId, url, viewMode };
    },
    setQueryParams(input) {
      const { customQueryParams } = store2.getState();
      const queryParams = {};
      const update2 = {
        ...customQueryParams,
        ...Object.entries(input).reduce((acc, [key, value]) => {
          if (value !== null) {
            acc[key] = value;
          }
          return acc;
        }, queryParams)
      };
      if (!deepEqual2(customQueryParams, update2)) {
        store2.setState({ customQueryParams: update2 });
        fullAPI.emit(UPDATE_QUERY_PARAMS, update2);
      }
    },
    navigateUrl(url, options) {
      navigate(url, { ...options, plain: true });
    }
  };
  const initModule = () => {
    const updateArgsParam = () => {
      const { path, queryParams, viewMode } = fullAPI.getUrlState();
      if (viewMode !== "story")
        return;
      const currentStory = fullAPI.getCurrentStoryData();
      if (currentStory?.type !== "story")
        return;
      const { args, initialArgs } = currentStory;
      const argsString = buildArgsParam(initialArgs, args);
      navigateTo(path, { ...queryParams, args: argsString }, { replace: true });
      api.setQueryParams({ args: argsString });
    };
    fullAPI.on(SET_CURRENT_STORY, () => updateArgsParam());
    let handleOrId;
    fullAPI.on(STORY_ARGS_UPDATED2, () => {
      if ("requestIdleCallback" in globalWindow) {
        if (handleOrId)
          globalWindow.cancelIdleCallback(handleOrId);
        handleOrId = globalWindow.requestIdleCallback(updateArgsParam, { timeout: 1e3 });
      } else {
        if (handleOrId)
          clearTimeout(handleOrId);
        setTimeout(updateArgsParam, 100);
      }
    });
    fullAPI.on(GLOBALS_UPDATED, ({ globals, initialGlobals }) => {
      const { path, queryParams } = fullAPI.getUrlState();
      const globalsString = buildArgsParam(initialGlobals, globals);
      navigateTo(path, { ...queryParams, globals: globalsString }, { replace: true });
      api.setQueryParams({ globals: globalsString });
    });
    fullAPI.on(NAVIGATE_URL, (url, options) => {
      fullAPI.navigateUrl(url, options);
    });
    if (fullAPI.showReleaseNotesOnLaunch()) {
      navigate("/settings/release-notes");
    }
  };
  return {
    api,
    state: initialUrlSupport({ store: store2, navigate, state, provider, fullAPI, ...rest }),
    init: initModule
  };
};

// src/modules/versions.ts
var versions_exports = {};
__export(versions_exports, {
  init: () => init12
});
import global8 from "global";
import semver from "@storybook/semver";
import memoize3 from "memoizerific";

// src/version.ts
var version = "7.0.0-alpha.34";

// src/modules/versions.ts
var { VERSIONCHECK } = global8;
var getVersionCheckData = memoize3(1)(() => {
  try {
    return { ...JSON.parse(VERSIONCHECK).data || {} };
  } catch (e) {
    return {};
  }
});
var init12 = ({ store: store2, mode, fullAPI }) => {
  const { dismissedVersionNotification } = store2.getState();
  const state = {
    versions: {
      current: {
        version
      },
      ...getVersionCheckData()
    },
    dismissedVersionNotification
  };
  const api = {
    getCurrentVersion: () => {
      const {
        versions: { current }
      } = store2.getState();
      return current;
    },
    getLatestVersion: () => {
      const {
        versions: { latest, next, current }
      } = store2.getState();
      if (current && semver.prerelease(current.version) && next) {
        return latest && semver.gt(latest.version, next.version) ? latest : next;
      }
      return latest;
    },
    versionUpdateAvailable: () => {
      const latest = api.getLatestVersion();
      const current = api.getCurrentVersion();
      if (latest) {
        if (!latest.version) {
          return true;
        }
        if (!current.version) {
          return true;
        }
        const onPrerelease = !!semver.prerelease(current.version);
        const actualCurrent = onPrerelease ? `${semver.major(current.version)}.${semver.minor(current.version)}.${semver.patch(
          current.version
        )}` : current.version;
        const diff = semver.diff(actualCurrent, latest.version);
        return semver.gt(latest.version, actualCurrent) && diff !== "patch" && !diff.includes("pre");
      }
      return false;
    }
  };
  const initModule = async () => {
    const { versions = {} } = store2.getState();
    const { latest, next } = getVersionCheckData();
    await store2.setState({
      versions: { ...versions, latest, next }
    });
    if (api.versionUpdateAvailable()) {
      const latestVersion = api.getLatestVersion().version;
      const diff = semver.diff(versions.current.version, versions.latest.version);
      if (latestVersion !== dismissedVersionNotification && diff !== "patch" && !semver.prerelease(latestVersion) && mode !== "production") {
        fullAPI.addNotification({
          id: "update",
          link: "/settings/about",
          content: {
            headline: `Storybook ${latestVersion} is available!`,
            subHeadline: `Your current version is: ${versions.current.version}`
          },
          icon: { name: "book" },
          onClear() {
            store2.setState(
              { dismissedVersionNotification: latestVersion },
              { persistence: "permanent" }
            );
          }
        });
      }
    }
  };
  return { init: initModule, state, api };
};

// src/modules/globals.ts
var globals_exports = {};
__export(globals_exports, {
  init: () => init13
});
import { SET_GLOBALS, UPDATE_GLOBALS, GLOBALS_UPDATED as GLOBALS_UPDATED2 } from "@storybook/core-events";
import { logger as logger4 } from "@storybook/client-logger";
import { dequal as deepEqual3 } from "dequal";
var init13 = ({ store: store2, fullAPI }) => {
  const api = {
    getGlobals() {
      return store2.getState().globals;
    },
    getGlobalTypes() {
      return store2.getState().globalTypes;
    },
    updateGlobals(newGlobals) {
      fullAPI.emit(UPDATE_GLOBALS, {
        globals: newGlobals,
        options: {
          target: "storybook-preview-iframe"
        }
      });
    }
  };
  const state = {
    globals: {},
    globalTypes: {}
  };
  const updateGlobals = (globals) => {
    const currentGlobals = store2.getState()?.globals;
    if (!deepEqual3(globals, currentGlobals)) {
      store2.setState({ globals });
    }
  };
  const initModule = () => {
    fullAPI.on(GLOBALS_UPDATED2, function handleGlobalsUpdated({ globals }) {
      const { ref } = getEventMetadata(this, fullAPI);
      if (!ref) {
        updateGlobals(globals);
      } else {
        logger4.warn(
          "received a GLOBALS_UPDATED from a non-local ref. This is not currently supported."
        );
      }
    });
    fullAPI.on(SET_GLOBALS, function handleSetStories({ globals, globalTypes }) {
      const { ref } = getEventMetadata(this, fullAPI);
      const currentGlobals = store2.getState()?.globals;
      if (!ref) {
        store2.setState({ globals, globalTypes });
      } else if (Object.keys(globals).length > 0) {
        logger4.warn("received globals from a non-local ref. This is not currently supported.");
      }
      if (currentGlobals && Object.keys(currentGlobals).length !== 0 && !deepEqual3(globals, currentGlobals)) {
        api.updateGlobals(currentGlobals);
      }
    });
  };
  return {
    api,
    state,
    init: initModule
  };
};

// src/index.tsx
var { ActiveTabs: ActiveTabs2 } = layout_exports;
var ManagerContext = createContext({ api: void 0, state: initial_state_default({}) });
var combineParameters = (...parameterSets) => mergeWith2({}, ...parameterSets, (objValue, srcValue) => {
  if (Array.isArray(srcValue))
    return srcValue;
  return void 0;
});
var ManagerProvider = class extends Component {
  constructor(props) {
    super(props);
    this.api = {};
    this.initModules = () => {
      this.modules.forEach((module) => {
        if ("init" in module) {
          module.init();
        }
      });
    };
    const {
      location: location2,
      path,
      refId,
      viewMode = props.docsOptions.docsMode ? "docs" : "story",
      singleStory,
      storyId,
      docsOptions,
      navigate
    } = props;
    const store2 = new Store({
      getState: () => this.state,
      setState: (stateChange, callback) => this.setState(stateChange, callback)
    });
    const routeData = { location: location2, path, viewMode, singleStory, storyId, refId };
    const optionsData = { docsOptions };
    this.state = store2.getInitialState(initial_state_default({ ...routeData, ...optionsData }));
    const apiData = {
      navigate,
      store: store2,
      provider: props.provider
    };
    this.modules = [
      provider_exports,
      channel_exports,
      addons_exports,
      layout_exports,
      notifications_exports,
      settings_exports,
      release_notes_exports,
      shortcuts_exports,
      stories_exports,
      refs_exports,
      globals_exports,
      url_exports,
      versions_exports
    ].map(
      (m) => m.init({ ...routeData, ...optionsData, ...apiData, state: this.state, fullAPI: this.api })
    );
    const state = initial_state_default(this.state, ...this.modules.map((m) => m.state));
    const api = Object.assign(this.api, { navigate }, ...this.modules.map((m) => m.api));
    this.state = state;
    this.api = api;
  }
  static getDerivedStateFromProps(props, state) {
    if (state.path !== props.path) {
      return {
        ...state,
        location: props.location,
        path: props.path,
        refId: props.refId,
        viewMode: props.viewMode,
        storyId: props.storyId
      };
    }
    return null;
  }
  shouldComponentUpdate(nextProps, nextState) {
    const prevState = this.state;
    const prevProps = this.props;
    if (prevState !== nextState) {
      return true;
    }
    if (prevProps.path !== nextProps.path) {
      return true;
    }
    return false;
  }
  render() {
    const { children } = this.props;
    const value = {
      state: this.state,
      api: this.api
    };
    return /* @__PURE__ */ React.createElement(EffectOnMount, {
      effect: this.initModules
    }, /* @__PURE__ */ React.createElement(ManagerContext.Provider, {
      value
    }, /* @__PURE__ */ React.createElement(ManagerConsumer, null, children)));
  }
};
ManagerProvider.displayName = "Manager";
var EffectOnMount = ({ children, effect }) => {
  React.useEffect(effect, []);
  return children;
};
var defaultFilter = (c) => c;
function ManagerConsumer({
  filter = defaultFilter,
  children
}) {
  const c = useContext(ManagerContext);
  const renderer = useRef(children);
  const filterer = useRef(filter);
  if (typeof renderer.current !== "function") {
    return /* @__PURE__ */ React.createElement(Fragment, null, renderer.current);
  }
  const data = filterer.current(c);
  const l = useMemo(() => {
    return [...Object.entries(data).reduce((acc, keyval) => acc.concat(keyval), [])];
  }, [c.state]);
  return useMemo(() => {
    const Child = renderer.current;
    return /* @__PURE__ */ React.createElement(Child, {
      ...data
    });
  }, l);
}
function useStorybookState() {
  const { state } = useContext(ManagerContext);
  return state;
}
function useStorybookApi() {
  const { api } = useContext(ManagerContext);
  return api;
}
function orDefault(fromStore, defaultState2) {
  if (typeof fromStore === "undefined") {
    return defaultState2;
  }
  return fromStore;
}
var useChannel = (eventMap, deps = []) => {
  const api = useStorybookApi();
  useEffect(() => {
    Object.entries(eventMap).forEach(([type, listener]) => api.on(type, listener));
    return () => {
      Object.entries(eventMap).forEach(([type, listener]) => api.off(type, listener));
    };
  }, deps);
  return api.emit;
};
function useStoryPrepared(storyId) {
  const api = useStorybookApi();
  return api.isPrepared(storyId);
}
function useParameter(parameterKey, defaultValue) {
  const api = useStorybookApi();
  const result = api.getCurrentParameter(parameterKey);
  return orDefault(result, defaultValue);
}
var addonStateCache = {};
function useSharedState(stateId, defaultState2) {
  const api = useStorybookApi();
  const existingState = api.getAddonState(stateId);
  const state = orDefault(
    existingState,
    addonStateCache[stateId] ? addonStateCache[stateId] : defaultState2
  );
  const setState = (s, options) => {
    if (addonStateCache[stateId]) {
      addonStateCache[stateId] = s;
    }
    api.setAddonState(stateId, s, options);
  };
  const allListeners = useMemo(() => {
    const stateChangeHandlers = {
      [`${SHARED_STATE_CHANGED}-client-${stateId}`]: (s) => setState(s),
      [`${SHARED_STATE_SET}-client-${stateId}`]: (s) => setState(s)
    };
    const stateInitializationHandlers = {
      [SET_STORIES2]: () => {
        const currentState = api.getAddonState(stateId);
        if (currentState) {
          addonStateCache[stateId] = currentState;
          api.emit(`${SHARED_STATE_SET}-manager-${stateId}`, currentState);
        } else if (addonStateCache[stateId]) {
          setState(addonStateCache[stateId]);
          api.emit(`${SHARED_STATE_SET}-manager-${stateId}`, addonStateCache[stateId]);
        } else if (defaultState2 !== void 0) {
          setState(defaultState2);
          addonStateCache[stateId] = defaultState2;
          api.emit(`${SHARED_STATE_SET}-manager-${stateId}`, defaultState2);
        }
      },
      [STORY_CHANGED2]: () => {
        const currentState = api.getAddonState(stateId);
        if (currentState !== void 0) {
          api.emit(`${SHARED_STATE_SET}-manager-${stateId}`, currentState);
        }
      }
    };
    return {
      ...stateChangeHandlers,
      ...stateInitializationHandlers
    };
  }, [stateId]);
  const emit = useChannel(allListeners);
  return [
    state,
    (newStateOrMerger, options) => {
      setState(newStateOrMerger, options);
      emit(`${SHARED_STATE_CHANGED}-manager-${stateId}`, newStateOrMerger);
    }
  ];
}
function useAddonState(addonId, defaultState2) {
  return useSharedState(addonId, defaultState2);
}
function useArgs() {
  const { getCurrentStoryData, updateStoryArgs, resetStoryArgs } = useStorybookApi();
  const data = getCurrentStoryData();
  const args = data.type === "story" ? data.args : {};
  const updateArgs = useCallback(
    (newArgs) => updateStoryArgs(data, newArgs),
    [data, updateStoryArgs]
  );
  const resetArgs = useCallback(
    (argNames) => resetStoryArgs(data, argNames),
    [data, resetStoryArgs]
  );
  return [args, updateArgs, resetArgs];
}
function useGlobals() {
  const api = useStorybookApi();
  return [api.getGlobals(), api.updateGlobals];
}
function useGlobalTypes() {
  return useStorybookApi().getGlobalTypes();
}
function useCurrentStory() {
  const { getCurrentStoryData } = useStorybookApi();
  return getCurrentStoryData();
}
function useArgTypes() {
  const current = useCurrentStory();
  return current?.type === "story" && current.argTypes || {};
}
export {
  ActiveTabs2 as ActiveTabs,
  ManagerConsumer as Consumer,
  ManagerContext,
  ManagerProvider as Provider,
  combineParameters,
  merge_default as merge,
  useAddonState,
  useArgTypes,
  useArgs,
  useChannel,
  useGlobalTypes,
  useGlobals,
  useParameter,
  useSharedState,
  useStoryPrepared,
  useStorybookApi,
  useStorybookState
};
