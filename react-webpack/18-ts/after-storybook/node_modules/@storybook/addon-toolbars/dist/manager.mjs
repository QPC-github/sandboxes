// src/manager.tsx
import React6 from "react";
import { addons, types } from "@storybook/addons";

// src/components/ToolbarManager.tsx
import React5 from "react";
import { useGlobalTypes } from "@storybook/api";
import { Separator } from "@storybook/components";

// src/components/ToolbarMenuList.tsx
import React4, { useCallback as useCallback2 } from "react";
import { useGlobals as useGlobals2 } from "@storybook/api";
import { WithTooltip, TooltipLinkList } from "@storybook/components";

// src/components/ToolbarMenuButton.tsx
import React from "react";
import { Icons, IconButton } from "@storybook/components";
var ToolbarMenuButton = ({
  active,
  title,
  icon,
  description,
  onClick
}) => {
  return /* @__PURE__ */ React.createElement(IconButton, {
    active,
    title: description,
    onClick
  }, icon && /* @__PURE__ */ React.createElement(Icons, {
    icon
  }), title ? `\xA0${title}` : null);
};

// src/hoc/withKeyboardCycle.tsx
import React2, { useRef, useEffect, useCallback } from "react";
import { useGlobals, useStorybookApi } from "@storybook/api";

// src/utils/create-cycle-value-array.ts
var disallowedCycleableItemTypes = ["reset"];
var createCycleValueArray = (items) => {
  const valueArray = items.filter((item) => !disallowedCycleableItemTypes.includes(item.type)).map((item) => item.value);
  return valueArray;
};

// src/constants.ts
var ADDON_ID = "addon-toolbars";

// src/utils/register-shortcuts.ts
var registerShortcuts = async (api, id, shortcuts) => {
  if (shortcuts && shortcuts.next) {
    await api.setAddonShortcut(ADDON_ID, {
      label: shortcuts.next.label,
      defaultShortcut: shortcuts.next.keys,
      actionName: `${id}:next`,
      action: shortcuts.next.action
    });
  }
  if (shortcuts && shortcuts.previous) {
    await api.setAddonShortcut(ADDON_ID, {
      label: shortcuts.previous.label,
      defaultShortcut: shortcuts.previous.keys,
      actionName: `${id}:previous`,
      action: shortcuts.previous.action
    });
  }
  if (shortcuts && shortcuts.reset) {
    await api.setAddonShortcut(ADDON_ID, {
      label: shortcuts.reset.label,
      defaultShortcut: shortcuts.reset.keys,
      actionName: `${id}:reset`,
      action: shortcuts.reset.action
    });
  }
};

// src/hoc/withKeyboardCycle.tsx
var withKeyboardCycle = (Component) => {
  const WithKeyboardCycle = (props) => {
    const {
      id,
      toolbar: { items, shortcuts }
    } = props;
    const api = useStorybookApi();
    const [globals, updateGlobals] = useGlobals();
    const cycleValues = useRef([]);
    const currentValue = globals[id];
    const reset = useCallback(() => {
      updateGlobals({ [id]: "" });
    }, [updateGlobals]);
    const setNext = useCallback(() => {
      const values = cycleValues.current;
      const currentIndex = values.indexOf(currentValue);
      const currentIsLast = currentIndex === values.length - 1;
      const newCurrentIndex = currentIsLast ? 0 : currentIndex + 1;
      const newCurrent = cycleValues.current[newCurrentIndex];
      updateGlobals({ [id]: newCurrent });
    }, [cycleValues, currentValue, updateGlobals]);
    const setPrevious = useCallback(() => {
      const values = cycleValues.current;
      const indexOf = values.indexOf(currentValue);
      const currentIndex = indexOf > -1 ? indexOf : 0;
      const currentIsFirst = currentIndex === 0;
      const newCurrentIndex = currentIsFirst ? values.length - 1 : currentIndex - 1;
      const newCurrent = cycleValues.current[newCurrentIndex];
      updateGlobals({ [id]: newCurrent });
    }, [cycleValues, currentValue, updateGlobals]);
    useEffect(() => {
      if (shortcuts) {
        registerShortcuts(api, id, {
          next: { ...shortcuts.next, action: setNext },
          previous: { ...shortcuts.previous, action: setPrevious },
          reset: { ...shortcuts.reset, action: reset }
        });
      }
    }, [api, id, shortcuts, setNext, setPrevious, reset]);
    useEffect(() => {
      cycleValues.current = createCycleValueArray(items);
    }, []);
    return /* @__PURE__ */ React2.createElement(Component, {
      cycleValues: cycleValues.current,
      ...props
    });
  };
  return WithKeyboardCycle;
};

// src/utils/get-selected.ts
var getSelectedItem = ({ currentValue, items }) => {
  const selectedItem = currentValue != null && items.find((item) => item.value === currentValue);
  return selectedItem;
};
var getSelectedIcon = ({ currentValue, items }) => {
  const selectedItem = getSelectedItem({ currentValue, items });
  if (selectedItem) {
    return selectedItem.icon;
  }
  return void 0;
};
var getSelectedTitle = ({ currentValue, items }) => {
  const selectedItem = getSelectedItem({ currentValue, items });
  if (selectedItem) {
    return selectedItem.title;
  }
  return void 0;
};

// src/components/ToolbarMenuListItem.tsx
import React3 from "react";
import { Icons as Icons2 } from "@storybook/components";
var ToolbarMenuListItem = ({
  left,
  right,
  title,
  value,
  icon,
  hideIcon,
  onClick,
  currentValue
}) => {
  const Icon = icon && /* @__PURE__ */ React3.createElement(Icons2, {
    style: { opacity: 1 },
    icon
  });
  const hasContent = left || right || title;
  const Item = {
    id: value || currentValue,
    active: currentValue === value,
    onClick
  };
  if (left) {
    Item.left = left;
  }
  if (right) {
    Item.right = right;
  }
  if (title) {
    Item.title = title;
  }
  if (icon && !hideIcon) {
    if (hasContent && !right) {
      Item.right = Icon;
    } else if (hasContent && !left) {
      Item.left = Icon;
    } else if (!hasContent) {
      Item.right = Icon;
    }
  }
  return Item;
};

// src/components/ToolbarMenuList.tsx
var ToolbarMenuList = withKeyboardCycle(
  ({
    id,
    name,
    description,
    toolbar: { icon: _icon, items, title: _title, showName, preventDynamicIcon, dynamicTitle }
  }) => {
    const [globals, updateGlobals] = useGlobals2();
    const currentValue = globals[id];
    const hasGlobalValue = !!currentValue;
    let icon = _icon;
    let title = _title;
    if (!preventDynamicIcon) {
      icon = getSelectedIcon({ currentValue, items }) || icon;
    }
    if (showName && !title) {
      title = name;
      console.warn(
        "`showName` is deprecated as `name` will stop having dual purposes in the future. Please specify a `title` in `globalTypes` instead."
      );
    } else if (!showName && !icon && !title) {
      title = name;
      console.warn(
        `Using the \`name\` "${name}" as toolbar title for backward compatibility. \`name\` will stop having dual purposes in the future. Please specify either a \`title\` or an \`icon\` in \`globalTypes\` instead.`
      );
    }
    if (dynamicTitle) {
      title = getSelectedTitle({ currentValue, items }) || title;
    }
    const handleItemClick = useCallback2(
      (value) => {
        updateGlobals({ [id]: value });
      },
      [currentValue, updateGlobals]
    );
    return /* @__PURE__ */ React4.createElement(WithTooltip, {
      placement: "top",
      trigger: "click",
      tooltip: ({ onHide }) => {
        const links = items.filter(({ type }) => {
          let shouldReturn = true;
          if (type === "reset" && !currentValue) {
            shouldReturn = false;
          }
          return shouldReturn;
        }).map((item) => {
          const listItem = ToolbarMenuListItem({
            ...item,
            currentValue,
            onClick: () => {
              handleItemClick(item.value);
              onHide();
            }
          });
          return listItem;
        });
        return /* @__PURE__ */ React4.createElement(TooltipLinkList, {
          links
        });
      },
      closeOnClick: true
    }, /* @__PURE__ */ React4.createElement(ToolbarMenuButton, {
      active: hasGlobalValue,
      description: description || "",
      icon,
      title: title || ""
    }));
  }
);

// src/utils/normalize-toolbar-arg-type.ts
var defaultItemValues = {
  type: "item",
  value: ""
};
var normalizeArgType = (key, argType) => ({
  ...argType,
  name: argType.name || key,
  description: argType.description || key,
  toolbar: {
    ...argType.toolbar,
    items: argType.toolbar.items.map((_item) => {
      const item = typeof _item === "string" ? { value: _item, title: _item } : _item;
      if (item.type === "reset" && argType.toolbar.icon) {
        item.icon = argType.toolbar.icon;
        item.hideIcon = true;
      }
      return { ...defaultItemValues, ...item };
    })
  }
});

// src/components/ToolbarManager.tsx
var ToolbarManager = () => {
  const globalTypes = useGlobalTypes();
  const globalIds = Object.keys(globalTypes).filter((id) => !!globalTypes[id].toolbar);
  if (!globalIds.length) {
    return null;
  }
  return /* @__PURE__ */ React5.createElement(React5.Fragment, null, /* @__PURE__ */ React5.createElement(Separator, null), globalIds.map((id) => {
    const normalizedArgType = normalizeArgType(id, globalTypes[id]);
    return /* @__PURE__ */ React5.createElement(ToolbarMenuList, {
      key: id,
      id,
      ...normalizedArgType
    });
  }));
};

// src/manager.tsx
addons.register(
  ADDON_ID,
  () => addons.add(ADDON_ID, {
    title: ADDON_ID,
    type: types.TOOL,
    match: () => true,
    render: () => /* @__PURE__ */ React6.createElement(ToolbarManager, null)
  })
);
