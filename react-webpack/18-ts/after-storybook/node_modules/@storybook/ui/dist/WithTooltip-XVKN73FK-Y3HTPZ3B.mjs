import {
  _inheritsLoose,
  createPopper,
  require_react_dom
} from "./chunk-V72RELJZ.mjs";
import {
  _extends,
  _objectWithoutPropertiesLoose,
  require_window
} from "./chunk-SXFHL5NO.mjs";
import {
  emotion_styled_browser_esm_default,
  lightenColor
} from "./chunk-JVGPQ5G4.mjs";
import {
  require_react
} from "./chunk-ZOCTBSY6.mjs";
import {
  require_memoizerific
} from "./chunk-QJJTTS2V.mjs";
import {
  __commonJS,
  __toESM as __toESM2,
  init_define_process_env as init_define_process_env2
} from "./chunk-BCVV5BM4.mjs";
import {
  __toESM,
  init_define_process_env
} from "./chunk-WHSM2MPW.mjs";

// ../components/dist/WithTooltip-XVKN73FK.mjs
init_define_process_env();
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var React4 = __toESM(require_react(), 1);
var React = __toESM(require_react(), 1);
var React2 = __toESM(require_react(), 1);
var React3 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var React5 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_memoizerific = __toESM(require_memoizerific(), 1);
var require_react_fast_compare = __commonJS({
  "../../node_modules/react-fast-compare/index.js"(exports, module) {
    init_define_process_env2();
    var hasElementType = typeof Element !== "undefined";
    var hasMap = typeof Map === "function";
    var hasSet = typeof Set === "function";
    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
    function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        var it;
        if (hasMap && a instanceof Map && b instanceof Map) {
          if (a.size !== b.size)
            return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!b.has(i.value[0]))
              return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!equal(i.value[1], b.get(i.value[0])))
              return false;
          return true;
        }
        if (hasSet && a instanceof Set && b instanceof Set) {
          if (a.size !== b.size)
            return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!b.has(i.value[0]))
              return false;
          return true;
        }
        if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (a[i] !== b[i])
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        if (hasElementType && a instanceof Element)
          return false;
        for (i = length; i-- !== 0; ) {
          if ((keys[i] === "_owner" || keys[i] === "__v" || keys[i] === "__o") && a.$$typeof) {
            continue;
          }
          if (!equal(a[keys[i]], b[keys[i]]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    }
    module.exports = function isEqual2(a, b) {
      try {
        return equal(a, b);
      } catch (error) {
        if ((error.message || "").match(/stack|recursion/i)) {
          console.warn("react-fast-compare cannot handle circular refs");
          return false;
        }
        throw error;
      }
    };
  }
});
var require_warning = __commonJS({
  "../../node_modules/warning/warning.js"(exports, module) {
    "use strict";
    init_define_process_env2();
    var __DEV__ = true;
    var warning2 = function() {
    };
    if (__DEV__) {
      printWarning = function printWarning2(format, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for (var key = 1; key < len; key++) {
          args[key - 1] = arguments[key];
        }
        var argIndex = 0;
        var message = "Warning: " + format.replace(/%s/g, function() {
          return args[argIndex++];
        });
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
      warning2 = function(condition, format, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++) {
          args[key - 2] = arguments[key];
        }
        if (format === void 0) {
          throw new Error(
            "`warning(condition, format, ...args)` requires a warning message argument"
          );
        }
        if (!condition) {
          printWarning.apply(null, [format].concat(args));
        }
      };
    }
    var printWarning;
    module.exports = warning2;
  }
});
init_define_process_env2();
var import_global = __toESM2(require_window());
init_define_process_env2();
init_define_process_env2();
init_define_process_env2();
init_define_process_env2();
var ManagerReferenceNodeContext = React.createContext();
var ManagerReferenceNodeSetterContext = React.createContext();
function Manager(_ref) {
  var children = _ref.children;
  var _React$useState = React.useState(null), referenceNode = _React$useState[0], setReferenceNode = _React$useState[1];
  var hasUnmounted = React.useRef(false);
  React.useEffect(function() {
    return function() {
      hasUnmounted.current = true;
    };
  }, []);
  var handleSetReferenceNode = React.useCallback(function(node) {
    if (!hasUnmounted.current) {
      setReferenceNode(node);
    }
  }, []);
  return /* @__PURE__ */ React.createElement(ManagerReferenceNodeContext.Provider, {
    value: referenceNode
  }, /* @__PURE__ */ React.createElement(ManagerReferenceNodeSetterContext.Provider, {
    value: handleSetReferenceNode
  }, children));
}
init_define_process_env2();
var unwrapArray = function unwrapArray2(arg) {
  return Array.isArray(arg) ? arg[0] : arg;
};
var safeInvoke = function safeInvoke2(fn) {
  if (typeof fn === "function") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return fn.apply(void 0, args);
  }
};
var setRef = function setRef2(ref, node) {
  if (typeof ref === "function") {
    return safeInvoke(ref, node);
  } else if (ref != null) {
    ref.current = node;
  }
};
var fromEntries = function fromEntries2(entries) {
  return entries.reduce(function(acc, _ref) {
    var key = _ref[0], value = _ref[1];
    acc[key] = value;
    return acc;
  }, {});
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement ? React2.useLayoutEffect : React2.useEffect;
init_define_process_env2();
var import_react_fast_compare = __toESM2(require_react_fast_compare());
var EMPTY_MODIFIERS = [];
var usePopper = function usePopper2(referenceElement, popperElement, options) {
  if (options === void 0) {
    options = {};
  }
  var prevOptions = React3.useRef(null);
  var optionsWithDefaults = {
    onFirstUpdate: options.onFirstUpdate,
    placement: options.placement || "bottom",
    strategy: options.strategy || "absolute",
    modifiers: options.modifiers || EMPTY_MODIFIERS
  };
  var _React$useState = React3.useState({
    styles: {
      popper: {
        position: optionsWithDefaults.strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), state = _React$useState[0], setState = _React$useState[1];
  var updateStateModifier = React3.useMemo(function() {
    return {
      name: "updateState",
      enabled: true,
      phase: "write",
      fn: function fn(_ref) {
        var state2 = _ref.state;
        var elements = Object.keys(state2.elements);
        ReactDOM.flushSync(function() {
          setState({
            styles: fromEntries(elements.map(function(element) {
              return [element, state2.styles[element] || {}];
            })),
            attributes: fromEntries(elements.map(function(element) {
              return [element, state2.attributes[element]];
            }))
          });
        });
      },
      requires: ["computeStyles"]
    };
  }, []);
  var popperOptions = React3.useMemo(function() {
    var newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
        name: "applyStyles",
        enabled: false
      }])
    };
    if ((0, import_react_fast_compare.default)(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    } else {
      prevOptions.current = newOptions;
      return newOptions;
    }
  }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
  var popperInstanceRef = React3.useRef();
  useIsomorphicLayoutEffect(function() {
    if (popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  useIsomorphicLayoutEffect(function() {
    if (referenceElement == null || popperElement == null) {
      return;
    }
    var createPopper2 = options.createPopper || createPopper;
    var popperInstance = createPopper2(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return function() {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options.createPopper]);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles: state.styles,
    attributes: state.attributes,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
};
var NOOP = function NOOP2() {
  return void 0;
};
var NOOP_PROMISE = function NOOP_PROMISE2() {
  return Promise.resolve(null);
};
var EMPTY_MODIFIERS2 = [];
function Popper(_ref) {
  var _ref$placement = _ref.placement, placement = _ref$placement === void 0 ? "bottom" : _ref$placement, _ref$strategy = _ref.strategy, strategy = _ref$strategy === void 0 ? "absolute" : _ref$strategy, _ref$modifiers = _ref.modifiers, modifiers = _ref$modifiers === void 0 ? EMPTY_MODIFIERS2 : _ref$modifiers, referenceElement = _ref.referenceElement, onFirstUpdate = _ref.onFirstUpdate, innerRef = _ref.innerRef, children = _ref.children;
  var referenceNode = React4.useContext(ManagerReferenceNodeContext);
  var _React$useState = React4.useState(null), popperElement = _React$useState[0], setPopperElement = _React$useState[1];
  var _React$useState2 = React4.useState(null), arrowElement = _React$useState2[0], setArrowElement = _React$useState2[1];
  React4.useEffect(function() {
    setRef(innerRef, popperElement);
  }, [innerRef, popperElement]);
  var options = React4.useMemo(function() {
    return {
      placement,
      strategy,
      onFirstUpdate,
      modifiers: [].concat(modifiers, [{
        name: "arrow",
        enabled: arrowElement != null,
        options: {
          element: arrowElement
        }
      }])
    };
  }, [placement, strategy, onFirstUpdate, modifiers, arrowElement]);
  var _usePopper = usePopper(referenceElement || referenceNode, popperElement, options), state = _usePopper.state, styles = _usePopper.styles, forceUpdate = _usePopper.forceUpdate, update = _usePopper.update;
  var childrenProps = React4.useMemo(function() {
    return {
      ref: setPopperElement,
      style: styles.popper,
      placement: state ? state.placement : placement,
      hasPopperEscaped: state && state.modifiersData.hide ? state.modifiersData.hide.hasPopperEscaped : null,
      isReferenceHidden: state && state.modifiersData.hide ? state.modifiersData.hide.isReferenceHidden : null,
      arrowProps: {
        style: styles.arrow,
        ref: setArrowElement
      },
      forceUpdate: forceUpdate || NOOP,
      update: update || NOOP_PROMISE
    };
  }, [setPopperElement, setArrowElement, placement, state, styles, update, forceUpdate]);
  return unwrapArray(children)(childrenProps);
}
init_define_process_env2();
var import_warning = __toESM2(require_warning());
function Reference(_ref) {
  var children = _ref.children, innerRef = _ref.innerRef;
  var setReferenceNode = React5.useContext(ManagerReferenceNodeSetterContext);
  var refHandler = React5.useCallback(function(node) {
    setRef(innerRef, node);
    safeInvoke(setReferenceNode, node);
  }, [innerRef, setReferenceNode]);
  React5.useEffect(function() {
    return function() {
      return setRef(innerRef, null);
    };
  }, []);
  React5.useEffect(function() {
    (0, import_warning.default)(Boolean(setReferenceNode), "`Reference` should not be used outside of a `Manager` component.");
  }, [setReferenceNode]);
  return unwrapArray(children)({
    ref: refHandler
  });
}
var TooltipContext = /* @__PURE__ */ import_react2.default.createContext({});
var callAll = function callAll2() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return fns.forEach(function(fn) {
      return fn && fn.apply(void 0, args);
    });
  };
};
var noop = function noop2() {
};
var canUseDOM = function canUseDOM2() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
};
var setRef3 = function setRef4(ref, node) {
  if (typeof ref === "function") {
    return ref(node);
  } else if (ref != null) {
    ref.current = node;
  }
};
var Tooltip = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(Tooltip3, _Component);
  function Tooltip3() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.observer = void 0;
    _this.tooltipRef = void 0;
    _this.handleOutsideClick = function(event) {
      if (_this.tooltipRef && !_this.tooltipRef.contains(event.target)) {
        var parentOutsideClickHandler = _this.context.parentOutsideClickHandler;
        var _this$props = _this.props, hideTooltip = _this$props.hideTooltip, clearScheduled = _this$props.clearScheduled;
        clearScheduled();
        hideTooltip();
        if (parentOutsideClickHandler) {
          parentOutsideClickHandler(event);
        }
      }
    };
    _this.handleOutsideRightClick = function(event) {
      if (_this.tooltipRef && !_this.tooltipRef.contains(event.target)) {
        var parentOutsideRightClickHandler = _this.context.parentOutsideRightClickHandler;
        var _this$props2 = _this.props, hideTooltip = _this$props2.hideTooltip, clearScheduled = _this$props2.clearScheduled;
        clearScheduled();
        hideTooltip();
        if (parentOutsideRightClickHandler) {
          parentOutsideRightClickHandler(event);
        }
      }
    };
    _this.addOutsideClickHandler = function() {
      document.body.addEventListener("touchend", _this.handleOutsideClick);
      document.body.addEventListener("click", _this.handleOutsideClick);
    };
    _this.removeOutsideClickHandler = function() {
      document.body.removeEventListener("touchend", _this.handleOutsideClick);
      document.body.removeEventListener("click", _this.handleOutsideClick);
    };
    _this.addOutsideRightClickHandler = function() {
      return document.body.addEventListener("contextmenu", _this.handleOutsideRightClick);
    };
    _this.removeOutsideRightClickHandler = function() {
      return document.body.removeEventListener("contextmenu", _this.handleOutsideRightClick);
    };
    _this.getTooltipRef = function(node) {
      _this.tooltipRef = node;
      setRef3(_this.props.innerRef, node);
    };
    _this.getArrowProps = function(props) {
      if (props === void 0) {
        props = {};
      }
      return _extends({}, props, {
        style: _extends({}, props.style, _this.props.arrowProps.style)
      });
    };
    _this.getTooltipProps = function(props) {
      if (props === void 0) {
        props = {};
      }
      return _extends({}, props, _this.isTriggeredBy("hover") && {
        onMouseEnter: callAll(_this.props.clearScheduled, props.onMouseEnter),
        onMouseLeave: callAll(_this.props.hideTooltip, props.onMouseLeave)
      }, {
        style: _extends({}, props.style, _this.props.style)
      });
    };
    _this.contextValue = {
      isParentNoneTriggered: _this.props.trigger === "none",
      addParentOutsideClickHandler: _this.addOutsideClickHandler,
      addParentOutsideRightClickHandler: _this.addOutsideRightClickHandler,
      parentOutsideClickHandler: _this.handleOutsideClick,
      parentOutsideRightClickHandler: _this.handleOutsideRightClick,
      removeParentOutsideClickHandler: _this.removeOutsideClickHandler,
      removeParentOutsideRightClickHandler: _this.removeOutsideRightClickHandler
    };
    return _this;
  }
  var _proto = Tooltip3.prototype;
  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;
    var observer = this.observer = new MutationObserver(function() {
      _this2.props.update();
    });
    observer.observe(this.tooltipRef, this.props.mutationObserverOptions);
    if (this.isTriggeredBy("hover") || this.isTriggeredBy("click") || this.isTriggeredBy("right-click")) {
      var _this$context = this.context, removeParentOutsideClickHandler = _this$context.removeParentOutsideClickHandler, removeParentOutsideRightClickHandler = _this$context.removeParentOutsideRightClickHandler;
      this.addOutsideClickHandler();
      this.addOutsideRightClickHandler();
      if (removeParentOutsideClickHandler) {
        removeParentOutsideClickHandler();
      }
      if (removeParentOutsideRightClickHandler) {
        removeParentOutsideRightClickHandler();
      }
    }
  };
  _proto.componentDidUpdate = function componentDidUpdate() {
    if (this.props.closeOnReferenceHidden && this.props.isReferenceHidden) {
      this.props.hideTooltip();
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.observer) {
      this.observer.disconnect();
    }
    if (this.isTriggeredBy("hover") || this.isTriggeredBy("click") || this.isTriggeredBy("right-click")) {
      var _this$context2 = this.context, isParentNoneTriggered = _this$context2.isParentNoneTriggered, addParentOutsideClickHandler = _this$context2.addParentOutsideClickHandler, addParentOutsideRightClickHandler = _this$context2.addParentOutsideRightClickHandler;
      this.removeOutsideClickHandler();
      this.removeOutsideRightClickHandler();
      this.handleOutsideClick = void 0;
      this.handleOutsideRightClick = void 0;
      if (!isParentNoneTriggered && addParentOutsideClickHandler) {
        addParentOutsideClickHandler();
      }
      if (!isParentNoneTriggered && addParentOutsideRightClickHandler) {
        addParentOutsideRightClickHandler();
      }
    }
  };
  _proto.render = function render() {
    var _this$props3 = this.props, arrowProps = _this$props3.arrowProps, placement = _this$props3.placement, tooltip = _this$props3.tooltip;
    return /* @__PURE__ */ import_react2.default.createElement(TooltipContext.Provider, {
      value: this.contextValue
    }, tooltip({
      arrowRef: arrowProps.ref,
      getArrowProps: this.getArrowProps,
      getTooltipProps: this.getTooltipProps,
      placement,
      tooltipRef: this.getTooltipRef
    }));
  };
  _proto.isTriggeredBy = function isTriggeredBy(event) {
    var trigger = this.props.trigger;
    return trigger === event || Array.isArray(trigger) && trigger.includes(event);
  };
  return Tooltip3;
}(import_react2.Component);
Tooltip.contextType = TooltipContext;
var DEFAULT_MUTATION_OBSERVER_CONFIG = {
  childList: true,
  subtree: true
};
var TooltipTrigger = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(TooltipTrigger2, _Component);
  function TooltipTrigger2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.state = {
      tooltipShown: _this.props.defaultTooltipShown
    };
    _this.hideTimeout = void 0;
    _this.showTimeout = void 0;
    _this.popperOffset = void 0;
    _this.setTooltipState = function(state) {
      var cb = function cb2() {
        return _this.props.onVisibilityChange(state.tooltipShown);
      };
      _this.isControlled() ? cb() : _this.setState(state, cb);
    };
    _this.clearScheduled = function() {
      clearTimeout(_this.hideTimeout);
      clearTimeout(_this.showTimeout);
    };
    _this.showTooltip = function(_ref) {
      var pageX = _ref.pageX, pageY = _ref.pageY;
      _this.clearScheduled();
      var state = {
        tooltipShown: true
      };
      if (_this.props.followCursor) {
        state = _extends({}, state, {
          pageX,
          pageY
        });
      }
      _this.showTimeout = window.setTimeout(function() {
        return _this.setTooltipState(state);
      }, _this.props.delayShow);
    };
    _this.hideTooltip = function() {
      _this.clearScheduled();
      _this.hideTimeout = window.setTimeout(function() {
        return _this.setTooltipState({
          tooltipShown: false
        });
      }, _this.props.delayHide);
    };
    _this.toggleTooltip = function(_ref2) {
      var pageX = _ref2.pageX, pageY = _ref2.pageY;
      var action = _this.getState() ? "hideTooltip" : "showTooltip";
      _this[action]({
        pageX,
        pageY
      });
    };
    _this.clickToggle = function(event) {
      event.preventDefault();
      var pageX = event.pageX, pageY = event.pageY;
      var action = _this.props.followCursor ? "showTooltip" : "toggleTooltip";
      _this[action]({
        pageX,
        pageY
      });
    };
    _this.contextMenuToggle = function(event) {
      event.preventDefault();
      var pageX = event.pageX, pageY = event.pageY;
      var action = _this.props.followCursor ? "showTooltip" : "toggleTooltip";
      _this[action]({
        pageX,
        pageY
      });
    };
    _this.getTriggerProps = function(props) {
      if (props === void 0) {
        props = {};
      }
      return _extends({}, props, _this.isTriggeredBy("click") && {
        onClick: callAll(_this.clickToggle, props.onClick),
        onTouchEnd: callAll(_this.clickToggle, props.onTouchEnd)
      }, _this.isTriggeredBy("right-click") && {
        onContextMenu: callAll(_this.contextMenuToggle, props.onContextMenu)
      }, _this.isTriggeredBy("hover") && _extends({
        onMouseEnter: callAll(_this.showTooltip, props.onMouseEnter),
        onMouseLeave: callAll(_this.hideTooltip, props.onMouseLeave)
      }, _this.props.followCursor && {
        onMouseMove: callAll(_this.showTooltip, props.onMouseMove)
      }), _this.isTriggeredBy("focus") && {
        onFocus: callAll(_this.showTooltip, props.onFocus),
        onBlur: callAll(_this.hideTooltip, props.onBlur)
      });
    };
    return _this;
  }
  var _proto = TooltipTrigger2.prototype;
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.clearScheduled();
  };
  _proto.render = function render() {
    var _this2 = this;
    var _this$props = this.props, children = _this$props.children, tooltip = _this$props.tooltip, placement = _this$props.placement, trigger = _this$props.trigger, getTriggerRef = _this$props.getTriggerRef, modifiers = _this$props.modifiers, closeOnReferenceHidden = _this$props.closeOnReferenceHidden, usePortal = _this$props.usePortal, portalContainer = _this$props.portalContainer, followCursor = _this$props.followCursor, getTooltipRef = _this$props.getTooltipRef, mutationObserverOptions = _this$props.mutationObserverOptions, restProps = _objectWithoutPropertiesLoose(_this$props, ["children", "tooltip", "placement", "trigger", "getTriggerRef", "modifiers", "closeOnReferenceHidden", "usePortal", "portalContainer", "followCursor", "getTooltipRef", "mutationObserverOptions"]);
    var popper = /* @__PURE__ */ import_react2.default.createElement(Popper, _extends({
      innerRef: getTooltipRef,
      placement,
      modifiers: [{
        name: "followCursor",
        enabled: followCursor,
        phase: "main",
        fn: function fn(data) {
          _this2.popperOffset = data.state.rects.popper;
        }
      }].concat(modifiers)
    }, restProps), function(_ref3) {
      var ref = _ref3.ref, style = _ref3.style, placement2 = _ref3.placement, arrowProps = _ref3.arrowProps, isReferenceHidden = _ref3.isReferenceHidden, update = _ref3.update;
      if (followCursor && _this2.popperOffset) {
        var _this2$state = _this2.state, pageX = _this2$state.pageX, pageY = _this2$state.pageY;
        var _this2$popperOffset = _this2.popperOffset, width = _this2$popperOffset.width, height = _this2$popperOffset.height;
        var x = pageX + width > window.pageXOffset + document.body.offsetWidth ? pageX - width : pageX;
        var y = pageY + height > window.pageYOffset + document.body.offsetHeight ? pageY - height : pageY;
        style.transform = "translate3d(" + x + "px, " + y + "px, 0";
      }
      return /* @__PURE__ */ import_react2.default.createElement(Tooltip, _extends({
        arrowProps,
        closeOnReferenceHidden,
        isReferenceHidden,
        placement: placement2,
        update,
        style,
        tooltip,
        trigger,
        mutationObserverOptions
      }, {
        clearScheduled: _this2.clearScheduled,
        hideTooltip: _this2.hideTooltip,
        innerRef: ref
      }));
    });
    return /* @__PURE__ */ import_react2.default.createElement(Manager, null, /* @__PURE__ */ import_react2.default.createElement(Reference, {
      innerRef: getTriggerRef
    }, function(_ref4) {
      var ref = _ref4.ref;
      return children({
        getTriggerProps: _this2.getTriggerProps,
        triggerRef: ref
      });
    }), this.getState() && (usePortal ? /* @__PURE__ */ (0, import_react_dom.createPortal)(popper, portalContainer) : popper));
  };
  _proto.isControlled = function isControlled() {
    return this.props.tooltipShown !== void 0;
  };
  _proto.getState = function getState() {
    return this.isControlled() ? this.props.tooltipShown : this.state.tooltipShown;
  };
  _proto.isTriggeredBy = function isTriggeredBy(event) {
    var trigger = this.props.trigger;
    return trigger === event || Array.isArray(trigger) && trigger.includes(event);
  };
  return TooltipTrigger2;
}(import_react2.Component);
TooltipTrigger.defaultProps = {
  closeOnReferenceHidden: true,
  defaultTooltipShown: false,
  delayHide: 0,
  delayShow: 0,
  followCursor: false,
  onVisibilityChange: noop,
  placement: "right",
  portalContainer: canUseDOM() ? document.body : null,
  trigger: "hover",
  usePortal: canUseDOM(),
  mutationObserverOptions: DEFAULT_MUTATION_OBSERVER_CONFIG,
  modifiers: []
};
var react_popper_tooltip_default = TooltipTrigger;
init_define_process_env2();
var match = (0, import_memoizerific.default)(1e3)(
  (requests, actual, value, fallback = 0) => actual.split("-")[0] === requests ? value : fallback
);
var ArrowSpacing = 8;
var Arrow = emotion_styled_browser_esm_default.div(
  {
    position: "absolute",
    borderStyle: "solid"
  },
  ({ placement }) => {
    let x = 0;
    let y = 0;
    switch (true) {
      case (placement.startsWith("left") || placement.startsWith("right")): {
        y = 8;
        break;
      }
      case (placement.startsWith("top") || placement.startsWith("bottom")): {
        x = 8;
        break;
      }
      default: {
      }
    }
    const transform = `translate3d(${x}px, ${y}px, 0px)`;
    return { transform };
  },
  ({ theme, color, placement }) => ({
    bottom: `${match("top", placement, ArrowSpacing * -1, "auto")}px`,
    top: `${match("bottom", placement, ArrowSpacing * -1, "auto")}px`,
    right: `${match("left", placement, ArrowSpacing * -1, "auto")}px`,
    left: `${match("right", placement, ArrowSpacing * -1, "auto")}px`,
    borderBottomWidth: `${match("top", placement, "0", ArrowSpacing)}px`,
    borderTopWidth: `${match("bottom", placement, "0", ArrowSpacing)}px`,
    borderRightWidth: `${match("left", placement, "0", ArrowSpacing)}px`,
    borderLeftWidth: `${match("right", placement, "0", ArrowSpacing)}px`,
    borderTopColor: match(
      "top",
      placement,
      theme.color[color] || color || theme.base === "light" ? lightenColor(theme.background.app) : theme.background.app,
      "transparent"
    ),
    borderBottomColor: match(
      "bottom",
      placement,
      theme.color[color] || color || theme.base === "light" ? lightenColor(theme.background.app) : theme.background.app,
      "transparent"
    ),
    borderLeftColor: match(
      "left",
      placement,
      theme.color[color] || color || theme.base === "light" ? lightenColor(theme.background.app) : theme.background.app,
      "transparent"
    ),
    borderRightColor: match(
      "right",
      placement,
      theme.color[color] || color || theme.base === "light" ? lightenColor(theme.background.app) : theme.background.app,
      "transparent"
    )
  })
);
var Wrapper = emotion_styled_browser_esm_default.div(
  ({ hidden }) => ({
    display: hidden ? "none" : "inline-block",
    zIndex: 2147483647
  }),
  ({ theme, color, hasChrome }) => hasChrome ? {
    background: theme.color[color] || color || theme.base === "light" ? lightenColor(theme.background.app) : theme.background.app,
    filter: `
            drop-shadow(0px 5px 5px rgba(0,0,0,0.05))
            drop-shadow(0 1px 3px rgba(0,0,0,0.1))
          `,
    borderRadius: theme.appBorderRadius * 2,
    fontSize: theme.typography.size.s1
  } : {}
);
var Tooltip2 = ({
  placement,
  hasChrome,
  children,
  arrowProps,
  tooltipRef,
  arrowRef,
  color,
  ...props
}) => {
  return /* @__PURE__ */ import_react3.default.createElement(Wrapper, {
    hasChrome,
    placement,
    ref: tooltipRef,
    ...props,
    color
  }, hasChrome && /* @__PURE__ */ import_react3.default.createElement(Arrow, {
    placement,
    ref: arrowRef,
    ...arrowProps,
    color
  }), children);
};
Tooltip2.defaultProps = {
  color: void 0,
  arrowRef: void 0,
  tooltipRef: void 0,
  hasChrome: true,
  placement: "top",
  arrowProps: {}
};
var { document: document2 } = import_global.default;
var TargetContainer = emotion_styled_browser_esm_default.div`
  display: inline-block;
  cursor: ${(props) => props.mode === "hover" ? "default" : "pointer"};
`;
var TargetSvgContainer = emotion_styled_browser_esm_default.g`
  cursor: ${(props) => props.mode === "hover" ? "default" : "pointer"};
`;
var WithTooltipPure = ({
  svg,
  trigger,
  closeOnClick,
  placement,
  modifiers,
  hasChrome,
  tooltip,
  children,
  tooltipShown,
  onVisibilityChange,
  ...props
}) => {
  const Container = svg ? TargetSvgContainer : TargetContainer;
  return /* @__PURE__ */ import_react.default.createElement(react_popper_tooltip_default, {
    placement,
    trigger,
    modifiers,
    tooltipShown,
    onVisibilityChange,
    tooltip: ({
      getTooltipProps,
      getArrowProps,
      tooltipRef,
      arrowRef,
      placement: tooltipPlacement
    }) => /* @__PURE__ */ import_react.default.createElement(Tooltip2, {
      hasChrome,
      placement: tooltipPlacement,
      tooltipRef,
      arrowRef,
      arrowProps: getArrowProps(),
      ...getTooltipProps()
    }, typeof tooltip === "function" ? tooltip({ onHide: () => onVisibilityChange(false) }) : tooltip)
  }, ({ getTriggerProps, triggerRef }) => /* @__PURE__ */ import_react.default.createElement(Container, {
    ref: triggerRef,
    ...getTriggerProps(),
    ...props
  }, children));
};
WithTooltipPure.defaultProps = {
  svg: false,
  trigger: "hover",
  closeOnClick: false,
  placement: "top",
  modifiers: [
    {
      name: "preventOverflow",
      options: {
        padding: 8
      }
    },
    {
      name: "offset",
      options: {
        offset: [8, 8]
      }
    },
    {
      name: "arrow",
      options: {
        padding: 8
      }
    }
  ],
  hasChrome: true,
  tooltipShown: false
};
var WithToolTipState = ({ startOpen, onVisibilityChange: onChange, ...rest }) => {
  const [tooltipShown, setTooltipShown] = (0, import_react.useState)(startOpen || false);
  const onVisibilityChange = (0, import_react.useCallback)(
    (visibility) => {
      if (onChange && onChange(visibility) === false)
        return;
      setTooltipShown(visibility);
    },
    [onChange]
  );
  (0, import_react.useEffect)(() => {
    const hide = () => onVisibilityChange(false);
    document2.addEventListener("keydown", hide, false);
    const iframes = Array.from(document2.getElementsByTagName("iframe"));
    const unbinders = [];
    iframes.forEach((iframe) => {
      const bind = () => {
        try {
          if (iframe.contentWindow.document) {
            iframe.contentWindow.document.addEventListener("click", hide);
            unbinders.push(() => {
              try {
                iframe.contentWindow.document.removeEventListener("click", hide);
              } catch (e) {
              }
            });
          }
        } catch (e) {
        }
      };
      bind();
      iframe.addEventListener("load", bind);
      unbinders.push(() => {
        iframe.removeEventListener("load", bind);
      });
    });
    return () => {
      document2.removeEventListener("keydown", hide);
      unbinders.forEach((unbind) => {
        unbind();
      });
    };
  });
  return /* @__PURE__ */ import_react.default.createElement(WithTooltipPure, {
    ...rest,
    tooltipShown,
    onVisibilityChange
  });
};
export {
  WithToolTipState,
  WithToolTipState as WithTooltip,
  WithTooltipPure
};
