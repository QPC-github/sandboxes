import {
  Channel,
  Provider,
  addons,
  dist_exports as dist_exports2,
  dist_exports2 as dist_exports3,
  dist_exports3 as dist_exports4,
  dist_exports4 as dist_exports6,
  dist_exports5 as dist_exports7,
  dist_exports6 as dist_exports8,
  isJSON,
  parse,
  renderStorybookUI,
  require_lib,
  src_default,
  stringify
} from "./chunk-VNDE67LE.mjs";
import {
  Keys
} from "./chunk-35ENMIDL.mjs";
import "./chunk-DFFVDB22.mjs";
import {
  require_react_dom
} from "./chunk-V72RELJZ.mjs";
import "./chunk-SXFHL5NO.mjs";
import {
  dist_exports,
  dist_exports2 as dist_exports5,
  logger,
  pretty,
  require_window
} from "./chunk-GLTUVBTF.mjs";
import {
  require_react
} from "./chunk-ZOCTBSY6.mjs";
import "./chunk-QJJTTS2V.mjs";
import "./chunk-BCVV5BM4.mjs";
import {
  __toESM,
  init_define_process_env
} from "./chunk-WHSM2MPW.mjs";

// src/runtime.ts
init_define_process_env();
var import_global3 = __toESM(require_window());

// ../channel-postmessage/dist/esm/index.js
init_define_process_env();
var import_global = __toESM(require_window());
var import_qs = __toESM(require_lib());
var {
  window: globalWindow,
  document,
  location
} = import_global.default;
var KEY = "storybook-channel";
var defaultEventOptions = {
  allowFunction: true,
  maxDepth: 25
};
var PostmsgTransport = class {
  constructor(config) {
    this.config = config;
    this.buffer = void 0;
    this.handler = void 0;
    this.connected = void 0;
    this.buffer = [];
    this.handler = null;
    if (globalWindow) {
      globalWindow.addEventListener("message", this.handleEvent.bind(this), false);
    }
    if (config.page !== "manager" && config.page !== "preview") {
      throw new Error(`postmsg-channel: "config.page" cannot be "${config.page}"`);
    }
  }
  setHandler(handler) {
    this.handler = (...args) => {
      handler.apply(this, args);
      if (!this.connected && this.getLocalFrame().length) {
        this.flush();
        this.connected = true;
      }
    };
  }
  send(event, options) {
    const {
      target,
      allowRegExp,
      allowFunction,
      allowSymbol,
      allowDate,
      allowUndefined,
      allowClass,
      maxDepth,
      space,
      lazyEval
    } = options || {};
    const eventOptions = Object.fromEntries(Object.entries({
      allowRegExp,
      allowFunction,
      allowSymbol,
      allowDate,
      allowUndefined,
      allowClass,
      maxDepth,
      space,
      lazyEval
    }).filter(([k, v]) => typeof v !== "undefined"));
    const stringifyOptions = Object.assign({}, defaultEventOptions, import_global.default.CHANNEL_OPTIONS || {}, eventOptions);
    const frames = this.getFrames(target);
    const query = import_qs.default.parse(location.search, {
      ignoreQueryPrefix: true
    });
    const data = stringify({
      key: KEY,
      event,
      refId: query.refId
    }, stringifyOptions);
    if (!frames.length) {
      return new Promise((resolve, reject) => {
        this.buffer.push({
          event,
          resolve,
          reject
        });
      });
    }
    if (this.buffer.length) {
      this.flush();
    }
    frames.forEach((f) => {
      try {
        f.postMessage(data, "*");
      } catch (e) {
        console.error("sending over postmessage fail");
      }
    });
    return Promise.resolve(null);
  }
  flush() {
    const {
      buffer
    } = this;
    this.buffer = [];
    buffer.forEach((item) => {
      this.send(item.event).then(item.resolve).catch(item.reject);
    });
  }
  getFrames(target) {
    if (this.config.page === "manager") {
      const nodes = [...document.querySelectorAll("iframe[data-is-storybook][data-is-loaded]")];
      const list = nodes.filter((e) => {
        try {
          return !!e.contentWindow && e.dataset.isStorybook !== void 0 && e.id === target;
        } catch (er) {
          return false;
        }
      }).map((e) => e.contentWindow);
      return list.length ? list : this.getCurrentFrames();
    }
    if (globalWindow && globalWindow.parent && globalWindow.parent !== globalWindow) {
      return [globalWindow.parent];
    }
    return [];
  }
  getCurrentFrames() {
    if (this.config.page === "manager") {
      const list = [...document.querySelectorAll('[data-is-storybook="true"]')];
      return list.map((e) => e.contentWindow);
    }
    if (globalWindow && globalWindow.parent) {
      return [globalWindow.parent];
    }
    return [];
  }
  getLocalFrame() {
    if (this.config.page === "manager") {
      const list = [...document.querySelectorAll("#storybook-preview-iframe")];
      return list.map((e) => e.contentWindow);
    }
    if (globalWindow && globalWindow.parent) {
      return [globalWindow.parent];
    }
    return [];
  }
  handleEvent(rawEvent) {
    try {
      const {
        data
      } = rawEvent;
      const {
        key,
        event,
        refId
      } = typeof data === "string" && isJSON(data) ? parse(data, import_global.default.CHANNEL_OPTIONS || {}) : data;
      if (key === KEY) {
        const pageString = this.config.page === "manager" ? `<span style="color: #37D5D3; background: black"> manager </span>` : `<span style="color: #1EA7FD; background: black"> preview </span>`;
        const eventString = Object.values(dist_exports3).includes(event.type) ? `<span style="color: #FF4785">${event.type}</span>` : `<span style="color: #FFAE00">${event.type}</span>`;
        if (refId) {
          event.refId = refId;
        }
        event.source = this.config.page === "preview" ? rawEvent.origin : getEventSourceUrl(rawEvent);
        if (!event.source) {
          pretty.error(`${pageString} received ${eventString} but was unable to determine the source of the event`);
          return;
        }
        const message = `${pageString} received ${eventString} (${data.length})`;
        pretty.debug(location.origin !== event.source ? message : `${message} <span style="color: gray">(on ${location.origin} from ${event.source})</span>`, ...event.args);
        this.handler(event);
      }
    } catch (error) {
      logger.error(error);
    }
  }
};
var getEventSourceUrl = (event) => {
  const frames = [...document.querySelectorAll("iframe[data-is-storybook]")];
  const [frame, ...remainder] = frames.filter((element) => {
    try {
      return element.contentWindow === event.source;
    } catch (err) {
    }
    const src = element.getAttribute("src");
    let origin;
    try {
      ({
        origin
      } = new URL(src, document.location));
    } catch (err) {
      return false;
    }
    return origin === event.origin;
  });
  if (frame && remainder.length === 0) {
    const src = frame.getAttribute("src");
    const {
      protocol,
      host,
      pathname
    } = new URL(src, document.location);
    return `${protocol}//${host}${pathname}`;
  }
  if (remainder.length > 0) {
    logger.error("found multiple candidates for event source");
  }
  return null;
};
function createChannel({
  page
}) {
  const transport = new PostmsgTransport({
    page
  });
  return new Channel({
    transport
  });
}

// ../channel-websocket/dist/esm/index.js
init_define_process_env();
var import_global2 = __toESM(require_window());
var {
  WebSocket
} = import_global2.default;
var WebsocketTransport = class {
  constructor({
    url,
    onError
  }) {
    this.socket = void 0;
    this.handler = void 0;
    this.buffer = [];
    this.isReady = false;
    this.connect(url, onError);
  }
  setHandler(handler) {
    this.handler = handler;
  }
  send(event) {
    if (!this.isReady) {
      this.sendLater(event);
    } else {
      this.sendNow(event);
    }
  }
  sendLater(event) {
    this.buffer.push(event);
  }
  sendNow(event) {
    const data = stringify(event, {
      maxDepth: 15,
      allowFunction: true
    });
    this.socket.send(data);
  }
  flush() {
    const {
      buffer
    } = this;
    this.buffer = [];
    buffer.forEach((event) => this.send(event));
  }
  connect(url, onError) {
    this.socket = new WebSocket(url);
    this.socket.onopen = () => {
      this.isReady = true;
      this.flush();
    };
    this.socket.onmessage = ({
      data
    }) => {
      const event = typeof data === "string" && isJSON(data) ? parse(data) : data;
      this.handler(event);
    };
    this.socket.onerror = (e) => {
      if (onError) {
        onError(e);
      }
    };
  }
};
function createChannel2({
  url,
  async = false,
  onError = (err) => logger.warn(err)
}) {
  const transport = new WebsocketTransport({
    url,
    onError
  });
  return new Channel({
    transport,
    async
  });
}

// src/globals/runtime.ts
init_define_process_env();
var REACT = __toESM(require_react());
var REACTDOM = __toESM(require_react_dom());
var values = {
  react: REACT,
  "react-dom": REACTDOM,
  "@storybook/components": dist_exports6,
  "@storybook/channels": dist_exports7,
  "@storybook/core-events": dist_exports3,
  "@storybook/router": dist_exports2,
  "@storybook/theming": dist_exports5,
  "@storybook/api": dist_exports4,
  "@storybook/addons": dist_exports8,
  "@storybook/client-logger": dist_exports
};

// src/runtime.ts
var { FEATURES, SERVER_CHANNEL_URL } = import_global3.default;
var ReactProvider = class extends Provider {
  constructor() {
    super();
    const channel = createChannel({ page: "manager" });
    addons.setChannel(channel);
    channel.emit(src_default.CHANNEL_CREATED);
    this.addons = addons;
    this.channel = channel;
    if (FEATURES?.storyStoreV7 && SERVER_CHANNEL_URL) {
      const serverChannel = createChannel2({ url: SERVER_CHANNEL_URL });
      this.serverChannel = serverChannel;
      addons.setServerChannel(this.serverChannel);
    }
  }
  getElements(type) {
    return this.addons.getElements(type);
  }
  getConfig() {
    return this.addons.getConfig();
  }
  handleAPI(api) {
    this.addons.loadAddons(api);
  }
};
var { document: document2 } = import_global3.default;
var rootEl = document2.getElementById("root");
renderStorybookUI(rootEl, new ReactProvider());
Object.keys(Keys).forEach((key) => {
  import_global3.default[Keys[key]] = values[key];
});
