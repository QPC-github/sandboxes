import C from"fs-extra";import{dedent as E}from"ts-dedent";import*as o from"@babel/types";import $ from"@babel/generator";import z from"@babel/traverse";import{toId as G,isExportStory as P,storyNameFromExport as k}from"@storybook/csf";import{parse as J}from"@babel/parser";var x=i=>J(i,{sourceType:"module",plugins:["jsx","typescript",["decorators",{decoratorsBeforeExport:!0}],"classProperties"],tokens:!0});var F=console;function K(i){if(o.isArrayExpression(i))return i.elements.map(t=>{if(o.isStringLiteral(t))return t.value;throw new Error(`Expected string literal: ${t}`)});if(o.isStringLiteral(i))return new RegExp(i.value);if(o.isRegExpLiteral(i))return new RegExp(i.pattern,i.flags);throw new Error(`Unknown include/exclude: ${i}`)}var b=(i,t)=>{let s=null,r=null;return t.body.find(e=>(o.isVariableDeclaration(e)?r=e.declarations:o.isExportNamedDeclaration(e)&&o.isVariableDeclaration(e.declaration)&&(r=e.declaration.declarations),r&&r.find(n=>o.isVariableDeclarator(n)&&o.isIdentifier(n.id)&&n.id.name===i?(s=n.init,!0):!1))),s},y=(i,t)=>{let{line:s,column:r}=i.loc.start;return`${t||""} (line ${s}, col ${r})`.trim()},V=(i,t,s)=>{let r=i;if(o.isCallExpression(i)){let{callee:e,arguments:n}=i;if(o.isProgram(t)&&o.isMemberExpression(e)&&o.isIdentifier(e.object)&&o.isIdentifier(e.property)&&e.property.name==="bind"&&(n.length===0||n.length===1&&o.isObjectExpression(n[0])&&n[0].properties.length===0)){let a=e.object.name,c=b(a,t);c&&(s._templates[a]=c,r=c)}}return o.isArrowFunctionExpression(r)||o.isFunctionDeclaration(r)?r.params.length>0:!1},Q=i=>{if(o.isArrayExpression(i))return i.elements.map(t=>{if(o.isStringLiteral(t))return t.value;throw new Error(`Expected string literal named export: ${t}`)});throw new Error(`Expected array of string literals: ${i}`)},A=(i,t)=>t.reduce((s,r)=>{let e=i[r];return e&&(s[r]=e),s},{}),O=class extends Error{constructor(t,s){super(E`
      CSF: missing default export ${y(t,s)}

      More info: https://storybook.js.org/docs/react/writing-stories/introduction#default-export
    `),this.name=this.constructor.name}},j=class{constructor(t,{fileName:s,makeTitle:r}){this._stories={};this._metaAnnotations={};this._storyExports={};this._storyAnnotations={};this._templates={};this._ast=t,this._fileName=s,this.imports=[],this._makeTitle=r}_parseTitle(t){let s=o.isIdentifier(t)?b(t.name,this._ast.program):t;if(o.isStringLiteral(s))return s.value;throw new Error(E`
      CSF: unexpected dynamic title ${y(s,this._fileName)}

      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#string-literal-titles
    `)}_parseMeta(t,s){let r={};t.properties.forEach(e=>{if(o.isIdentifier(e.key)){if(this._metaAnnotations[e.key.name]=e.value,e.key.name==="title")r.title=this._parseTitle(e.value);else if(["includeStories","excludeStories"].includes(e.key.name))r[e.key.name]=K(e.value);else if(e.key.name==="component"){let{code:n}=$(e.value,{});r.component=n}else if(e.key.name==="id")if(o.isStringLiteral(e.value))r.id=e.value.value;else throw new Error(`Unexpected component id: ${e.value}`)}}),this._meta=r}parse(){let t=this;if(z(this._ast,{ExportDefaultDeclaration:{enter({node:r,parent:e}){let n,a=o.isIdentifier(r.declaration)&&o.isProgram(e)?b(r.declaration.name,e):r.declaration;o.isObjectExpression(a)?n=a:o.isTSAsExpression(a)&&o.isObjectExpression(a.expression)&&(n=a.expression),!t._meta&&n&&o.isProgram(e)&&t._parseMeta(n,e)}},ExportNamedDeclaration:{enter({node:r,parent:e}){let n;o.isVariableDeclaration(r.declaration)?n=r.declaration.declarations.filter(a=>o.isVariableDeclarator(a)):o.isFunctionDeclaration(r.declaration)&&(n=[r.declaration]),n?n.forEach(a=>{if(o.isIdentifier(a.id)){let{name:c}=a.id;if(c==="__namedExportsOrder"&&o.isVariableDeclarator(a)){t._namedExportsOrder=Q(a.init);return}t._storyExports[c]=a;let m=k(c);t._storyAnnotations[c]?F.warn(`Unexpected annotations for "${c}" before story declaration`):t._storyAnnotations[c]={};let p;if(o.isVariableDeclarator(a)&&o.isObjectExpression(a.init)){let u=!0;a.init.properties.forEach(d=>{o.isIdentifier(d.key)&&(d.key.name==="render"?u=V(d.value,e,t):d.key.name==="name"&&o.isStringLiteral(d.value)?m=d.value.value:d.key.name==="storyName"&&o.isStringLiteral(d.value)&&F.warn(`Unexpected usage of "storyName" in "${c}". Please use "name" instead.`),t._storyAnnotations[c][d.key.name]=d.value)}),p={__isArgsStory:u}}else{let u=o.isVariableDeclarator(a)?a.init:a;p={__isArgsStory:V(u,e,t)}}t._stories[c]={id:"FIXME",name:m,parameters:p}}}):r.specifiers.length>0&&r.specifiers.forEach(a=>{if(o.isExportSpecifier(a)&&o.isIdentifier(a.exported)){let{name:c}=a.exported;if(c==="default"){let m,p=o.isProgram(e)?b(a.local.name,e):a.local;o.isObjectExpression(p)?m=p:o.isTSAsExpression(p)&&o.isObjectExpression(p.expression)&&(m=p.expression),!t._meta&&m&&o.isProgram(e)&&t._parseMeta(m,e)}else t._storyAnnotations[c]={},t._stories[c]={id:"FIXME",name:c,parameters:{}}}})}},ExpressionStatement:{enter({node:r,parent:e}){let{expression:n}=r;if(o.isProgram(e)&&o.isAssignmentExpression(n)&&o.isMemberExpression(n.left)&&o.isIdentifier(n.left.object)&&o.isIdentifier(n.left.property)){let a=n.left.object.name,c=n.left.property.name,m=n.right;if(t._storyAnnotations[a]&&(c==="story"&&o.isObjectExpression(m)?m.properties.forEach(p=>{o.isIdentifier(p.key)&&(t._storyAnnotations[a][p.key.name]=p.value)}):t._storyAnnotations[a][c]=m),c==="storyName"&&o.isStringLiteral(m)){let p=m.value,u=t._stories[a];if(!u)return;u.name=p}}}},CallExpression:{enter({node:r}){let{callee:e}=r;if(o.isIdentifier(e)&&e.name==="storiesOf")throw new Error(E`
              CSF: unexpected storiesOf call ${y(r,t._fileName)}

              More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#story-store-v7
            `)}},ImportDeclaration:{enter({node:r}){let{source:e}=r;if(o.isStringLiteral(e))t.imports.push(e.value);else throw new Error("CSF: unexpected import source")}}}),!t._meta)throw new O(t._ast,t._fileName);if(!t._meta.title&&!t._meta.component)throw new Error(E`
        CSF: missing title/component ${y(t._ast,t._fileName)}

        More info: https://storybook.js.org/docs/react/writing-stories/introduction#default-export
      `);let s=Object.entries(t._stories);if(t._meta.title=this._makeTitle(t._meta.title),t._stories=s.reduce((r,[e,n])=>{if(P(e,t._meta)){let a=G(t._meta.id||t._meta.title,k(e)),c={...n.parameters,__id:a};s.length===1&&e==="__page"&&(c.docsOnly=!0),r[e]={...n,id:a,parameters:c}}return r},{}),Object.keys(t._storyExports).forEach(r=>{P(r,t._meta)||(delete t._storyExports[r],delete t._storyAnnotations[r])}),t._namedExportsOrder){let r=Object.keys(t._storyExports);t._storyExports=A(t._storyExports,t._namedExportsOrder),t._stories=A(t._stories,t._namedExportsOrder);let e=Object.keys(t._storyExports);if(r.length!==e.length)throw new Error(`Missing exports after sort: ${r.filter(n=>!e.includes(n))}`)}return t}get meta(){return this._meta}get stories(){return Object.values(this._stories)}},X=(i,t)=>{let s=x(i);return new j(s,t)},B=i=>{let{code:t}=$(i._ast,{});return t},ct=async(i,t)=>{let s=(await C.readFile(i,"utf-8")).toString();return X(s,{...t,fileName:i})},ft=async(i,t)=>{if(!(t||i._fileName))throw new Error("Please specify a fileName for writeCsf");await C.writeFile(t,await B(i))};import T from"fs-extra";import*as l from"@babel/types";import N from"@babel/generator";import R from"@babel/traverse";var M=console,I=i=>l.isIdentifier(i.key)?i.key.name:l.isStringLiteral(i.key)?i.key.value:null,L=(i,t)=>{if(i.length===0)return t;if(l.isObjectExpression(t)){let[s,...r]=i,e=t.properties.find(n=>I(n)===s);if(e)return L(r,e.value)}},w=(i,t)=>{let s=null,r=null;return t.body.find(e=>(l.isVariableDeclaration(e)?r=e.declarations:l.isExportNamedDeclaration(e)&&l.isVariableDeclaration(e.declaration)&&(r=e.declaration.declarations),r&&r.find(n=>l.isVariableDeclarator(n)&&l.isIdentifier(n.id)&&n.id.name===i?(s=n.init,!0):!1))),s},_=(i,t)=>{if(i.length===0)return t;let[s,...r]=i,e=_(r,t);return l.objectExpression([l.objectProperty(l.identifier(s),e)])},S=(i,t,s)=>{let[r,...e]=i,n=s.properties.find(a=>I(a)===r);n?l.isObjectExpression(n.value)&&e.length>0?S(e,t,n.value):n.value=_(e,t):s.properties.push(l.objectProperty(l.identifier(r),_(e,t)))},v=class{constructor(t,s,r){this._exports={};this._ast=t,this._code=s,this.fileName=r}parse(){let t=this;return R(this._ast,{ExportNamedDeclaration:{enter({node:s,parent:r}){l.isVariableDeclaration(s.declaration)?s.declaration.declarations.forEach(e=>{if(l.isVariableDeclarator(e)&&l.isIdentifier(e.id)){let{name:n}=e.id,a=e.init;l.isIdentifier(a)&&(a=w(a.name,r)),t._exports[n]=a}}):M.warn(`Unexpected ${JSON.stringify(s)}`)}},ExpressionStatement:{enter({node:s,parent:r}){if(l.isAssignmentExpression(s.expression)&&s.expression.operator==="="){let{left:e,right:n}=s.expression;if(l.isMemberExpression(e)&&l.isIdentifier(e.object)&&e.object.name==="module"&&l.isIdentifier(e.property)&&e.property.name==="exports"){let a=n;l.isIdentifier(n)&&(a=w(n.name,r)),l.isObjectExpression(a)?(t._exportsObject=a,a.properties.forEach(c=>{let m=I(c);if(m){let p=c.value;l.isIdentifier(p)&&(p=w(p.name,r)),t._exports[m]=p}})):M.warn(`Unexpected ${JSON.stringify(s)}`)}}}}}),t}getFieldNode(t){let[s,...r]=t,e=this._exports[s];if(!!e)return L(r,e)}getFieldValue(t){let s=this.getFieldNode(t);if(s){let{code:r}=N(s,{});return(0,eval)(`(() => (${r}))()`)}}setFieldNode(t,s){let[r,...e]=t,n=this._exports[r];if(this._exportsObject)S(t,s,this._exportsObject),this._exports[t[0]]=s;else if(n&&l.isObjectExpression(n)&&e.length>0)S(e,s,n);else{let a=_(e,s),c=l.exportNamedDeclaration(l.variableDeclaration("const",[l.variableDeclarator(l.identifier(r),a)]));this._exports[r]=a,this._ast.program.body.push(c)}}_inferQuotes(){if(!this._quotes){let t=(this._ast.tokens||[]).slice(0,500).reduce((s,r)=>(r.type.label==="string"&&(s[this._code[r.start]]+=1),s),{"'":0,'"':0});this._quotes=t["'"]>t['"']?"single":"double"}return this._quotes}setFieldValue(t,s){let r=this._inferQuotes(),e;if(r==="single"){let{code:n}=N(l.valueToNode(s),{jsescOption:{quotes:r}}),a=x(`const __x = ${n}`);R(a,{VariableDeclaration:{enter({node:c}){c.declarations.length===1&&l.isVariableDeclarator(c.declarations[0])&&l.isIdentifier(c.declarations[0].id)&&c.declarations[0].id.name==="__x"&&(e=c.declarations[0].init)}}})}else e=l.valueToNode(s);if(!e)throw new Error(`Unexpected value ${JSON.stringify(s)}`);this.setFieldNode(t,e)}},H=(i,t)=>{let s=x(i);return new v(s,i,t)},W=i=>{let{code:t}=N(i._ast,{});return t},gt=async i=>{let t=(await T.readFile(i,"utf-8")).toString();return H(t,i).parse()},Et=async(i,t)=>{let s=t||i.fileName;if(!s)throw new Error("Please specify a fileName for writeConfig");await T.writeFile(s,await W(i))};import*as f from"@babel/types";import Y from"@babel/traverse";import U from"@babel/generator";import{dedent as Z}from"ts-dedent";var tt=console,q=(i,t)=>{let s;return i.properties.forEach(r=>{f.isIdentifier(r.key)&&r.key.name===t&&(s=r.value)}),s},D=i=>{if(f.isArrayExpression(i))return i.elements.map(t=>D(t));if(f.isObjectExpression(i))return i.properties.reduce((t,s)=>(f.isIdentifier(s.key)&&(t[s.key.name]=D(s.value)),t),{});if(f.isLiteral(i))return i.value;throw new Error(`Unknown node type ${i}`)},h=(i,t)=>{let s=Z`
    Unexpected '${i}'. Parameter 'options.storySort' should be defined inline e.g.:

    export const parameters = {
      options: {
        storySort: <array | object | function>
      }
    }
  `;if(t)throw new Error(s);tt.info(s)},jt=i=>{let t,s=x(i);if(Y(s,{ExportNamedDeclaration:{enter({node:r}){f.isVariableDeclaration(r.declaration)?r.declaration.declarations.forEach(e=>{if(f.isVariableDeclarator(e)&&f.isIdentifier(e.id)){let{name:n}=e.id;if(n==="parameters"){let a=f.isTSAsExpression(e.init)?e.init.expression:e.init;if(f.isObjectExpression(a)){let c=q(a,"options");c&&(f.isObjectExpression(c)?t=q(c,"storySort"):h("options",!0))}else h("parameters",!0)}}}):r.specifiers.forEach(e=>{f.isIdentifier(e.exported)&&e.exported.name==="parameters"&&h("parameters",!1)})}}}),!!t){if(f.isArrowFunctionExpression(t)){let{code:r}=U(t,{});return(0,eval)(r)}if(f.isFunctionExpression(t)){let{code:r}=U(t,{}),e=t.id.name,n=`(a, b) => {
      ${r};
      return ${e}(a, b)
    }`;return(0,eval)(n)}return f.isLiteral(t)||f.isArrayExpression(t)||f.isObjectExpression(t)?D(t):h("storySort",!0)}};export{v as ConfigFile,j as CsfFile,O as NoMetaError,W as formatConfig,B as formatCsf,jt as getStorySortParameter,H as loadConfig,X as loadCsf,gt as readConfig,ct as readCsf,Et as writeConfig,ft as writeCsf};
