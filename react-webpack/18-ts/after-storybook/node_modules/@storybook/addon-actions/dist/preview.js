"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/preview.ts
var preview_exports = {};
__export(preview_exports, {
  argsEnhancers: () => argsEnhancers,
  decorators: () => decorators
});
module.exports = __toCommonJS(preview_exports);

// src/runtime/withActions.ts
var import_global = __toESM(require("global"));
var import_addons2 = require("@storybook/addons");
var import_util_deprecate = __toESM(require("util-deprecate"));
var import_ts_dedent = require("ts-dedent");

// src/runtime/action.ts
var import_v4 = __toESM(require("uuid-browser/v4"));
var import_addons = require("@storybook/addons");

// src/constants.ts
var PARAM_KEY = "actions";
var ADDON_ID = "storybook/actions";
var PANEL_ID = `${ADDON_ID}/panel`;
var EVENT_ID = `${ADDON_ID}/action-event`;

// src/runtime/configureActions.ts
var config = {
  depth: 10,
  clearOnStoryChange: true,
  limit: 50
};

// src/runtime/action.ts
var findProto = (obj, callback) => {
  const proto = Object.getPrototypeOf(obj);
  if (!proto || callback(proto))
    return proto;
  return findProto(proto, callback);
};
var isReactSyntheticEvent = (e) => Boolean(
  typeof e === "object" && e && findProto(e, (proto) => /^Synthetic(?:Base)?Event$/.test(proto.constructor.name)) && typeof e.persist === "function"
);
var serializeArg = (a) => {
  if (isReactSyntheticEvent(a)) {
    const e = Object.create(
      a.constructor.prototype,
      Object.getOwnPropertyDescriptors(a)
    );
    e.persist();
    const viewDescriptor = Object.getOwnPropertyDescriptor(e, "view");
    const view = viewDescriptor == null ? void 0 : viewDescriptor.value;
    if (typeof view === "object" && (view == null ? void 0 : view.constructor.name) === "Window") {
      Object.defineProperty(e, "view", {
        ...viewDescriptor,
        value: Object.create(view.constructor.prototype)
      });
    }
    return e;
  }
  return a;
};
function action(name, options = {}) {
  const actionOptions = {
    ...config,
    ...options
  };
  const handler = function actionHandler(...args) {
    const channel = import_addons.addons.getChannel();
    const id = (0, import_v4.default)();
    const minDepth = 5;
    const serializedArgs = args.map(serializeArg);
    const normalizedArgs = args.length > 1 ? serializedArgs : serializedArgs[0];
    const actionDisplayToEmit = {
      id,
      count: 0,
      data: { name, args: normalizedArgs },
      options: {
        ...actionOptions,
        maxDepth: minDepth + (actionOptions.depth || 3),
        allowFunction: actionOptions.allowFunction || false
      }
    };
    channel.emit(EVENT_ID, actionDisplayToEmit);
  };
  handler.isAction = true;
  return handler;
}

// src/runtime/actions.ts
var actions = (...args) => {
  let options = config;
  let names = args;
  if (names.length === 1 && Array.isArray(names[0])) {
    [names] = names;
  }
  if (names.length !== 1 && typeof names[names.length - 1] !== "string") {
    options = {
      ...config,
      ...names.pop()
    };
  }
  let namesObject = names[0];
  if (names.length !== 1 || typeof namesObject === "string") {
    namesObject = {};
    names.forEach((name) => {
      namesObject[name] = name;
    });
  }
  const actionsObject = {};
  Object.keys(namesObject).forEach((name) => {
    actionsObject[name] = action(namesObject[name], options);
  });
  return actionsObject;
};

// src/runtime/withActions.ts
var { document, Element } = import_global.default;
var delegateEventSplitter = /^(\S+)\s*(.*)$/;
var isIE = Element != null && !Element.prototype.matches;
var matchesMethod = isIE ? "msMatchesSelector" : "matches";
var hasMatchInAncestry = (element, selector) => {
  if (element[matchesMethod](selector)) {
    return true;
  }
  const parent = element.parentElement;
  if (!parent) {
    return false;
  }
  return hasMatchInAncestry(parent, selector);
};
var createHandlers = (actionsFn, ...handles) => {
  const actionsObject = actionsFn(...handles);
  return Object.entries(actionsObject).map(([key, action2]) => {
    const [_, eventName, selector] = key.match(delegateEventSplitter) || [];
    return {
      eventName,
      handler: (e) => {
        if (!selector || hasMatchInAncestry(e.target, selector)) {
          action2(e);
        }
      }
    };
  });
};
var applyEventHandlers = (0, import_util_deprecate.default)(
  (actionsFn, ...handles) => {
    const root = document && document.getElementById("storybook-root");
    (0, import_addons2.useEffect)(() => {
      if (root != null) {
        const handlers = createHandlers(actionsFn, ...handles);
        handlers.forEach(({ eventName, handler }) => root.addEventListener(eventName, handler));
        return () => handlers.forEach(
          ({ eventName, handler }) => root.removeEventListener(eventName, handler)
        );
      }
      return void 0;
    }, [root, actionsFn, handles]);
  },
  import_ts_dedent.dedent`
    withActions(options) is deprecated, please configure addon-actions using the addParameter api:

    addParameters({
      actions: {
        handles: options
      },
    });
  `
);
var applyDeprecatedOptions = (actionsFn, options) => {
  if (options) {
    applyEventHandlers(actionsFn, options);
  }
};
var withActions = (0, import_addons2.makeDecorator)({
  name: "withActions",
  parameterName: PARAM_KEY,
  skipIfNoParametersOrOptions: true,
  wrapper: (getStory, context, { parameters, options }) => {
    applyDeprecatedOptions(actions, options);
    if (parameters && parameters.handles)
      applyEventHandlers(actions, ...parameters.handles);
    return getStory(context);
  }
});

// src/addDecorator.ts
var decorators = [withActions];

// src/addArgsHelpers.ts
var isInInitialArgs = (name, initialArgs) => typeof initialArgs[name] === "undefined" && !(name in initialArgs);
var inferActionsFromArgTypesRegex = (context) => {
  const {
    initialArgs,
    argTypes,
    parameters: { actions: actions2 }
  } = context;
  if (!actions2 || actions2.disable || !actions2.argTypesRegex || !argTypes) {
    return {};
  }
  const argTypesRegex = new RegExp(actions2.argTypesRegex);
  const argTypesMatchingRegex = Object.entries(argTypes).filter(
    ([name]) => !!argTypesRegex.test(name)
  );
  return argTypesMatchingRegex.reduce((acc, [name, argType]) => {
    if (isInInitialArgs(name, initialArgs)) {
      acc[name] = action(name);
    }
    return acc;
  }, {});
};
var addActionsFromArgTypes = (context) => {
  const {
    initialArgs,
    argTypes,
    parameters: { actions: actions2 }
  } = context;
  if ((actions2 == null ? void 0 : actions2.disable) || !argTypes) {
    return {};
  }
  const argTypesWithAction = Object.entries(argTypes).filter(([name, argType]) => !!argType.action);
  return argTypesWithAction.reduce((acc, [name, argType]) => {
    if (isInInitialArgs(name, initialArgs)) {
      acc[name] = action(typeof argType.action === "string" ? argType.action : name);
    }
    return acc;
  }, {});
};

// src/addArgs.ts
var argsEnhancers = [addActionsFromArgTypes, inferActionsFromArgTypesRegex];
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  argsEnhancers,
  decorators
});
