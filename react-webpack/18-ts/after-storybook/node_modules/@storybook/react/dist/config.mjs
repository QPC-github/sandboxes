import {
  render,
  renderToDOM
} from "./chunk-7HTWJPRS.mjs";

// src/docs/config.ts
import { extractComponentDescription, enhanceArgTypes } from "@storybook/docs-tools";

// src/docs/extractProps.ts
import PropTypes from "prop-types";
import { hasDocgen, extractComponentProps, TypeSystem } from "@storybook/docs-tools";

// src/docs/propTypes/createType.ts
import { createSummaryValue, isTooLongForTypeSummary } from "@storybook/docs-tools";

// src/docs/propTypes/generateFuncSignature.ts
function generateFuncSignature(params, returns) {
  const hasParams = params != null;
  const hasReturns = returns != null;
  if (!hasParams && !hasReturns) {
    return "";
  }
  const funcParts = [];
  if (hasParams) {
    const funcParams = params.map((x) => {
      const prettyName = x.getPrettyName();
      const typeName = x.getTypeName();
      if (typeName != null) {
        return `${prettyName}: ${typeName}`;
      }
      return prettyName;
    });
    funcParts.push(`(${funcParams.join(", ")})`);
  } else {
    funcParts.push("()");
  }
  if (hasReturns) {
    funcParts.push(`=> ${returns.getTypeName()}`);
  }
  return funcParts.join(" ");
}
function generateShortFuncSignature(params, returns) {
  const hasParams = params != null;
  const hasReturns = returns != null;
  if (!hasParams && !hasReturns) {
    return "";
  }
  const funcParts = [];
  if (hasParams) {
    funcParts.push("( ... )");
  } else {
    funcParts.push("()");
  }
  if (hasReturns) {
    funcParts.push(`=> ${returns.getTypeName()}`);
  }
  return funcParts.join(" ");
}
function toMultilineSignature(signature) {
  return signature.replace(/,/g, ",\r\n");
}

// src/docs/lib/captions.ts
var CUSTOM_CAPTION = "custom";
var OBJECT_CAPTION = "object";
var ARRAY_CAPTION = "array";
var CLASS_CAPTION = "class";
var FUNCTION_CAPTION = "func";
var ELEMENT_CAPTION = "element";

// src/docs/lib/isHtmlTag.ts
import htmlTags from "html-tags";
function isHtmlTag(tagName) {
  return htmlTags.includes(tagName.toLowerCase());
}

// src/docs/lib/generateCode.ts
import { generate } from "escodegen";
import { dedent } from "ts-dedent";
var BASIC_OPTIONS = {
  format: {
    indent: {
      style: "  "
    },
    semicolons: false
  }
};
var COMPACT_OPTIONS = {
  ...BASIC_OPTIONS,
  format: {
    newline: ""
  }
};
var PRETTY_OPTIONS = {
  ...BASIC_OPTIONS
};
function generateCode(ast, compact = false) {
  return generate(ast, compact ? COMPACT_OPTIONS : PRETTY_OPTIONS);
}
function generateObjectCode(ast, compact = false) {
  return !compact ? generateCode(ast) : generateCompactObjectCode(ast);
}
function generateCompactObjectCode(ast) {
  let result = generateCode(ast, true);
  if (!result.endsWith(" }")) {
    result = `${result.slice(0, -1)} }`;
  }
  return result;
}
function generateArrayCode(ast, compact = false) {
  return !compact ? generateMultilineArrayCode(ast) : generateCompactArrayCode(ast);
}
function generateMultilineArrayCode(ast) {
  let result = generateCode(ast);
  if (result.endsWith("  }]")) {
    result = dedent(result);
  }
  return result;
}
function generateCompactArrayCode(ast) {
  let result = generateCode(ast, true);
  if (result.startsWith("[    ")) {
    result = result.replace("[    ", "[");
  }
  return result;
}

// src/docs/lib/componentTypes.ts
var isMemo = (component) => component.$$typeof === Symbol.for("react.memo");
var isForwardRef = (component) => component.$$typeof === Symbol.for("react.forward_ref");

// src/docs/lib/inspection/acornParser.ts
import { Parser } from "acorn";
import jsx from "acorn-jsx";
import * as acornWalk from "acorn-walk";
var ACORN_WALK_VISITORS = {
  ...acornWalk.base,
  JSXElement: () => {
  }
};
var acornParser = Parser.extend(jsx());
function extractIdentifierName(identifierNode) {
  return identifierNode != null ? identifierNode.name : null;
}
function filterAncestors(ancestors) {
  return ancestors.filter((x) => x.type === "ObjectExpression" || x.type === "ArrayExpression");
}
function calculateNodeDepth(node) {
  const depths = [];
  acornWalk.ancestor(
    node,
    {
      ObjectExpression(_, ancestors) {
        depths.push(filterAncestors(ancestors).length);
      },
      ArrayExpression(_, ancestors) {
        depths.push(filterAncestors(ancestors).length);
      }
    },
    ACORN_WALK_VISITORS
  );
  return Math.max(...depths);
}
function parseIdentifier(identifierNode) {
  return {
    inferredType: {
      type: "Identifier" /* IDENTIFIER */,
      identifier: extractIdentifierName(identifierNode)
    },
    ast: identifierNode
  };
}
function parseLiteral(literalNode) {
  return {
    inferredType: { type: "Literal" /* LITERAL */ },
    ast: literalNode
  };
}
function parseFunction(funcNode) {
  let innerJsxElementNode;
  acornWalk.simple(
    funcNode.body,
    {
      JSXElement(node) {
        innerJsxElementNode = node;
      }
    },
    ACORN_WALK_VISITORS
  );
  const isJsx = innerJsxElementNode != null;
  const inferredType = {
    type: isJsx ? "Element" /* ELEMENT */ : "Function" /* FUNCTION */,
    params: funcNode.params,
    hasParams: funcNode.params.length !== 0
  };
  const identifierName = extractIdentifierName(funcNode.id);
  if (identifierName != null) {
    inferredType.identifier = identifierName;
  }
  return {
    inferredType,
    ast: funcNode
  };
}
function parseClass(classNode) {
  let innerJsxElementNode;
  acornWalk.simple(
    classNode.body,
    {
      JSXElement(node) {
        innerJsxElementNode = node;
      }
    },
    ACORN_WALK_VISITORS
  );
  const inferredType = {
    type: innerJsxElementNode != null ? "Element" /* ELEMENT */ : "Class" /* CLASS */,
    identifier: extractIdentifierName(classNode.id)
  };
  return {
    inferredType,
    ast: classNode
  };
}
function parseJsxElement(jsxElementNode) {
  const inferredType = {
    type: "Element" /* ELEMENT */
  };
  const identifierName = extractIdentifierName(jsxElementNode.openingElement.name);
  if (identifierName != null) {
    inferredType.identifier = identifierName;
  }
  return {
    inferredType,
    ast: jsxElementNode
  };
}
function parseCall(callNode) {
  const identifierNode = callNode.callee.type === "MemberExpression" ? callNode.callee.property : callNode.callee;
  const identifierName = extractIdentifierName(identifierNode);
  if (identifierName === "shape") {
    return parseObject(callNode.arguments[0]);
  }
  return null;
}
function parseObject(objectNode) {
  return {
    inferredType: { type: "Object" /* OBJECT */, depth: calculateNodeDepth(objectNode) },
    ast: objectNode
  };
}
function parseArray(arrayNode) {
  return {
    inferredType: { type: "Array" /* ARRAY */, depth: calculateNodeDepth(arrayNode) },
    ast: arrayNode
  };
}
function parseExpression(expression) {
  switch (expression.type) {
    case "Identifier":
      return parseIdentifier(expression);
    case "Literal":
      return parseLiteral(expression);
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      return parseFunction(expression);
    case "ClassExpression":
      return parseClass(expression);
    case "JSXElement":
      return parseJsxElement(expression);
    case "CallExpression":
      return parseCall(expression);
    case "ObjectExpression":
      return parseObject(expression);
    case "ArrayExpression":
      return parseArray(expression);
    default:
      return null;
  }
}
function parse(value) {
  const ast = acornParser.parse(`(${value})`);
  let parsingResult = {
    inferredType: { type: "Unknown" /* UNKNOWN */ },
    ast
  };
  if (ast.body[0] != null) {
    const rootNode = ast.body[0];
    switch (rootNode.type) {
      case "ExpressionStatement": {
        const expressionResult = parseExpression(rootNode.expression);
        if (expressionResult != null) {
          parsingResult = expressionResult;
        }
        break;
      }
      default:
        break;
    }
  }
  return parsingResult;
}

// src/docs/lib/inspection/inspectValue.ts
function inspectValue(value) {
  try {
    const parsingResult = parse(value);
    return { ...parsingResult };
  } catch (e) {
  }
  return { inferredType: { type: "Unknown" /* UNKNOWN */ } };
}

// src/docs/propTypes/createType.ts
var MAX_FUNC_LENGTH = 150;
function createTypeDef({
  name,
  short,
  compact,
  full,
  inferredType
}) {
  return {
    name,
    short,
    compact,
    full: full != null ? full : short,
    inferredType
  };
}
function cleanPropTypes(value) {
  return value.replace(/PropTypes./g, "").replace(/.isRequired/g, "");
}
function splitIntoLines(value) {
  return value.split(/\r?\n/);
}
function prettyObject(ast, compact = false) {
  return cleanPropTypes(generateObjectCode(ast, compact));
}
function prettyArray(ast, compact = false) {
  return cleanPropTypes(generateCode(ast, compact));
}
function getCaptionForInspectionType(type) {
  switch (type) {
    case "Object" /* OBJECT */:
      return OBJECT_CAPTION;
    case "Array" /* ARRAY */:
      return ARRAY_CAPTION;
    case "Class" /* CLASS */:
      return CLASS_CAPTION;
    case "Function" /* FUNCTION */:
      return FUNCTION_CAPTION;
    case "Element" /* ELEMENT */:
      return ELEMENT_CAPTION;
    default:
      return CUSTOM_CAPTION;
  }
}
function generateTypeFromString(value, originalTypeName) {
  const { inferredType, ast } = inspectValue(value);
  const { type } = inferredType;
  let short;
  let compact;
  let full;
  switch (type) {
    case "Identifier" /* IDENTIFIER */:
    case "Literal" /* LITERAL */:
      short = value;
      compact = value;
      break;
    case "Object" /* OBJECT */: {
      const { depth } = inferredType;
      short = OBJECT_CAPTION;
      compact = depth === 1 ? prettyObject(ast, true) : null;
      full = prettyObject(ast);
      break;
    }
    case "Element" /* ELEMENT */: {
      const { identifier } = inferredType;
      short = identifier != null && !isHtmlTag(identifier) ? identifier : ELEMENT_CAPTION;
      compact = splitIntoLines(value).length === 1 ? value : null;
      full = value;
      break;
    }
    case "Array" /* ARRAY */: {
      const { depth } = inferredType;
      short = ARRAY_CAPTION;
      compact = depth <= 2 ? prettyArray(ast, true) : null;
      full = prettyArray(ast);
      break;
    }
    default:
      short = getCaptionForInspectionType(type);
      compact = splitIntoLines(value).length === 1 ? value : null;
      full = value;
      break;
  }
  return createTypeDef({
    name: originalTypeName,
    short,
    compact,
    full,
    inferredType: type
  });
}
function generateCustom({ raw }) {
  if (raw != null) {
    return generateTypeFromString(raw, "custom" /* CUSTOM */);
  }
  return createTypeDef({
    name: "custom" /* CUSTOM */,
    short: CUSTOM_CAPTION,
    compact: CUSTOM_CAPTION
  });
}
function generateFunc(extractedProp) {
  const { jsDocTags } = extractedProp;
  if (jsDocTags != null) {
    if (jsDocTags.params != null || jsDocTags.returns != null) {
      return createTypeDef({
        name: "func" /* FUNC */,
        short: generateShortFuncSignature(jsDocTags.params, jsDocTags.returns),
        compact: null,
        full: generateFuncSignature(jsDocTags.params, jsDocTags.returns)
      });
    }
  }
  return createTypeDef({
    name: "func" /* FUNC */,
    short: FUNCTION_CAPTION,
    compact: FUNCTION_CAPTION
  });
}
function generateShape(type, extractedProp) {
  const fields = Object.keys(type.value).map((key) => `${key}: ${generateType(type.value[key], extractedProp).full}`).join(", ");
  const { inferredType, ast } = inspectValue(`{ ${fields} }`);
  const { depth } = inferredType;
  return createTypeDef({
    name: "shape" /* SHAPE */,
    short: OBJECT_CAPTION,
    compact: depth === 1 && ast ? prettyObject(ast, true) : null,
    full: ast ? prettyObject(ast) : null
  });
}
function objectOf(of) {
  return `objectOf(${of})`;
}
function generateObjectOf(type, extractedProp) {
  const { short, compact, full } = generateType(type.value, extractedProp);
  return createTypeDef({
    name: "objectOf" /* OBJECTOF */,
    short: objectOf(short),
    compact: compact != null ? objectOf(compact) : null,
    full: full ? objectOf(full) : full
  });
}
function generateUnion(type, extractedProp) {
  if (Array.isArray(type.value)) {
    const values = type.value.reduce(
      (acc, v) => {
        const { short, compact, full } = generateType(v, extractedProp);
        acc.short.push(short);
        acc.compact.push(compact);
        acc.full.push(full);
        return acc;
      },
      { short: [], compact: [], full: [] }
    );
    return createTypeDef({
      name: "union" /* UNION */,
      short: values.short.join(" | "),
      compact: values.compact.every((x) => x != null) ? values.compact.join(" | ") : null,
      full: values.full.join(" | ")
    });
  }
  return createTypeDef({ name: "union" /* UNION */, short: type.value, compact: null });
}
function generateEnumValue({ value, computed }) {
  return computed ? generateTypeFromString(value, "enumvalue") : createTypeDef({ name: "enumvalue", short: value, compact: value });
}
function generateEnum(type) {
  if (Array.isArray(type.value)) {
    const values = type.value.reduce(
      (acc, v) => {
        const { short, compact, full } = generateEnumValue(v);
        acc.short.push(short);
        acc.compact.push(compact);
        acc.full.push(full);
        return acc;
      },
      { short: [], compact: [], full: [] }
    );
    return createTypeDef({
      name: "enum" /* ENUM */,
      short: values.short.join(" | "),
      compact: values.compact.every((x) => x != null) ? values.compact.join(" | ") : null,
      full: values.full.join(" | ")
    });
  }
  return createTypeDef({ name: "enum" /* ENUM */, short: type.value, compact: type.value });
}
function braceAfter(of) {
  return `${of}[]`;
}
function braceAround(of) {
  return `[${of}]`;
}
function createArrayOfObjectTypeDef(short, compact, full) {
  return createTypeDef({
    name: "arrayOf" /* ARRAYOF */,
    short: braceAfter(short),
    compact: compact != null ? braceAround(compact) : null,
    full: full ? braceAround(full) : full
  });
}
function generateArray(type, extractedProp) {
  const { name, short, compact, full, inferredType } = generateType(type.value, extractedProp);
  if (name === "custom" /* CUSTOM */) {
    if (inferredType === "Object" /* OBJECT */) {
      return createArrayOfObjectTypeDef(short, compact, full);
    }
  } else if (name === "shape" /* SHAPE */) {
    return createArrayOfObjectTypeDef(short, compact, full);
  }
  return createTypeDef({
    name: "arrayOf" /* ARRAYOF */,
    short: braceAfter(short),
    compact: braceAfter(short)
  });
}
function generateType(type, extractedProp) {
  try {
    switch (type.name) {
      case "custom" /* CUSTOM */:
        return generateCustom(type);
      case "func" /* FUNC */:
        return generateFunc(extractedProp);
      case "shape" /* SHAPE */:
        return generateShape(type, extractedProp);
      case "instanceOf" /* INSTANCEOF */:
        return createTypeDef({
          name: "instanceOf" /* INSTANCEOF */,
          short: type.value,
          compact: type.value
        });
      case "objectOf" /* OBJECTOF */:
        return generateObjectOf(type, extractedProp);
      case "union" /* UNION */:
        return generateUnion(type, extractedProp);
      case "enum" /* ENUM */:
        return generateEnum(type);
      case "arrayOf" /* ARRAYOF */:
        return generateArray(type, extractedProp);
      default:
        return createTypeDef({ name: type.name, short: type.name, compact: type.name });
    }
  } catch (e) {
    console.error(e);
  }
  return createTypeDef({ name: "unknown", short: "unknown", compact: "unknown" });
}
function createType(extractedProp) {
  const { type } = extractedProp.docgenInfo;
  if (type == null) {
    return null;
  }
  try {
    switch (type.name) {
      case "custom" /* CUSTOM */:
      case "shape" /* SHAPE */:
      case "instanceOf" /* INSTANCEOF */:
      case "objectOf" /* OBJECTOF */:
      case "union" /* UNION */:
      case "enum" /* ENUM */:
      case "arrayOf" /* ARRAYOF */: {
        const { short, compact, full } = generateType(type, extractedProp);
        if (compact != null) {
          if (!isTooLongForTypeSummary(compact)) {
            return createSummaryValue(compact);
          }
        }
        return full ? createSummaryValue(short, full) : createSummaryValue(short);
      }
      case "func" /* FUNC */: {
        const { short, full } = generateType(type, extractedProp);
        let summary = short;
        let detail;
        if (full && full.length < MAX_FUNC_LENGTH) {
          summary = full;
        } else if (full) {
          detail = toMultilineSignature(full);
        }
        return createSummaryValue(summary, detail);
      }
      default:
        return null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
}

// src/docs/lib/defaultValues/createDefaultValue.ts
import {
  createSummaryValue as createSummaryValue4,
  isTooLongForDefaultValueSummary as isTooLongForDefaultValueSummary3
} from "@storybook/docs-tools";

// src/docs/lib/defaultValues/generateObject.ts
import {
  createSummaryValue as createSummaryValue2,
  isTooLongForDefaultValueSummary
} from "@storybook/docs-tools";
function generateObject({ inferredType, ast }) {
  const { depth } = inferredType;
  if (depth === 1) {
    const compactObject = generateObjectCode(ast, true);
    if (!isTooLongForDefaultValueSummary(compactObject)) {
      return createSummaryValue2(compactObject);
    }
  }
  return createSummaryValue2(OBJECT_CAPTION, generateObjectCode(ast));
}

// src/docs/lib/defaultValues/generateArray.ts
import {
  createSummaryValue as createSummaryValue3,
  isTooLongForDefaultValueSummary as isTooLongForDefaultValueSummary2
} from "@storybook/docs-tools";
function generateArray2({ inferredType, ast }) {
  const { depth } = inferredType;
  if (depth <= 2) {
    const compactArray = generateArrayCode(ast, true);
    if (!isTooLongForDefaultValueSummary2(compactArray)) {
      return createSummaryValue3(compactArray);
    }
  }
  return createSummaryValue3(ARRAY_CAPTION, generateArrayCode(ast));
}

// src/docs/lib/defaultValues/prettyIdentifier.ts
function getPrettyFuncIdentifier(identifier, hasArguments) {
  return hasArguments ? `${identifier}( ... )` : `${identifier}()`;
}
function getPrettyElementIdentifier(identifier) {
  return `<${identifier} />`;
}
function getPrettyIdentifier(inferredType) {
  const { type, identifier } = inferredType;
  switch (type) {
    case "Function" /* FUNCTION */:
      return getPrettyFuncIdentifier(identifier, inferredType.hasParams);
    case "Element" /* ELEMENT */:
      return getPrettyElementIdentifier(identifier);
    default:
      return identifier;
  }
}

// src/docs/lib/defaultValues/createDefaultValue.ts
function generateFunc2({ inferredType, ast }) {
  const { identifier } = inferredType;
  if (identifier != null) {
    return createSummaryValue4(
      getPrettyIdentifier(inferredType),
      generateCode(ast)
    );
  }
  const prettyCaption = generateCode(ast, true);
  return !isTooLongForDefaultValueSummary3(prettyCaption) ? createSummaryValue4(prettyCaption) : createSummaryValue4(FUNCTION_CAPTION, generateCode(ast));
}
function generateElement(defaultValue, inspectionResult) {
  const { inferredType } = inspectionResult;
  const { identifier } = inferredType;
  if (identifier != null) {
    if (!isHtmlTag(identifier)) {
      const prettyIdentifier = getPrettyIdentifier(
        inferredType
      );
      return createSummaryValue4(prettyIdentifier, defaultValue);
    }
  }
  return !isTooLongForDefaultValueSummary3(defaultValue) ? createSummaryValue4(defaultValue) : createSummaryValue4(ELEMENT_CAPTION, defaultValue);
}
function createDefaultValue(defaultValue) {
  try {
    const inspectionResult = inspectValue(defaultValue);
    switch (inspectionResult.inferredType.type) {
      case "Object" /* OBJECT */:
        return generateObject(inspectionResult);
      case "Function" /* FUNCTION */:
        return generateFunc2(inspectionResult);
      case "Element" /* ELEMENT */:
        return generateElement(defaultValue, inspectionResult);
      case "Array" /* ARRAY */:
        return generateArray2(inspectionResult);
      default:
        return null;
    }
  } catch (e) {
    console.error(e);
  }
  return null;
}

// src/docs/lib/defaultValues/createFromRawDefaultProp.ts
import isPlainObject from "lodash/isPlainObject";
import isFunction from "lodash/isFunction";
import isString from "lodash/isString";
import reactElementToJSXString from "react-element-to-jsx-string";
import {
  createSummaryValue as createSummaryValue5,
  isTooLongForDefaultValueSummary as isTooLongForDefaultValueSummary4
} from "@storybook/docs-tools";
function isReactElement(element) {
  return element.$$typeof != null;
}
function extractFunctionName(func, propName) {
  const { name } = func;
  if (name !== "" && name !== "anonymous" && name !== propName) {
    return name;
  }
  return null;
}
var stringResolver = (rawDefaultProp) => {
  return createSummaryValue5(JSON.stringify(rawDefaultProp));
};
function generateReactObject(rawDefaultProp) {
  const { type } = rawDefaultProp;
  const { displayName } = type;
  const jsx2 = reactElementToJSXString(rawDefaultProp, {});
  if (displayName != null) {
    const prettyIdentifier = getPrettyElementIdentifier(displayName);
    return createSummaryValue5(prettyIdentifier, jsx2);
  }
  if (isString(type)) {
    if (isHtmlTag(type)) {
      const jsxCompact = reactElementToJSXString(rawDefaultProp, { tabStop: 0 });
      const jsxSummary = jsxCompact.replace(/\r?\n|\r/g, "");
      if (!isTooLongForDefaultValueSummary4(jsxSummary)) {
        return createSummaryValue5(jsxSummary);
      }
    }
  }
  return createSummaryValue5(ELEMENT_CAPTION, jsx2);
}
var objectResolver = (rawDefaultProp) => {
  if (isReactElement(rawDefaultProp) && rawDefaultProp.type != null) {
    return generateReactObject(rawDefaultProp);
  }
  if (isPlainObject(rawDefaultProp)) {
    const inspectionResult = inspectValue(JSON.stringify(rawDefaultProp));
    return generateObject(inspectionResult);
  }
  if (Array.isArray(rawDefaultProp)) {
    const inspectionResult = inspectValue(JSON.stringify(rawDefaultProp));
    return generateArray2(inspectionResult);
  }
  return createSummaryValue5(OBJECT_CAPTION);
};
var functionResolver = (rawDefaultProp, propDef) => {
  let isElement = false;
  let inspectionResult;
  if (isFunction(rawDefaultProp.render)) {
    isElement = true;
  } else if (rawDefaultProp.prototype != null && isFunction(rawDefaultProp.prototype.render)) {
    isElement = true;
  } else {
    let innerElement;
    try {
      inspectionResult = inspectValue(rawDefaultProp.toString());
      const { hasParams, params } = inspectionResult.inferredType;
      if (hasParams) {
        if (params.length === 1 && params[0].type === "ObjectPattern") {
          innerElement = rawDefaultProp({});
        }
      } else {
        innerElement = rawDefaultProp();
      }
      if (innerElement != null) {
        if (isReactElement(innerElement)) {
          isElement = true;
        }
      }
    } catch (e) {
    }
  }
  const funcName = extractFunctionName(rawDefaultProp, propDef.name);
  if (funcName != null) {
    if (isElement) {
      return createSummaryValue5(getPrettyElementIdentifier(funcName));
    }
    if (inspectionResult != null) {
      inspectionResult = inspectValue(rawDefaultProp.toString());
    }
    const { hasParams } = inspectionResult.inferredType;
    return createSummaryValue5(getPrettyFuncIdentifier(funcName, hasParams));
  }
  return createSummaryValue5(isElement ? ELEMENT_CAPTION : FUNCTION_CAPTION);
};
var defaultResolver = (rawDefaultProp) => {
  return createSummaryValue5(rawDefaultProp.toString());
};
var DEFAULT_TYPE_RESOLVERS = {
  string: stringResolver,
  object: objectResolver,
  function: functionResolver,
  default: defaultResolver
};
function createTypeResolvers(customResolvers = {}) {
  return {
    ...DEFAULT_TYPE_RESOLVERS,
    ...customResolvers
  };
}
function createDefaultValueFromRawDefaultProp(rawDefaultProp, propDef, typeResolvers = DEFAULT_TYPE_RESOLVERS) {
  try {
    switch (typeof rawDefaultProp) {
      case "string":
        return typeResolvers.string(rawDefaultProp, propDef);
      case "object":
        return typeResolvers.object(rawDefaultProp, propDef);
      case "function": {
        return typeResolvers.function(rawDefaultProp, propDef);
      }
      default:
        return typeResolvers.default(rawDefaultProp, propDef);
    }
  } catch (e) {
    console.error(e);
  }
  return null;
}

// src/docs/propTypes/sortProps.ts
function keepOriginalDefinitionOrder(extractedProps, component) {
  const { propTypes } = component;
  if (propTypes != null) {
    return Object.keys(propTypes).map((x) => extractedProps.find((y) => y.name === x)).filter(Boolean);
  }
  return extractedProps;
}

// src/docs/propTypes/rawDefaultPropResolvers.ts
import { createSummaryValue as createSummaryValue6 } from "@storybook/docs-tools";
var funcResolver = (rawDefaultProp, { name, type }) => {
  const isElement = type.summary === "element" || type.summary === "elementType";
  const funcName = extractFunctionName(rawDefaultProp, name);
  if (funcName != null) {
    if (isElement) {
      return createSummaryValue6(getPrettyElementIdentifier(funcName));
    }
    const { hasParams } = inspectValue(rawDefaultProp.toString()).inferredType;
    return createSummaryValue6(getPrettyFuncIdentifier(funcName, hasParams));
  }
  return createSummaryValue6(isElement ? ELEMENT_CAPTION : FUNCTION_CAPTION);
};
var rawDefaultPropTypeResolvers = createTypeResolvers({
  function: funcResolver
});

// src/docs/propTypes/handleProp.ts
function enhancePropTypesProp(extractedProp, rawDefaultProp) {
  const { propDef } = extractedProp;
  const newtype = createType(extractedProp);
  if (newtype != null) {
    propDef.type = newtype;
  }
  const { defaultValue } = extractedProp.docgenInfo;
  if (defaultValue != null && defaultValue.value != null) {
    const newDefaultValue = createDefaultValue(defaultValue.value);
    if (newDefaultValue != null) {
      propDef.defaultValue = newDefaultValue;
    }
  } else if (rawDefaultProp != null) {
    const newDefaultValue = createDefaultValueFromRawDefaultProp(
      rawDefaultProp,
      propDef,
      rawDefaultPropTypeResolvers
    );
    if (newDefaultValue != null) {
      propDef.defaultValue = newDefaultValue;
    }
  }
  return propDef;
}
function enhancePropTypesProps(extractedProps, component) {
  const rawDefaultProps = component.defaultProps != null ? component.defaultProps : {};
  const enhancedProps = extractedProps.map(
    (x) => enhancePropTypesProp(x, rawDefaultProps[x.propDef.name])
  );
  return keepOriginalDefinitionOrder(enhancedProps, component);
}

// src/docs/typeScript/handleProp.ts
function enhanceTypeScriptProp(extractedProp, rawDefaultProp) {
  const { propDef } = extractedProp;
  const { defaultValue } = extractedProp.docgenInfo;
  if (defaultValue != null && defaultValue.value != null) {
    const newDefaultValue = createDefaultValue(defaultValue.value);
    if (newDefaultValue != null) {
      propDef.defaultValue = newDefaultValue;
    }
  } else if (rawDefaultProp != null) {
    const newDefaultValue = createDefaultValueFromRawDefaultProp(rawDefaultProp, propDef);
    if (newDefaultValue != null) {
      propDef.defaultValue = newDefaultValue;
    }
  }
  return propDef;
}
function enhanceTypeScriptProps(extractedProps) {
  return extractedProps.map((prop) => enhanceTypeScriptProp(prop));
}

// src/docs/extractProps.ts
var propTypesMap = /* @__PURE__ */ new Map();
Object.keys(PropTypes).forEach((typeName) => {
  const type = PropTypes[typeName];
  propTypesMap.set(type, typeName);
  propTypesMap.set(type.isRequired, typeName);
});
function getPropDefs(component, section) {
  let processedComponent = component;
  if (!hasDocgen(component) && !component.propTypes && isMemo(component)) {
    processedComponent = component.type;
  }
  const extractedProps = extractComponentProps(processedComponent, section);
  if (extractedProps.length === 0) {
    return [];
  }
  switch (extractedProps[0].typeSystem) {
    case TypeSystem.JAVASCRIPT:
      return enhancePropTypesProps(extractedProps, component);
    case TypeSystem.TYPESCRIPT:
      return enhanceTypeScriptProps(extractedProps);
    default:
      return extractedProps.map((x) => x.propDef);
  }
}
var extractProps = (component) => ({
  rows: getPropDefs(component, "props")
});

// src/docs/extractArgTypes.ts
var extractArgTypes = (component) => {
  if (component) {
    const { rows } = extractProps(component);
    if (rows) {
      return rows.reduce((acc, row) => {
        const {
          name,
          description,
          type,
          sbType,
          defaultValue: defaultSummary,
          jsDocTags,
          required
        } = row;
        acc[name] = {
          name,
          description,
          type: { required, ...sbType },
          table: {
            type,
            jsDocTags,
            defaultValue: defaultSummary
          }
        };
        return acc;
      }, {});
    }
  }
  return null;
};

// src/docs/jsxDecorator.tsx
import React, { createElement } from "react";
import reactElementToJSXString2 from "react-element-to-jsx-string";
import { dedent as dedent2 } from "ts-dedent";
import deprecate from "util-deprecate";
import { addons, useEffect } from "@storybook/addons";
import { SourceType, SNIPPET_RENDERED, getDocgenSection } from "@storybook/docs-tools";
import { logger } from "@storybook/client-logger";
var applyBeforeRender = (domString, options) => {
  if (typeof options.onBeforeRender !== "function") {
    return domString;
  }
  const deprecatedOnBeforeRender = deprecate(
    options.onBeforeRender,
    dedent2`
      StoryFn.parameters.jsx.onBeforeRender was deprecated.
      Prefer StoryFn.parameters.jsx.transformSource instead.
      See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-onbeforerender for details.
    `
  );
  return deprecatedOnBeforeRender(domString);
};
var applyTransformSource = (domString, options, context) => {
  if (typeof options.transformSource !== "function") {
    return domString;
  }
  return options.transformSource(domString, context);
};
var renderJsx = (code, options) => {
  if (typeof code === "undefined") {
    logger.warn("Too many skip or undefined component");
    return null;
  }
  let renderedJSX = code;
  const Type = renderedJSX.type;
  for (let i = 0; i < options.skip; i += 1) {
    if (typeof renderedJSX === "undefined") {
      logger.warn("Cannot skip undefined element");
      return null;
    }
    if (React.Children.count(renderedJSX) > 1) {
      logger.warn("Trying to skip an array of elements");
      return null;
    }
    if (typeof renderedJSX.props.children === "undefined") {
      logger.warn("Not enough children to skip elements.");
      if (typeof renderedJSX.type === "function" && renderedJSX.type.name === "") {
        renderedJSX = /* @__PURE__ */ React.createElement(Type, {
          ...renderedJSX.props
        });
      }
    } else if (typeof renderedJSX.props.children === "function") {
      renderedJSX = renderedJSX.props.children();
    } else {
      renderedJSX = renderedJSX.props.children;
    }
  }
  const displayNameDefaults = typeof options.displayName === "string" ? { showFunctions: true, displayName: () => options.displayName } : {
    displayName: (el) => el.type.displayName || getDocgenSection(el.type, "displayName") || (el.type.name !== "_default" ? el.type.name : null) || (typeof el.type === "function" ? "No Display Name" : null) || (isForwardRef(el.type) ? el.type.render.name : null) || (isMemo(el.type) ? el.type.type.name : null) || el.type
  };
  const filterDefaults = {
    filterProps: (value, key) => value !== void 0
  };
  const opts = {
    ...displayNameDefaults,
    ...filterDefaults,
    ...options
  };
  const result = React.Children.map(code, (c) => {
    const child = typeof c === "number" ? c.toString() : c;
    const toJSXString = typeof reactElementToJSXString2 === "function" ? reactElementToJSXString2 : reactElementToJSXString2.default;
    let string = applyBeforeRender(toJSXString(child, opts), options);
    if (string.indexOf("&quot;") > -1) {
      const matches = string.match(/\S+=\\"([^"]*)\\"/g);
      if (matches) {
        matches.forEach((match) => {
          string = string.replace(match, match.replace(/&quot;/g, "'"));
        });
      }
    }
    return string;
  }).join("\n");
  return result.replace(/function\s+noRefCheck\(\)\s+\{\}/, "() => {}");
};
var defaultOpts = {
  skip: 0,
  showFunctions: false,
  enableBeautify: true,
  showDefaultProps: false
};
var skipJsxRender = (context) => {
  const sourceParams = context?.parameters.docs?.source;
  const isArgsStory = context?.parameters.__isArgsStory;
  if (sourceParams?.type === SourceType.DYNAMIC) {
    return false;
  }
  return !isArgsStory || sourceParams?.code || sourceParams?.type === SourceType.CODE;
};
var isMdx = (node) => node.type?.displayName === "MDXCreateElement" && !!node.props?.mdxType;
var mdxToJsx = (node) => {
  if (!isMdx(node))
    return node;
  const { mdxType, originalType, children, ...rest } = node.props;
  let jsxChildren = [];
  if (children) {
    const array = Array.isArray(children) ? children : [children];
    jsxChildren = array.map(mdxToJsx);
  }
  return createElement(originalType, rest, ...jsxChildren);
};
var jsxDecorator = (storyFn, context) => {
  const channel = addons.getChannel();
  const skip = skipJsxRender(context);
  let jsx2 = "";
  useEffect(() => {
    if (!skip) {
      channel.emit(SNIPPET_RENDERED, (context || {}).id, jsx2);
    }
  });
  const story = storyFn();
  if (skip) {
    return story;
  }
  const options = {
    ...defaultOpts,
    ...context?.parameters.jsx || {}
  };
  const storyJsx = context?.parameters.docs?.source?.excludeDecorators ? context.originalStoryFn(context.args, context) : story;
  const sourceJsx = mdxToJsx(storyJsx);
  const rendered = renderJsx(sourceJsx, options);
  if (rendered) {
    jsx2 = applyTransformSource(rendered, options, context);
  }
  return story;
};

// src/docs/config.ts
var parameters = {
  docs: {
    inlineStories: true,
    extractArgTypes,
    extractComponentDescription
  }
};
var decorators = [jsxDecorator];
var argTypesEnhancers = [enhanceArgTypes];

// src/config.ts
var parameters2 = {
  framework: "react",
  ...parameters
};
export {
  argTypesEnhancers,
  decorators,
  parameters2 as parameters,
  render,
  renderToDOM
};
