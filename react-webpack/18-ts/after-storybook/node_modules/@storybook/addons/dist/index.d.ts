import { ReactElement } from 'react';
import { Channel } from '@storybook/channels';
export { Channel } from '@storybook/channels';
import { API } from '@storybook/api';
import { RenderData } from '@storybook/router';
import { ThemeVars } from '@storybook/theming';
import { InputType, Args, StoryId, AnyFramework, StoryContext as StoryContext$1, PartialStoryFn as PartialStoryFn$1, LegacyStoryFn as LegacyStoryFn$1, ArgsStoryFn as ArgsStoryFn$1, StoryFn as StoryFn$1, DecoratorFunction as DecoratorFunction$1, LoaderFunction as LoaderFunction$1, StoryKind, StoryName, ComponentTitle, DecoratorApplicator } from '@storybook/csf';
export { Args, StoryId, StoryIdentifier, StoryKind, StoryName, ViewMode } from '@storybook/csf';

interface ArgType<TArg = unknown> extends InputType {
    defaultValue?: TArg;
}
declare type ArgTypes<TArgs = Args> = {
    [key in keyof Partial<TArgs>]: ArgType<TArgs[key]>;
} & {
    [key in string]: ArgType<unknown>;
};
declare type Comparator<T> = ((a: T, b: T) => boolean) | ((a: T, b: T) => number);
declare type StorySortMethod = 'configure' | 'alphabetical';
interface StorySortObjectParameter {
    method?: StorySortMethod;
    order?: any[];
    locales?: string;
    includeNames?: boolean;
}
declare type Path = string;
interface BaseIndexEntry {
    id: StoryId;
    name: StoryName;
    title: ComponentTitle;
    importPath: Path;
}
declare type StoryIndexEntry = BaseIndexEntry & {
    type: 'story';
};
declare type DocsIndexEntry = BaseIndexEntry & {
    storiesImports: Path[];
    type: 'docs';
    standalone: boolean;
};
/** A StandaloneDocsIndexExtry represents a file who's default export is directly renderable */
declare type StandaloneDocsIndexEntry = DocsIndexEntry & {
    standalone: true;
};
/** A TemplateDocsIndexEntry represents a stories file that gets rendered in "docs" mode */
declare type TemplateDocsIndexEntry = DocsIndexEntry & {
    standalone: false;
};
declare type IndexEntry = StoryIndexEntry | DocsIndexEntry;
declare type IndexEntryLegacy = [StoryId, any, Parameters, Parameters];
declare type StorySortComparator = Comparator<IndexEntryLegacy>;
declare type StorySortParameter = StorySortComparator | StorySortObjectParameter;
declare type StorySortComparatorV7 = Comparator<IndexEntry>;
declare type StorySortParameterV7 = StorySortComparatorV7 | StorySortObjectParameter;
interface OptionsParameter extends Object {
    storySort?: StorySortParameter;
    theme?: {
        base: string;
        brandTitle?: string;
    };
    [key: string]: any;
}
interface Parameters {
    fileName?: string;
    options?: OptionsParameter;
    /** The layout property defines basic styles added to the preview body where the story is rendered. If you pass 'none', no styles are applied. */
    layout?: 'centered' | 'fullscreen' | 'padded' | 'none';
    docsOnly?: boolean;
    [key: string]: any;
}
declare type StoryContext<TFramework extends AnyFramework = AnyFramework> = StoryContext$1<TFramework>;
declare type StoryContextUpdate = Partial<StoryContext>;
declare type ReturnTypeFramework<ReturnType> = {
    component: any;
    storyResult: ReturnType;
};
declare type PartialStoryFn<ReturnType = unknown> = PartialStoryFn$1<ReturnTypeFramework<ReturnType>>;
declare type LegacyStoryFn<ReturnType = unknown> = LegacyStoryFn$1<ReturnTypeFramework<ReturnType>>;
declare type ArgsStoryFn<ReturnType = unknown> = ArgsStoryFn$1<ReturnTypeFramework<ReturnType>>;
declare type StoryFn<ReturnType = unknown> = StoryFn$1<ReturnTypeFramework<ReturnType>>;
declare type DecoratorFunction<StoryFnReturnType = unknown> = DecoratorFunction$1<ReturnTypeFramework<StoryFnReturnType>>;
declare type LoaderFunction = LoaderFunction$1<ReturnTypeFramework<unknown>>;
declare enum types {
    TAB = "tab",
    PANEL = "panel",
    TOOL = "tool",
    TOOLEXTRA = "toolextra",
    PREVIEW = "preview",
    NOTES_ELEMENT = "notes-element"
}
declare type Types = types | string;
declare function isSupportedType(type: Types): boolean;
interface WrapperSettings {
    options: object;
    parameters: {
        [key: string]: any;
    };
}
declare type StoryWrapper = (storyFn: LegacyStoryFn, context: StoryContext, settings: WrapperSettings) => any;
declare type MakeDecoratorResult$1 = (...args: any) => any;
interface AddStoryArgs<StoryFnReturnType = unknown> {
    id: StoryId;
    kind: StoryKind;
    name: StoryName;
    storyFn: StoryFn<StoryFnReturnType>;
    parameters: Parameters;
}
interface ClientApiAddon<StoryFnReturnType = unknown> extends Addon {
    apply: (a: StoryApi<StoryFnReturnType>, b: any[]) => any;
}
interface ClientApiAddons<StoryFnReturnType> {
    [key: string]: ClientApiAddon<StoryFnReturnType>;
}
declare type ClientApiReturnFn<StoryFnReturnType = unknown> = (...args: any[]) => StoryApi<StoryFnReturnType>;
interface StoryApi<StoryFnReturnType = unknown> {
    kind: StoryKind;
    add: (storyName: StoryName, storyFn: StoryFn<StoryFnReturnType>, parameters?: Parameters) => StoryApi<StoryFnReturnType>;
    addDecorator: (decorator: DecoratorFunction<StoryFnReturnType>) => StoryApi<StoryFnReturnType>;
    addLoader: (decorator: LoaderFunction) => StoryApi<StoryFnReturnType>;
    addParameters: (parameters: Parameters) => StoryApi<StoryFnReturnType>;
    [k: string]: string | ClientApiReturnFn<StoryFnReturnType>;
}
interface ClientStoryApi<StoryFnReturnType = unknown> {
    storiesOf(kind: StoryKind, module: any): StoryApi<StoryFnReturnType>;
}
declare type LoadFn = () => any;
declare type RequireContext = any;
declare type Loadable = RequireContext | [RequireContext] | LoadFn;
declare type BaseDecorators<StoryFnReturnType> = Array<(story: () => StoryFnReturnType, context: StoryContext) => StoryFnReturnType>;
interface BaseAnnotations<Args, StoryFnReturnType> {
    /**
     * Dynamic data that are provided (and possibly updated by) Storybook and its addons.
     * @see [Arg story inputs](https://storybook.js.org/docs/react/api/csf#args-story-inputs)
     */
    args?: Partial<Args>;
    /**
     * ArgTypes encode basic metadata for args, such as `name`, `description`, `defaultValue` for an arg. These get automatically filled in by Storybook Docs.
     * @see [Control annotations](https://github.com/storybookjs/storybook/blob/91e9dee33faa8eff0b342a366845de7100415367/addons/controls/README.md#control-annotations)
     */
    argTypes?: ArgTypes<Args>;
    /**
     * Custom metadata for a story.
     * @see [Parameters](https://storybook.js.org/docs/basics/writing-stories/#parameters)
     */
    parameters?: Parameters;
    /**
     * Wrapper components or Storybook decorators that wrap a story.
     *
     * Decorators defined in Meta will be applied to every story variation.
     * @see [Decorators](https://storybook.js.org/docs/addons/introduction/#1-decorators)
     */
    decorators?: BaseDecorators<StoryFnReturnType>;
    /**
     * Define a custom render function for the story(ies). If not passed, a default render function by the framework will be used.
     */
    render?: (args: Args, context: StoryContext) => StoryFnReturnType;
    /**
     * Function that is executed after the story is rendered.
     */
    play?: (context: StoryContext) => Promise<void> | void;
}
interface Annotations<Args, StoryFnReturnType> extends BaseAnnotations<Args, StoryFnReturnType> {
    /**
     * Used to only include certain named exports as stories. Useful when you want to have non-story exports such as mock data or ignore a few stories.
     * @example
     * includeStories: ['SimpleStory', 'ComplexStory']
     * includeStories: /.*Story$/
     *
     * @see [Non-story exports](https://storybook.js.org/docs/formats/component-story-format/#non-story-exports)
     */
    includeStories?: string[] | RegExp;
    /**
     * Used to exclude certain named exports. Useful when you want to have non-story exports such as mock data or ignore a few stories.
     * @example
     * excludeStories: ['simpleData', 'complexData']
     * excludeStories: /.*Data$/
     *
     * @see [Non-story exports](https://storybook.js.org/docs/formats/component-story-format/#non-story-exports)
     */
    excludeStories?: string[] | RegExp;
}
interface BaseMeta<ComponentType> {
    /**
     * Title of the story which will be presented in the navigation. **Should be unique.**
     *
     * Stories can be organized in a nested structure using "/" as a separator.
     *
     * Since CSF 3.0 this property is optional.
     *
     * @example
     * export default {
     *   ...
     *   title: 'Design System/Atoms/Button'
     * }
     *
     * @see [Story Hierarchy](https://storybook.js.org/docs/basics/writing-stories/#story-hierarchy)
     */
    title?: string;
    /**
     * Manually set the id of a story, which in particular is useful if you want to rename stories without breaking permalinks.
     *
     * Storybook will prioritize the id over the title for ID generation, if provided, and will prioritize the story.storyName over the export key for display.
     *
     * @see [Sidebar and URLs](https://storybook.js.org/docs/react/configure/sidebar-and-urls#permalinking-to-stories)
     */
    id?: string;
    /**
     * The primary component for your story.
     *
     * Used by addons for automatic prop table generation and display of other component metadata.
     */
    component?: ComponentType;
    /**
     * Auxiliary subcomponents that are part of the stories.
     *
     * Used by addons for automatic prop table generation and display of other component metadata.
     *
     * @example
     * import { Button, ButtonGroup } from './components';
     *
     * export default {
     *   ...
     *   subcomponents: { Button, ButtonGroup }
     * }
     *
     * By defining them each component will have its tab in the args table.
     */
    subcomponents?: Record<string, ComponentType>;
}
declare type BaseStoryObject<Args, StoryFnReturnType> = {
    /**
     * Override the display name in the UI
     */
    storyName?: string;
};
declare type BaseStoryFn<Args, StoryFnReturnType> = {
    (args: Args, context: StoryContext): StoryFnReturnType;
} & BaseStoryObject<Args, StoryFnReturnType>;
declare type BaseStory<Args, StoryFnReturnType> = BaseStoryFn<Args, StoryFnReturnType> | BaseStoryObject<Args, StoryFnReturnType>;

interface RenderOptions {
    active?: boolean;
    key?: string;
}
interface Addon {
    title: (() => string) | string;
    type?: Types;
    id?: string;
    route?: (routeOptions: RenderData) => string;
    match?: (matchOptions: RenderData) => boolean;
    render: (renderOptions: RenderOptions) => ReactElement<any> | null;
    paramKey?: string;
    disabled?: boolean;
    hidden?: boolean;
}
declare type Loader = (api: API) => void;
interface Collection {
    [key: string]: Addon;
}
interface ToolbarConfig {
    hidden?: boolean;
}
interface Config {
    theme?: ThemeVars;
    toolbar?: {
        [id: string]: ToolbarConfig;
    };
    [key: string]: any;
}
declare class AddonStore {
    constructor();
    private loaders;
    private elements;
    private config;
    private channel;
    private serverChannel;
    private promise;
    private resolve;
    getChannel: () => Channel;
    getServerChannel: () => Channel;
    ready: () => Promise<Channel>;
    hasChannel: () => boolean;
    hasServerChannel: () => boolean;
    setChannel: (channel: Channel) => void;
    setServerChannel: (channel: Channel) => void;
    getElements: (type: Types) => Collection;
    addPanel: (name: string, options: Addon) => void;
    add: (name: string, addon: Addon) => void;
    setConfig: (value: Config) => void;
    getConfig: () => Config;
    register: (name: string, registerCallback: (api: API) => void) => void;
    loadAddons: (api: any) => void;
}
declare const addons: AddonStore;

declare type MakeDecoratorResult = (...args: any) => any;
interface MakeDecoratorOptions {
    name: string;
    parameterName: string;
    skipIfNoParametersOrOptions?: boolean;
    wrapper: StoryWrapper;
}
declare const makeDecorator: ({ name, parameterName, wrapper, skipIfNoParametersOrOptions, }: MakeDecoratorOptions) => MakeDecoratorResult;

declare function mockChannel(): Channel;

interface Hook {
    name: string;
    memoizedState?: any;
    deps?: any[] | undefined;
}
interface Effect {
    create: () => (() => void) | void;
    destroy?: (() => void) | void;
}
declare type AbstractFunction = (...args: any[]) => any;
declare class HooksContext<TFramework extends AnyFramework> {
    hookListsMap: WeakMap<AbstractFunction, Hook[]>;
    mountedDecorators: Set<AbstractFunction>;
    prevMountedDecorators: Set<AbstractFunction>;
    currentHooks: Hook[];
    nextHookIndex: number;
    currentPhase: 'MOUNT' | 'UPDATE' | 'NONE';
    currentEffects: Effect[];
    prevEffects: Effect[];
    currentDecoratorName: string | null;
    hasUpdates: boolean;
    currentContext: StoryContext$1<TFramework> | null;
    renderListener: (storyId: StoryId) => void;
    constructor();
    init(): void;
    clean(): void;
    getNextHook(): Hook;
    triggerEffects(): void;
    addRenderListeners(): void;
    removeRenderListeners(): void;
}
declare const applyHooks: <TFramework extends AnyFramework>(applyDecorators: DecoratorApplicator<TFramework, Args>) => DecoratorApplicator<TFramework, Args>;
declare function useMemo<T>(nextCreate: () => T, deps?: any[]): T;
declare function useCallback<T>(callback: T, deps?: any[]): T;
declare function useRef<T>(initialValue: T): {
    current: T;
};
declare function useState<S>(initialState: (() => S) | S): [S, (update: ((prevState: S) => S) | S) => void];
declare function useReducer<S, A>(reducer: (state: S, action: A) => S, initialState: S): [S, (action: A) => void];
declare function useReducer<S, I, A>(reducer: (state: S, action: A) => S, initialArg: I, init: (initialArg: I) => S): [S, (action: A) => void];
declare function useEffect(create: () => (() => void) | void, deps?: any[]): void;
interface Listener {
    (...args: any[]): void;
}
interface EventMap {
    [eventId: string]: Listener;
}
declare function useChannel(eventMap: EventMap, deps?: any[]): (eventName: string, ...args: any) => void;
declare function useStoryContext<TFramework extends AnyFramework>(): StoryContext$1<TFramework>;
declare function useParameter<S>(parameterKey: string, defaultValue?: S): S | undefined;
declare function useArgs<SpecificArgs = Args>(): [
    SpecificArgs,
    (newArgs: Partial<SpecificArgs>) => void,
    (argNames?: (keyof SpecificArgs)[]) => void
];
declare function useGlobals(): [Args, (newGlobals: Args) => void];

export { AddStoryArgs, Addon, AddonStore, Annotations, ArgType, ArgTypes, ArgsStoryFn, BaseAnnotations, BaseDecorators, BaseMeta, BaseStory, BaseStoryFn, BaseStoryObject, ClientApiAddon, ClientApiAddons, ClientApiReturnFn, ClientStoryApi, Collection, Comparator, Config, DecoratorFunction, DocsIndexEntry, EventMap, HooksContext, IndexEntry, IndexEntryLegacy, LegacyStoryFn, Listener, Loadable, Loader, LoaderFunction, MakeDecoratorResult$1 as MakeDecoratorResult, OptionsParameter, Parameters, PartialStoryFn, RenderOptions, StandaloneDocsIndexEntry, StoryApi, StoryContext, StoryContextUpdate, StoryFn, StoryIndexEntry, StorySortComparator, StorySortComparatorV7, StorySortMethod, StorySortObjectParameter, StorySortParameter, StorySortParameterV7, StoryWrapper, TemplateDocsIndexEntry, Types, WrapperSettings, addons, applyHooks, addons as default, isSupportedType, makeDecorator, mockChannel, types, useArgs, useCallback, useChannel, useEffect, useGlobals, useMemo, useParameter, useReducer, useRef, useState, useStoryContext };
