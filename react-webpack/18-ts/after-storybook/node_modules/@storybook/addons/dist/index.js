var _=Object.create;var l=Object.defineProperty;var B=Object.getOwnPropertyDescriptor;var U=Object.getOwnPropertyNames;var j=Object.getPrototypeOf,K=Object.prototype.hasOwnProperty;var $=(r,e)=>{for(var t in e)l(r,t,{get:e[t],enumerable:!0})},C=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of U(e))!K.call(r,o)&&o!==t&&l(r,o,{get:()=>e[o],enumerable:!(n=B(e,o))||n.enumerable});return r};var E=(r,e,t)=>(t=r!=null?_(j(r)):{},C(e||!r||!r.__esModule?l(t,"default",{value:r,enumerable:!0}):t,r)),W=r=>C(l({},"__esModule",{value:!0}),r);var ye={};$(ye,{AddonStore:()=>S,Channel:()=>v.Channel,HooksContext:()=>A,addons:()=>y,applyHooks:()=>X,default:()=>ie,isSupportedType:()=>Y,makeDecorator:()=>G,mockChannel:()=>k,types:()=>T,useArgs:()=>ae,useCallback:()=>d,useChannel:()=>oe,useEffect:()=>M,useGlobals:()=>se,useMemo:()=>Q,useParameter:()=>ne,useReducer:()=>te,useRef:()=>Z,useState:()=>re,useStoryContext:()=>g});module.exports=W(ye);var m=E(require("global")),v=require("@storybook/channels"),O=require("@storybook/core-events"),D=require("@storybook/client-logger");var b=require("@storybook/channels");function k(){let r={setHandler:()=>{},send:()=>{}};return new b.Channel({transport:r})}var T=(s=>(s.TAB="tab",s.PANEL="panel",s.TOOL="tool",s.TOOLEXTRA="toolextra",s.PREVIEW="preview",s.NOTES_ELEMENT="notes-element",s))(T||{});function Y(r){return!!Object.values(T).find(e=>e===r)}var S=class{constructor(){this.loaders={};this.elements={};this.config={};this.getChannel=()=>(this.channel||this.setChannel(k()),this.channel);this.getServerChannel=()=>{if(!this.serverChannel)throw new Error("Accessing non-existent serverChannel");return this.serverChannel};this.ready=()=>this.promise;this.hasChannel=()=>!!this.channel;this.hasServerChannel=()=>!!this.serverChannel;this.setChannel=e=>{this.channel=e,this.resolve()};this.setServerChannel=e=>{this.serverChannel=e};this.getElements=e=>(this.elements[e]||(this.elements[e]={}),this.elements[e]);this.addPanel=(e,t)=>{this.add(e,{type:"panel",...t})};this.add=(e,t)=>{let{type:n}=t,o=this.getElements(n);o[e]={id:e,...t}};this.setConfig=e=>{Object.assign(this.config,e),this.hasChannel()&&this.getChannel().emit(O.SET_CONFIG,e)};this.getConfig=()=>this.config;this.register=(e,t)=>{this.loaders[e]&&D.logger.warn(`${e} was loaded twice, this could have bad side-effects`),this.loaders[e]=t};this.loadAddons=e=>{Object.values(this.loaders).forEach(t=>t(e))};this.promise=new Promise(e=>{this.resolve=()=>e(this.getChannel())})}},x="__STORYBOOK_ADDONS";function V(){return m.default[x]||(m.default[x]=new S),m.default[x]}var y=V();var G=({name:r,parameterName:e,wrapper:t,skipIfNoParametersOrOptions:n=!1})=>{let o=a=>(s,c)=>{let p=c.parameters&&c.parameters[e];return p&&p.disable||n&&!a&&!p?s(c):t(s,c,{options:a,parameters:p})};return(...a)=>typeof a[0]=="function"?o()(...a):(...s)=>{if(s.length>1)return a.length>1?o(a)(...s):o(...a)(...s);throw new Error(`Passing stories directly into ${r}() is not allowed,
        instead use addDecorator(${r}) and pass options with the '${e}' parameter`)}};var L=E(require("global")),u=require("@storybook/client-logger"),i=require("@storybook/core-events");var{window:f}=L.default,A=class{constructor(){this.renderListener=e=>{e===this.currentContext.id&&(this.triggerEffects(),this.currentContext=null,this.removeRenderListeners())};this.init()}init(){this.hookListsMap=new WeakMap,this.mountedDecorators=new Set,this.prevMountedDecorators=this.mountedDecorators,this.currentHooks=[],this.nextHookIndex=0,this.currentPhase="NONE",this.currentEffects=[],this.prevEffects=[],this.currentDecoratorName=null,this.hasUpdates=!1,this.currentContext=null}clean(){this.prevEffects.forEach(e=>{e.destroy&&e.destroy()}),this.init(),this.removeRenderListeners()}getNextHook(){let e=this.currentHooks[this.nextHookIndex];return this.nextHookIndex+=1,e}triggerEffects(){this.prevEffects.forEach(e=>{!this.currentEffects.includes(e)&&e.destroy&&e.destroy()}),this.currentEffects.forEach(e=>{this.prevEffects.includes(e)||(e.destroy=e.create())}),this.prevEffects=this.currentEffects,this.currentEffects=[]}addRenderListeners(){this.removeRenderListeners(),y.getChannel().on(i.STORY_RENDERED,this.renderListener)}removeRenderListeners(){y.getChannel().removeListener(i.STORY_RENDERED,this.renderListener)}};function P(r){return(...e)=>{let{hooks:t}=typeof e[0]=="function"?e[1]:e[0],n=t.currentPhase,o=t.currentHooks,a=t.nextHookIndex,s=t.currentDecoratorName;t.currentDecoratorName=r.name,t.prevMountedDecorators.has(r)?(t.currentPhase="UPDATE",t.currentHooks=t.hookListsMap.get(r)||[]):(t.currentPhase="MOUNT",t.currentHooks=[],t.hookListsMap.set(r,t.currentHooks),t.prevMountedDecorators.add(r)),t.nextHookIndex=0;let c=f.STORYBOOK_HOOKS_CONTEXT;f.STORYBOOK_HOOKS_CONTEXT=t;let p=r(...e);if(f.STORYBOOK_HOOKS_CONTEXT=c,t.currentPhase==="UPDATE"&&t.getNextHook()!=null)throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");return t.currentPhase=n,t.currentHooks=o,t.nextHookIndex=a,t.currentDecoratorName=s,p}}var F=0,z=25,X=r=>(e,t)=>{let n=r(P(e),t.map(o=>P(o)));return o=>{let{hooks:a}=o;a.prevMountedDecorators=a.mountedDecorators,a.mountedDecorators=new Set([e,...t]),a.currentContext=o,a.hasUpdates=!1;let s=n(o);for(F=1;a.hasUpdates;)if(a.hasUpdates=!1,a.currentEffects=[],s=n(o),F+=1,F>z)throw new Error("Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.");return a.addRenderListeners(),s}},q=(r,e)=>r.length===e.length&&r.every((t,n)=>t===e[n]),w=()=>new Error("Storybook preview hooks can only be called inside decorators and story functions.");function I(){return f.STORYBOOK_HOOKS_CONTEXT||null}function R(){let r=I();if(r==null)throw w();return r}function J(r,e,t){let n=R();if(n.currentPhase==="MOUNT"){t!=null&&!Array.isArray(t)&&u.logger.warn(`${r} received a final argument that is not an array (instead, received ${t}). When specified, the final argument must be an array.`);let o={name:r,deps:t};return n.currentHooks.push(o),e(o),o}if(n.currentPhase==="UPDATE"){let o=n.getNextHook();if(o==null)throw new Error("Rendered more hooks than during the previous render.");return o.name!==r&&u.logger.warn(`Storybook has detected a change in the order of Hooks${n.currentDecoratorName?` called by ${n.currentDecoratorName}`:""}. This will lead to bugs and errors if not fixed.`),t!=null&&o.deps==null&&u.logger.warn(`${r} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`),t!=null&&o.deps!=null&&t.length!==o.deps.length&&u.logger.warn(`The final argument passed to ${r} changed size between renders. The order and size of this array must remain constant.
Previous: ${o.deps}
Incoming: ${t}`),(t==null||o.deps==null||!q(t,o.deps))&&(e(o),o.deps=t),o}throw w()}function h(r,e,t){let{memoizedState:n}=J(r,o=>{o.memoizedState=e()},t);return n}function Q(r,e){return h("useMemo",r,e)}function d(r,e){return h("useCallback",()=>r,e)}function N(r,e){return h(r,()=>({current:e}),[])}function Z(r){return N("useRef",r)}function ee(){let r=I();if(r!=null&&r.currentPhase!=="NONE")r.hasUpdates=!0;else try{y.getChannel().emit(i.FORCE_RE_RENDER)}catch{u.logger.warn("State updates of Storybook preview hooks work only in browser")}}function H(r,e){let t=N(r,typeof e=="function"?e():e),n=o=>{t.current=typeof o=="function"?o(t.current):o,ee()};return[t.current,n]}function re(r){return H("useState",r)}function te(r,e,t){let n=t!=null?()=>t(e):e,[o,a]=H("useReducer",n);return[o,c=>a(p=>r(p,c))]}function M(r,e){let t=R(),n=h("useEffect",()=>({create:r}),e);t.currentEffects.includes(n)||t.currentEffects.push(n)}function oe(r,e=[]){let t=y.getChannel();return M(()=>(Object.entries(r).forEach(([n,o])=>t.on(n,o)),()=>{Object.entries(r).forEach(([n,o])=>t.removeListener(n,o))}),[...Object.keys(r),...e]),d(t.emit.bind(t),[t])}function g(){let{currentContext:r}=R();if(r==null)throw w();return r}function ne(r,e){let{parameters:t}=g();if(r)return t[r]??e}function ae(){let r=y.getChannel(),{id:e,args:t}=g(),n=d(a=>r.emit(i.UPDATE_STORY_ARGS,{storyId:e,updatedArgs:a}),[r,e]),o=d(a=>r.emit(i.RESET_STORY_ARGS,{storyId:e,argNames:a}),[r,e]);return[t,n,o]}function se(){let r=y.getChannel(),{globals:e}=g(),t=d(n=>r.emit(i.UPDATE_GLOBALS,{globals:n}),[r]);return[e,t]}var ie=y;0&&(module.exports={AddonStore,Channel,HooksContext,addons,applyHooks,isSupportedType,makeDecorator,mockChannel,types,useArgs,useCallback,useChannel,useEffect,useGlobals,useMemo,useParameter,useReducer,useRef,useState,useStoryContext});
