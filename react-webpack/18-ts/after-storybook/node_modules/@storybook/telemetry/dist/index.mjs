var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});

// <define:process.env>
var define_process_env_default = {};

// src/index.ts
import { logger as logger2 } from "@storybook/client-logger";

// src/storybook-metadata.ts
import readPkgUp from "read-pkg-up";
import { detect, getNpmVersion } from "detect-package-manager";
import {
  loadMainConfig,
  getStorybookInfo,
  getStorybookConfiguration,
  getProjectRoot as getProjectRoot2
} from "@storybook/core-common";

// src/package-versions.ts
import path from "path";
var getActualPackageVersions = async (packages) => {
  const packageNames = Object.keys(packages);
  return Promise.all(packageNames.map(getActualPackageVersion));
};
var getActualPackageVersion = async (packageName) => {
  try {
    const packageJson = __require(path.join(packageName, "package.json"));
    return {
      name: packageName,
      version: packageJson.version
    };
  } catch (err) {
    return { name: packageName, version: null };
  }
};

// src/get-monorepo-type.ts
import fs from "fs-extra";
import path2 from "path";
import { getProjectRoot } from "@storybook/core-common";
var monorepoConfigs = {
  Nx: "nx.json",
  Turborepo: "turbo.json",
  Lerna: "lerna.json",
  Rush: "rush.json",
  Lage: "lage.config.json"
};
var getMonorepoType = () => {
  const projectRootPath = getProjectRoot();
  if (!projectRootPath)
    return void 0;
  const keys = Object.keys(monorepoConfigs);
  const monorepoType = keys.find((monorepo) => {
    const configFile = path2.join(projectRootPath, monorepoConfigs[monorepo]);
    return fs.existsSync(configFile);
  });
  if (monorepoType) {
    return monorepoType;
  }
  if (!fs.existsSync(path2.join(projectRootPath, "package.json"))) {
    return void 0;
  }
  const packageJson = fs.readJsonSync(path2.join(projectRootPath, "package.json"));
  if (packageJson?.workspaces) {
    return "Workspaces";
  }
  return void 0;
};

// src/sanitize.ts
import { sep } from "path";
function regexpEscape(str) {
  return str.replace(/[-[/{}()*+?.\\^$|]/g, `\\$&`);
}
function cleanPaths(str, separator = sep) {
  if (!str)
    return str;
  const stack = process.cwd().split(separator);
  while (stack.length > 1) {
    const currentPath = stack.join(separator);
    const currentRegex = new RegExp(regexpEscape(currentPath), `g`);
    str = str.replace(currentRegex, `$SNIP`);
    const currentPath2 = stack.join(separator + separator);
    const currentRegex2 = new RegExp(regexpEscape(currentPath2), `g`);
    str = str.replace(currentRegex2, `$SNIP`);
    stack.pop();
  }
  return str;
}
function sanitizeError(error, pathSeparator = sep) {
  error = JSON.parse(JSON.stringify(error, Object.getOwnPropertyNames(error)));
  const errorString = cleanPaths(JSON.stringify(error), pathSeparator);
  return JSON.parse(errorString);
}

// src/storybook-metadata.ts
var metaFrameworks = {
  next: "Next",
  "react-scripts": "CRA",
  gatsby: "Gatsby",
  "@nuxtjs/storybook": "nuxt",
  "@nrwl/storybook": "nx",
  "@vue/cli-service": "vue-cli",
  "@sveltejs/kit": "svelte-kit"
};
var getFrameworkOptions = (mainConfig) => {
  const possibleOptions = [
    "angular",
    "ember",
    "html",
    "preact",
    "react",
    "server",
    "svelte",
    "vue",
    "vue3",
    "webComponents"
  ].map((opt) => `${opt}Options`);
  for (const opt of possibleOptions) {
    if (opt in mainConfig) {
      return mainConfig[opt];
    }
  }
  return void 0;
};
var sanitizeAddonName = (name) => {
  return cleanPaths(name).replace(/\/dist\/.*/, "").replace(/\.[mc]?[tj]?s[x]?$/, "").replace(/\/register$/, "").replace(/\/manager$/, "").replace(/\/preset$/, "");
};
var computeStorybookMetadata = async ({
  packageJson,
  mainConfig
}) => {
  const metadata = {
    generatedAt: new Date().getTime(),
    builder: { name: "webpack5" },
    hasCustomBabel: false,
    hasCustomWebpack: false,
    hasStaticDirs: false,
    hasStorybookEslint: false,
    refCount: 0
  };
  const allDependencies = {
    ...packageJson?.dependencies,
    ...packageJson?.devDependencies,
    ...packageJson?.peerDependencies
  };
  const metaFramework = Object.keys(allDependencies).find((dep) => !!metaFrameworks[dep]);
  if (metaFramework) {
    const { version } = await getActualPackageVersion(metaFramework);
    metadata.metaFramework = {
      name: metaFrameworks[metaFramework],
      packageName: metaFramework,
      version
    };
  }
  const monorepoType = getMonorepoType();
  if (monorepoType) {
    metadata.monorepo = monorepoType;
  }
  try {
    const packageManagerType = await detect({ cwd: getProjectRoot2() });
    const packageManagerVerson = await getNpmVersion(packageManagerType);
    metadata.packageManager = {
      type: packageManagerType,
      version: packageManagerVerson
    };
  } catch (err) {
  }
  metadata.hasCustomBabel = !!mainConfig.babel;
  metadata.hasCustomWebpack = !!mainConfig.webpackFinal;
  metadata.hasStaticDirs = !!mainConfig.staticDirs;
  if (mainConfig.typescript) {
    metadata.typescriptOptions = mainConfig.typescript;
  }
  if (mainConfig.core?.builder) {
    const { builder } = mainConfig.core;
    metadata.builder = {
      name: typeof builder === "string" ? builder : builder.name,
      options: typeof builder === "string" ? void 0 : builder?.options ?? void 0
    };
  }
  if (mainConfig.refs) {
    metadata.refCount = Object.keys(mainConfig.refs).length;
  }
  if (mainConfig.features) {
    metadata.features = mainConfig.features;
  }
  const addons = {};
  if (mainConfig.addons) {
    mainConfig.addons.forEach((addon) => {
      let addonName;
      let options;
      if (typeof addon === "string") {
        addonName = sanitizeAddonName(addon);
      } else {
        options = addon.options;
        addonName = sanitizeAddonName(addon.name);
      }
      addons[addonName] = {
        options,
        version: void 0
      };
    });
  }
  const addonVersions = await getActualPackageVersions(addons);
  addonVersions.forEach(({ name, version }) => {
    addons[name].version = version;
  });
  const addonNames = Object.keys(addons);
  const storybookPackages = Object.keys(allDependencies).filter((dep) => dep.includes("storybook") && !addonNames.includes(dep)).reduce((acc, dep) => {
    return {
      ...acc,
      [dep]: { version: void 0 }
    };
  }, {});
  const storybookPackageVersions = await getActualPackageVersions(storybookPackages);
  storybookPackageVersions.forEach(({ name, version }) => {
    storybookPackages[name].version = version;
  });
  const language = allDependencies.typescript ? "typescript" : "javascript";
  const hasStorybookEslint = !!allDependencies["eslint-plugin-storybook"];
  const storybookInfo = getStorybookInfo(packageJson);
  const storybookVersion = storybookPackages[storybookInfo.frameworkPackage]?.version || storybookInfo.version;
  return {
    ...metadata,
    storybookVersion,
    language,
    storybookPackages,
    framework: {
      name: storybookInfo.framework,
      options: getFrameworkOptions(mainConfig)
    },
    addons,
    hasStorybookEslint
  };
};
var cachedMetadata;
var getStorybookMetadata = async (_configDir) => {
  if (cachedMetadata) {
    return cachedMetadata;
  }
  const { packageJson = {} } = readPkgUp.sync({ cwd: process.cwd(), normalize: false }) || {};
  const configDir = (_configDir || getStorybookConfiguration(
    packageJson?.scripts?.storybook || "",
    "-c",
    "--config-dir"
  )) ?? ".storybook";
  const mainConfig = loadMainConfig({ configDir });
  cachedMetadata = await computeStorybookMetadata({ mainConfig, packageJson });
  return cachedMetadata;
};

// src/telemetry.ts
import originalFetch from "isomorphic-unfetch";
import retry from "fetch-retry";
import { nanoid } from "nanoid";

// src/anonymous-id.ts
import path3 from "path";
import { execSync } from "child_process";
import { getProjectRoot as getProjectRoot3 } from "@storybook/core-common";

// src/one-way-hash.ts
import { createHash } from "crypto";
var oneWayHash = (payload) => {
  const hash = createHash("sha256");
  hash.update("storybook-telemetry-salt");
  hash.update(payload);
  return hash.digest("hex");
};

// src/anonymous-id.ts
var anonymousProjectId;
var getAnonymousProjectId = () => {
  if (anonymousProjectId) {
    return anonymousProjectId;
  }
  let unhashedProjectId;
  try {
    const projectRoot = getProjectRoot3();
    const projectRootPath = path3.relative(projectRoot, process.cwd());
    const originBuffer = execSync(`git config --local --get remote.origin.url`, {
      timeout: 1e3,
      stdio: `pipe`
    });
    unhashedProjectId = `${String(originBuffer).trim()}${projectRootPath}`;
    anonymousProjectId = oneWayHash(unhashedProjectId);
  } catch (_) {
  }
  return anonymousProjectId;
};

// src/telemetry.ts
var URL = "https://storybook.js.org/event-log";
var fetch = retry(originalFetch);
var tasks = [];
var sessionId = nanoid();
async function sendTelemetry(data, options = { retryDelay: 1e3, immediate: false }) {
  const { payload, metadata, ...rest } = data;
  const context = {
    anonymousId: getAnonymousProjectId(),
    inCI: define_process_env_default.CI === "true"
  };
  const eventId = nanoid();
  const body = { ...rest, eventId, sessionId, metadata, payload, context };
  let request;
  try {
    request = fetch(URL, {
      method: "POST",
      body: JSON.stringify(body),
      headers: { "Content-Type": "application/json" },
      retries: 3,
      retryOn: [503, 504],
      retryDelay: (attempt) => 2 ** attempt * (typeof options?.retryDelay === "number" && !Number.isNaN(options?.retryDelay) ? options.retryDelay : 1e3)
    });
    tasks.push(request);
    if (options.immediate) {
      await Promise.all(tasks);
    } else {
      await request;
    }
  } catch (err) {
  } finally {
    tasks = tasks.filter((task) => task !== request);
  }
}

// src/notify.ts
import chalk from "chalk";
import { cache } from "@storybook/core-common";
var TELEMETRY_KEY_NOTIFY_DATE = "telemetry-notification-date";
var logger = console;
var notify = async () => {
  const telemetryNotifyDate = await cache.get(TELEMETRY_KEY_NOTIFY_DATE, null);
  if (telemetryNotifyDate) {
    return;
  }
  cache.set(TELEMETRY_KEY_NOTIFY_DATE, Date.now());
  logger.log();
  logger.log(
    `${chalk.magenta.bold(
      "attention"
    )} => Storybook now collects completely anonymous telemetry regarding usage.`
  );
  logger.log(`This information is used to shape Storybook's roadmap and prioritize features.`);
  logger.log(
    `You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:`
  );
  logger.log(chalk.cyan("https://storybook.js.org/telemetry"));
  logger.log();
};

// src/index.ts
var telemetry = async (eventType, payload = {}, options = {}) => {
  await notify();
  const telemetryData = {
    eventType,
    payload
  };
  try {
    telemetryData.metadata = await getStorybookMetadata(options?.configDir);
  } catch (error) {
    if (!telemetryData.payload.error)
      telemetryData.payload.error = error;
  } finally {
    const { error } = telemetryData.payload;
    if (error) {
      telemetryData.payload.error = sanitizeError(error);
    }
    if (!telemetryData.payload.error || options?.enableCrashReports) {
      if (define_process_env_default?.STORYBOOK_DEBUG_TELEMETRY) {
        logger2.info("\n[telemetry]");
        logger2.info(JSON.stringify(telemetryData, null, 2));
      } else {
        await sendTelemetry(telemetryData, options);
      }
    }
  }
};
export {
  computeStorybookMetadata,
  getStorybookMetadata,
  metaFrameworks,
  sanitizeAddonName,
  telemetry
};
